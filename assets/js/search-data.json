{"0": {
    "doc": "Looping",
    "title": "Looping",
    "content": "This chapter deals with structure loops, not Process loops. ",
    "url": "https://ossia.io/score-docs/common-practices/1-looping.html",
    "relUrl": "/common-practices/1-looping.html"
  },"1": {
    "doc": "Looping",
    "title": "Loop with transitions",
    "content": "To enable the repetition of certain parts of a Scenario, we use transitions to go “back in time”. Transitions are instantaneous intervals that can connect two states regardless of their chronological relationship. In this case, the loop will go on forever as well as playing and replaying all following intervals. ",
    "url": "https://ossia.io/score-docs/common-practices/1-looping.html#loop-with-transitions",
    "relUrl": "/common-practices/1-looping.html#loop-with-transitions"
  },"2": {
    "doc": "Looping",
    "title": "Nested loops",
    "content": "For more control and to avoid perpetual looping and branching, it may be necessary to isolate a repeating structure in a sub-scenario. Triggering the end of the interval containing the sub-scenario will ensure that the loop stops as well as the execution of the following intervals. ",
    "url": "https://ossia.io/score-docs/common-practices/1-looping.html#nested-loops",
    "relUrl": "/common-practices/1-looping.html#nested-loops"
  },"3": {
    "doc": "Looping",
    "title": "Repetition amount",
    "content": "Adding a trigger on the last Sync of a loop and setting its maximum duration allows to control the amount of repetition. The trigger left by default to be “never” true will still be validated when the maximum duration of the preceding interval has been reached. With this method, the time spent looping is equal to the loop duration + the maximum duration, and can be fine-tuned by manipulating the closing parenthesis. ",
    "url": "https://ossia.io/score-docs/common-practices/1-looping.html#repetition-amount",
    "relUrl": "/common-practices/1-looping.html#repetition-amount"
  },"4": {
    "doc": "Looping",
    "title": "Loop branches",
    "content": "Transitions actually connect to Syncs (vertical doted lines), thus, transitioning to a specific Sync will execute or re-execute all connected branches. When several transitions are connected to the same Sync, the smallest loop will then always restart first and cut short all parallel intervals. Transitions can provide a workaround in this situation. Since transitions are instantaneous intervals, they can also be used to isolate parallel loops without interfering with timing and their original synchronization. ",
    "url": "https://ossia.io/score-docs/common-practices/1-looping.html#loop-branches",
    "relUrl": "/common-practices/1-looping.html#loop-branches"
  },"5": {
    "doc": "Livestreaming",
    "title": "Livestreaming",
    "content": "This page explains how to set-up a livestream in various manners. | Livestreaming | Livestreaming with OBS Studio . | On Windows | On macOS | On Linux . | Streaming video outputs | Streaming audio outputs | . | . | Livestreaming from the command line under Linux . | Livestreaming through RTP with GStreamer | Livestreaming audio and video to Twitch (and other RTMP systems) | . | Configuring Jitsi for high-quality streams | . ",
    "url": "https://ossia.io/score-docs/common-practices/10-livestreaming.html",
    "relUrl": "/common-practices/10-livestreaming.html"
  },"6": {
    "doc": "Livestreaming",
    "title": "Livestreaming with OBS Studio",
    "content": "OBS Studio is a leading free software streaming solution, which is supported on Linux, Windows and macOS. ",
    "url": "https://ossia.io/score-docs/common-practices/10-livestreaming.html#livestreaming-with-obs-studio",
    "relUrl": "/common-practices/10-livestreaming.html#livestreaming-with-obs-studio"
  },"7": {
    "doc": "Livestreaming",
    "title": "On Windows",
    "content": "On Windows, we recommend using Spout (available since score 3.0.4) to stream a video output to OBS. | This requires the following OBS plug-in: Off-World-Live/obs-spout2-plugin. | Once OBS is launched, add a “Spout2 Input” source. | In score, add a Spout2 output, and set it as the output of the video effect chain you are working on. | For streaming audio to OBS, the WASAPI audio output of score should be used, as ASIO drivers may not have loopback capabilities, making OBS unable to record the audio output coming from score. | Add an “Audio output capture” for getting the sound output of score into OBS. | . ",
    "url": "https://ossia.io/score-docs/common-practices/10-livestreaming.html#on-windows",
    "relUrl": "/common-practices/10-livestreaming.html#on-windows"
  },"8": {
    "doc": "Livestreaming",
    "title": "On macOS",
    "content": "On macOS, we recommend using Syphon (available since score 3.0.4) to stream a video output to OBS. You will need the free Syphon Virtual Webcam to be able to see Syphon video streams in OBS. ",
    "url": "https://ossia.io/score-docs/common-practices/10-livestreaming.html#on-macos",
    "relUrl": "/common-practices/10-livestreaming.html#on-macos"
  },"9": {
    "doc": "Livestreaming",
    "title": "On Linux",
    "content": "We recommend using GStreamer with shmdata and V4L2 to stream a video output from score to OBS ; this will create a virtual camera that can also be used in web browsers, etc. Streaming video outputs . | Install v4l2loopback, gstreamer, obs-studio. They are available in most distributions’ package repositories. | Reboot or load the module: sudo modprobe v4l2loopback card_label=\"Virtual camera\". | Test that a simple pipeline works: | . $ sudo gst-launch-1.0 videotestsrc ! v4l2sink device=/dev/video0 . If it fails, consider reloading the module with the additional option max_buffers=16. | Install Shmdata and add it to the GStreamer plug-ins. | . This generally means copying libgstshmdata.so in /usr/lib/gstreamer-1.0/. | In score, add a Shmdata output device, and set it as the output of the video effect chain you are working on. | Create a GStreamer pipeline which will pipe the Shmdata output of score into a V4L2 virtual camera. Assuming /tmp/score_shm_video as the shmdata socket path, this gives: | . $ sudo gst-launch-1.0 shmdatasrc socket-path=/tmp/score_shm_video \\ ! videoconvert \\ ! video/x-raw, format=NV12 \\ ! queue \\ ! v4l2sink device=/dev/video0 . Streaming audio outputs . Simply using JACK or PipeWire works ; OBS is able to take such audio input streams through the “JACK input client” source. Then use your favorite routing GUI to route score’s output into OBS. ",
    "url": "https://ossia.io/score-docs/common-practices/10-livestreaming.html#on-linux",
    "relUrl": "/common-practices/10-livestreaming.html#on-linux"
  },"10": {
    "doc": "Livestreaming",
    "title": "Livestreaming from the command line under Linux",
    "content": " ",
    "url": "https://ossia.io/score-docs/common-practices/10-livestreaming.html#livestreaming-from-the-command-line-under-linux",
    "relUrl": "/common-practices/10-livestreaming.html#livestreaming-from-the-command-line-under-linux"
  },"11": {
    "doc": "Livestreaming",
    "title": "Livestreaming through RTP with GStreamer",
    "content": "RTP is the standard low-level network protocol for streaming audio and video data. To stream to RTP as efficiently as possible from score, we are going to leverage the Shmdata plug-in, and GStreamer. We will stream with the classic MJPEG codec for simplicity in this example ; depending on your system other codecs could be more efficient: x264, HEVC, VP8, etc. Refer to the GStreamer documentation to know how to encode in these formats. First, create a Shmdata video output (writing on the /tmp/score_shm_video path) on score and some video content to stream, then hit play. Then run GStreamer (the Shmdata devices plug-in is needed): . $ gst-launch-1.0 \\ shmdatasrc socket-path=/tmp/score_shm_video \\ ! videoconvert \\ ! video/x-raw, format=I420 \\ ! queue \\ ! jpegenc \\ ! rtpjpegpay \\ ! udpsink host=127.0.0.1 port=5000 . Create the following file (mjpeg.sdp for instance) which represents the stream: . v=0 m=video 5000 RTP/AVP 26 a=rtpmap:26 JPEG/90000; a=decode_buf=300; c=IN IP4 127.0.0.1 . You can now read the stream, for instance with ffplay, vlc, mpv… . $ ffplay mjpeg.sdp . Note: the format of SDP is: . v=&lt;version&gt; o= &lt;owner&gt; IN IP4 &lt;IP4 ADDRESS&gt; c=IN IP4 &lt;IP4 ADDRESS&gt; s=&lt;STREAM \"HUMAN\" DESCRIPTION&gt; m=&lt;media&gt; &lt;udp port&gt; RTP/AVP &lt;payload&gt; a=rtpmap:&lt;payload&gt; &lt;encoding-name&gt;/&lt;clock-rate&gt;[/&lt;encoding-params&gt;] a=fmtp:&lt;payload&gt; &lt;param&gt;=&lt;value&gt;;... ",
    "url": "https://ossia.io/score-docs/common-practices/10-livestreaming.html#livestreaming-through-rtp-with-gstreamer",
    "relUrl": "/common-practices/10-livestreaming.html#livestreaming-through-rtp-with-gstreamer"
  },"12": {
    "doc": "Livestreaming",
    "title": "Livestreaming audio and video to Twitch (and other RTMP systems)",
    "content": "Here is an example pipeline, which assumes PipeWire for audio: . $ export STREAM_URL=\"rtmp://mrs02.contribute.live-video.net/app/&lt;YOUR_TWITCH_KEY&gt;\" $ export FPS=30 $ export CHANNELS=2 $ export BITRATE=6000 $ gst-launch-1.0 shmdatasrc socket-path=/tmp/score_shm_video \\ ! videoconvert \\ ! video/x-raw, format=NV12 \\ ! queue \\ ! x264enc bitrate=$BITRATE tune=zerolatency key-int-max=30 \\ ! flvmux streamable=true name=flvmux \\ ! rtmpsink location=\"$STREAM_URL\" \\ pipewiresrc client-name=my-stream \\ ! audio/x-raw,format=F32LE,channels=$CHANNELS \\ ! audioconvert \\ ! faac \\ ! flvmux. Use the following link to choose a correct stream url: https://stream.twitch.tv/ingests. If you are using Jack, use jackaudiosrc instead of pipewiresrc, and do not forget to connect the score audio outputs to the PipeWire / JACK object’s inputs (called my-stream in this example). ",
    "url": "https://ossia.io/score-docs/common-practices/10-livestreaming.html#livestreaming-audio-and-video-to-twitch-and-other-rtmp-systems",
    "relUrl": "/common-practices/10-livestreaming.html#livestreaming-audio-and-video-to-twitch-and-other-rtmp-systems"
  },"13": {
    "doc": "Livestreaming",
    "title": "Configuring Jitsi for high-quality streams",
    "content": "If you use Jitsi, by default the sound and video quality may be low and optimized for talking rather than music. You can open your Jitsi room with the following set of parameters after the room name to increase the available video and audio quality, and enable stereo sound (if the browsers used support it): . https://meet.jit.si/&lt;JITSI_ROOM_NAME&gt;#config.disableAP=true&amp;config.disableAEC=true&amp;config.disableNS=true&amp;config.disableAGC=true&amp;config.disableHPF=true&amp;config.stereo=true&amp;config.enableLipSync=false&amp;config.p2p.enabled=false&amp;config.prejoinPageEnabled=false&amp;config.resolution=1080 . Note that for these parameters to be taken into account, the room must not have been created yet (that is, no one must have joined https://meet.jit.si/&lt;JITSI_ROOM_NAME&gt; already). ",
    "url": "https://ossia.io/score-docs/common-practices/10-livestreaming.html#configuring-jitsi-for-high-quality-streams",
    "relUrl": "/common-practices/10-livestreaming.html#configuring-jitsi-for-high-quality-streams"
  },"14": {
    "doc": "Video mixing and mapping",
    "title": "Video mixing",
    "content": "The user library provides an eight-channel video mixing object. It is available in the process library in the section: . Visuals &gt; ISF Shader &gt; Utility &gt; Video Mixer . It allows to choose opacity and blend mode for the eight input sources. Any improvement is welcome ! . ",
    "url": "https://ossia.io/score-docs/common-practices/11-video-mixing-and-mapping.html#video-mixing",
    "relUrl": "/common-practices/11-video-mixing-and-mapping.html#video-mixing"
  },"15": {
    "doc": "Video mixing and mapping",
    "title": "Video mapping",
    "content": "Likewise, the library provides a simple 4-point video mapping object (nothing advanced such as smooth edge, etc). ",
    "url": "https://ossia.io/score-docs/common-practices/11-video-mixing-and-mapping.html#video-mapping",
    "relUrl": "/common-practices/11-video-mixing-and-mapping.html#video-mapping"
  },"16": {
    "doc": "Video mixing and mapping",
    "title": "Video mixing and mapping",
    "content": " ",
    "url": "https://ossia.io/score-docs/common-practices/11-video-mixing-and-mapping.html",
    "relUrl": "/common-practices/11-video-mixing-and-mapping.html"
  },"17": {
    "doc": "Switches",
    "title": "Switches",
    "content": " ",
    "url": "https://ossia.io/score-docs/common-practices/2-switches.html",
    "relUrl": "/common-practices/2-switches.html"
  },"18": {
    "doc": "Switches",
    "title": "Single trigger",
    "content": "Adding a trigger at either end of a looping interval provides control over each repetition. If the trigger is enabled at the beginning of the interval, it controls the start and restarts of the loop. When time reaches the end of the interval, the transition returns to the start Sync where the execution is suspended again until re-triggered. In this case, the interval’s execution must reach its end before it can be restarted. If the trigger is enabled at the end of the loop, it provides flexible time to the interval. As soon as the interval begins executing, it can be interrupted by the validation of the trigger and transition back to the beginning. ",
    "url": "https://ossia.io/score-docs/common-practices/2-switches.html#single-trigger",
    "relUrl": "/common-practices/2-switches.html#single-trigger"
  },"19": {
    "doc": "Switches",
    "title": "On / Off",
    "content": "Combining both the above options, an interval can be toggled on and off at will. This method, like the previous, can also be directly mapped to various devices featuring buttons, keys, hardware switches or any kind of discrete value streams. In this case we will use the first button of a game controller accessed through the Joystick Device. When the button is pressed, the first trigger is validated (as by default, it is set to “pulse”) and will respond to any value received at the provided address. When the button is released, the end trigger is validated in the same way, before the transition returns to the initial Sync. ",
    "url": "https://ossia.io/score-docs/common-practices/2-switches.html#on--off",
    "relUrl": "/common-practices/2-switches.html#on--off"
  },"20": {
    "doc": "Switches",
    "title": "Consecutive toggles",
    "content": "The section inside the loop can contain more than one interval. Expanding on the prior example, switching between an idle state and an interval, a similar structure could enclose two intervals. This switch also requires an extra trigger. With the default “Pulse” operators to validate each trigger, this structure will return to the idle state after each transition. To avoid this extra step and make sure that the first interval executes every time the button’s value is true and that the second executes every time it is false, the expression for the trigger has to be modified. By setting both the start and end triggers to only respond when the value is true, they can be validated in a row, skipping the idle state after the transition.  . A better way of achieving the same result would be to rely on a sub-scenario to isolate the loop. Since the first trigger is only needed to control the very first execution of the loop, it can be validated once to enter the sub-scenario and omitted in the actual toggle structure. The trigger at the end of the sub-scenario is left “never” valid to allow as many repetitions as needed. It may be preferable to switch at every press of the button, instead of having to hold for the first interval and let go for the second. Adding a minimum duration on each of the toggled intervals ensures that the value of the button can go back to false without validating the next trigger. This method also protects the switch from accidental “double taps”. ",
    "url": "https://ossia.io/score-docs/common-practices/2-switches.html#consecutive-toggles",
    "relUrl": "/common-practices/2-switches.html#consecutive-toggles"
  },"21": {
    "doc": "Switches",
    "title": "Parallel switches",
    "content": "Consecutive switches shown above can sequence an arbitrary number of intervals, but only in the same order every time. To enable switching as well as reordering, we can rely on conditional branches. Let’s first create another device for control. For this example we will add a Mapper device by copying and pasting the script below. We will name it “Structure”. import Ossia 1.0 as Ossia Ossia.Mapper { function createTree() { return [ { name: \"Branch\", type: Ossia.Type.Int, write: function(v) { return v.value; } } ]; } } . Parallel branches start from the same Sync. Syncing them at the end too will also make them responsive to the same trigger and allow us to only set up one transition to loop the entire structure. To add conditions for each start state of parallel intervals, they have to be split into individual events with the “Split condition” function. The state connecting the transition back to the initial Sync does not require a condition. Finally, a trigger on the end Sync can reset the loop with every new value set in the mapper. It is now possible to switch between parallel intervals when setting a value to the “Branch” parameter. To control the start of the structure when played the first time, we have to avoid adding a trigger to the start sync of the loop. It would add an idle state as we experienced before and skip the evaluation of every other value. Instead we can isolate this switch from its initial trigger with another transition, similar to our solution to looping parallel branches. ",
    "url": "https://ossia.io/score-docs/common-practices/2-switches.html#parallel-switches",
    "relUrl": "/common-practices/2-switches.html#parallel-switches"
  },"22": {
    "doc": "2D Spline",
    "title": "2D Spline (X-Y automation)",
    "content": ". The 2D spline is a process which allows to control a 2D position in time, by modifying a curve in the user interface. ",
    "url": "https://ossia.io/score-docs/processes/2Dspline.html#2d-spline-x-y-automation",
    "relUrl": "/processes/2Dspline.html#2d-spline-x-y-automation"
  },"23": {
    "doc": "2D Spline",
    "title": "Modifying the spline",
    "content": "Points can be dragged with the mouse. | To create a new control point, double-click on the curve. | To remove a point, double-click on it. | Due to the way cubic splines work, there cannot be less than four points. | . ",
    "url": "https://ossia.io/score-docs/processes/2Dspline.html#modifying-the-spline",
    "relUrl": "/processes/2Dspline.html#modifying-the-spline"
  },"24": {
    "doc": "2D Spline",
    "title": "Generating a curve",
    "content": "It is possible to use math formulas to generate a specific spline. To do so, right-click on a spline, and select Generate curve in the menu. The available variable is t. It is evaluated between 0 and 1. The syntax uses ExprTK (see ExprTK support reference page). Here are some useful examples: . ",
    "url": "https://ossia.io/score-docs/processes/2Dspline.html#generating-a-curve",
    "relUrl": "/processes/2Dspline.html#generating-a-curve"
  },"25": {
    "doc": "2D Spline",
    "title": "Circle",
    "content": "var tp := 2 * PI * t; x := tp * cos(tp); y := tp * sin(tp); . ",
    "url": "https://ossia.io/score-docs/processes/2Dspline.html#circle",
    "relUrl": "/processes/2Dspline.html#circle"
  },"26": {
    "doc": "2D Spline",
    "title": "Spiral",
    "content": "var tp := 2 * PI * t; x := tp * cos(tp); y := tp * sin(tp); . ",
    "url": "https://ossia.io/score-docs/processes/2Dspline.html#spiral",
    "relUrl": "/processes/2Dspline.html#spiral"
  },"27": {
    "doc": "2D Spline",
    "title": "Expanding spiral",
    "content": "var tp := 2 * PI * t; x := 0.04 * exp(0.3 * tp) * cos(tp); y := 0.04 * exp(0.3 * tp) * sin(tp); . ",
    "url": "https://ossia.io/score-docs/processes/2Dspline.html#expanding-spiral",
    "relUrl": "/processes/2Dspline.html#expanding-spiral"
  },"28": {
    "doc": "2D Spline",
    "title": "Lissajoux",
    "content": "var tp := 2 * PI * t; x := cos(3 * tp); y := sin(2 * tp); . var tp := 2 * PI * t; x := cos(5 * tp); y := sin(3 * tp); . ",
    "url": "https://ossia.io/score-docs/processes/2Dspline.html#lissajoux",
    "relUrl": "/processes/2Dspline.html#lissajoux"
  },"29": {
    "doc": "2D Spline",
    "title": "Hypotrochroids",
    "content": "Star 1 . var tp := 6 * PI * t; var a := 5; var b := 3; var d := 3; x := (a - b) * cos(tp) + d * cos(tp * (a - b) / b); y := (a - b) * sin(tp) - d * sin(tp * (a - b) / b); . Star 2 . var tp := 6 * PI * t; var a := 5; var b := 3; var d := 5; x := (a - b) * cos(tp) + d * cos(tp * (a - b) / b); y := (a - b) * sin(tp) - d * sin(tp * (a - b) / b); . ",
    "url": "https://ossia.io/score-docs/processes/2Dspline.html#hypotrochroids",
    "relUrl": "/processes/2Dspline.html#hypotrochroids"
  },"30": {
    "doc": "2D Spline",
    "title": "Others",
    "content": "See https://en.wikipedia.org/wiki/Parametric_equation for inspiration. var tp := 2 * PI * t; var a := 4; var b := 1; var c := 4; var d := 1; var j := 3; var k := 3; x := cos(a * tp) - pow(cos(b * tp), j); y := sin(c * tp) - pow(sin(d * tp), k); . var tp := 2 * PI * t; var a := 80; var b := 1; var c := 80; var d := 1; var j := 3; var k := 3; x := cos(a * tp) - pow(cos(b * tp), j); y := sin(c * tp) - pow(sin(d * tp), k); . ",
    "url": "https://ossia.io/score-docs/processes/2Dspline.html#others",
    "relUrl": "/processes/2Dspline.html#others"
  },"31": {
    "doc": "2D Spline",
    "title": "2D Spline",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/2Dspline.html",
    "relUrl": "/processes/2Dspline.html"
  },"32": {
    "doc": "Out-of-time triggering",
    "title": "Out-of-time triggering",
    "content": "By default, score works as a time-line: time flows from the start to the end of the score. As mentioned by the quick start guide, the time-line can be made non-linear by adding triggers and graph connections. It is possible to go one step further, by entirely removing parts of the score from the “main” timeline and triggering them at any point in time: for instance in response to an OSC message, by clicking, … . ",
    "url": "https://ossia.io/score-docs/common-practices/3-out-of-time.html",
    "relUrl": "/common-practices/3-out-of-time.html"
  },"33": {
    "doc": "Out-of-time triggering",
    "title": "Creating an out-of-time score",
    "content": "To remove a part of the score from the time-line, simply make sure that it isn’t connected to the start of the time-line: . When playing the score, this interval now won’t run anymore: . Some score users use that mechanism as a sand-box to try various behaviours. Now, to play this part of the score, we have to tell score what is going to trigger it. Thus, we have to add a trigger to the start of the interval: . Then, select the trigger, go to the inspector and enable the “Start on play” which will make the trigger available for triggering when the score starts, with the right button: . ",
    "url": "https://ossia.io/score-docs/common-practices/3-out-of-time.html#creating-an-out-of-time-score",
    "relUrl": "/common-practices/3-out-of-time.html#creating-an-out-of-time-score"
  },"34": {
    "doc": "Out-of-time triggering",
    "title": "Re-triggering",
    "content": "The left button in the inspector is used to control the re-triggering behaviour. If left unchecked, re-triggering the trigger will stop the sub-score that follows it. It will need another event to start again. If checked, it will restart automatically from the beginning every time the trigger is triggered. ",
    "url": "https://ossia.io/score-docs/common-practices/3-out-of-time.html#re-triggering",
    "relUrl": "/common-practices/3-out-of-time.html#re-triggering"
  },"35": {
    "doc": "Out-of-time triggering",
    "title": "Triggering intervals",
    "content": "When the main score is playing, play / stop buttons will appear on top of intervals when hovered. These allow to stop or start an interval while entirely discarding any semantics that may have been set in the score. This will respect the quantization settings by default. ",
    "url": "https://ossia.io/score-docs/common-practices/3-out-of-time.html#triggering-intervals",
    "relUrl": "/common-practices/3-out-of-time.html#triggering-intervals"
  },"36": {
    "doc": "Audio techniques",
    "title": "Audio techniques",
    "content": " ",
    "url": "https://ossia.io/score-docs/common-practices/4-audio.html",
    "relUrl": "/common-practices/4-audio.html"
  },"37": {
    "doc": "Audio techniques",
    "title": "Playing a sound file",
    "content": "To play a sound file, drag’n’drop it in the score, from the library, or from your operating system. If you don’t hear a sound, check that : . | The time cursor is increasing (if not, that means that the sound card is not properly configured). | The sound file is linked to the beginning of the score via an interval. | . It should look like this: . ",
    "url": "https://ossia.io/score-docs/common-practices/4-audio.html#playing-a-sound-file",
    "relUrl": "/common-practices/4-audio.html#playing-a-sound-file"
  },"38": {
    "doc": "Audio techniques",
    "title": "Applying an effect",
    "content": "To apply an effect to a sound file: . | Drop it from the process library to the sound file interval. | Connect a cable from the audio file output to the effect input. Now the sound will be routed entirely through the effect. | Add more effects in the same manner, by connecting the output of the previous effects to the input of the following ones ! | . ",
    "url": "https://ossia.io/score-docs/common-practices/4-audio.html#applying-an-effect",
    "relUrl": "/common-practices/4-audio.html#applying-an-effect"
  },"39": {
    "doc": "Audio techniques",
    "title": "Applying an effect to multiple audio files",
    "content": "To apply an effect to multiple files, it would be possible but unwieldy to connect a cable from each file to the audio effect. Instead, we can group them in a single scenario, and rout the scenario’s output to the audio effects: . ",
    "url": "https://ossia.io/score-docs/common-practices/4-audio.html#applying-an-effect-to-multiple-audio-files",
    "relUrl": "/common-practices/4-audio.html#applying-an-effect-to-multiple-audio-files"
  },"40": {
    "doc": "Audio techniques",
    "title": "Fade-ins and fade-outs",
    "content": "Every audio outlet has a “gain” sub-outlet which can be used to perform fades. | Press the audio outlet. | Right-click on the “gain” port. | Select “Create automation”. | . The created automation can then be used to adjust the volume of that output in time. ",
    "url": "https://ossia.io/score-docs/common-practices/4-audio.html#fade-ins-and-fade-outs",
    "relUrl": "/common-practices/4-audio.html#fade-ins-and-fade-outs"
  },"41": {
    "doc": "Audio techniques",
    "title": "Analysing an audio signal",
    "content": "score provides a simple envelope analyzer. Combined with the signal display process, this allows to visualize a signal in the time-line. | Add an envelope process (Audio &gt; Envelope). | Add a signal display process (Monitoring &gt; Signal display) | Route the audio output to the input of the envelope process. This means that the entire audio is routed to the envelope process, and thus won’t be heard anymore. To prevent this, check “Propagate” in the audio outlet inspector. | Route the envelope output to the signal display input. The first output measures RMS, the second measures peak values. | If the signal is too low, add a Custom Mapping process between the envelope and the signal display, in order to multiply it by some factor meaningful for your signal. | . ",
    "url": "https://ossia.io/score-docs/common-practices/4-audio.html#analysing-an-audio-signal",
    "relUrl": "/common-practices/4-audio.html#analysing-an-audio-signal"
  },"42": {
    "doc": "Audio techniques",
    "title": "Sound spatialization",
    "content": "score allows arbitrary numbers of audio channels to go through its ports. This makes it possible to use it for instance with large speaker arrays, domes, etc. A simple and efficient 2D spatialization algorithm is provided with the Faust spat preset (which uses the spatialization method devised by Laurent Pottier). By default, it will spatialize a mono source on a 8-channel circular loudspeaker array. It is possible to edit the Faust script, to change the number of loudspeakers: . | Press the “Window” icon next to the Faust process name, to open its editor. | Edit the following line with the number of wanted loudspeakers instead of 8: . process = vgroup(\"Spatializer 1x8\", sp.spat(8, angle, distance)); . | Press “Compile”. The Faust process will be compiled and updated automatically. | . ",
    "url": "https://ossia.io/score-docs/common-practices/4-audio.html#sound-spatialization",
    "relUrl": "/common-practices/4-audio.html#sound-spatialization"
  },"43": {
    "doc": "Audio techniques",
    "title": "Using live audio input",
    "content": "To use a live audio input in a part of the score, follow these steps: . | Set-up the Audio device in the device explorer. | Drag’n’drop the input address to use as an input of a sound effect. | . In the following example, a stereo bus receiving a stereo guitar signal has been created. It is sent to a reverb. ",
    "url": "https://ossia.io/score-docs/common-practices/4-audio.html#using-live-audio-input",
    "relUrl": "/common-practices/4-audio.html#using-live-audio-input"
  },"44": {
    "doc": "Audio techniques",
    "title": "Applying global audio effects",
    "content": "As mentioned in Audio routing, mixing is by default hierarchical: objects mix their output in their parent object. In general, most scores will be built around a top-level scenario, which will contain all the structures: . This scenario is no exception to the rule: if you scroll at the bottom of the score, you’ll notice it comes with an output audio port, too. In this example, we reduce its slots’s height so that it is visible: . It is then possible to connect the output of this scenario to another process, to apply a global audio filter: . If complex filtering is necessary, it is of course possible to switch into the nodal view to create advanced effect routings: . ",
    "url": "https://ossia.io/score-docs/common-practices/4-audio.html#applying-global-audio-effects",
    "relUrl": "/common-practices/4-audio.html#applying-global-audio-effects"
  },"45": {
    "doc": "Video techniques",
    "title": "Video techniques",
    "content": " ",
    "url": "https://ossia.io/score-docs/common-practices/5-video.html",
    "relUrl": "/common-practices/5-video.html"
  },"46": {
    "doc": "Video techniques",
    "title": "Playing videos",
    "content": "See the quick start guide: Working with video. ",
    "url": "https://ossia.io/score-docs/common-practices/5-video.html#playing-videos",
    "relUrl": "/common-practices/5-video.html#playing-videos"
  },"47": {
    "doc": "Video techniques",
    "title": "Fades",
    "content": "To perform a fade, a simple way is to use the Set Alpha shader filter, provided as part of the user library. | Add the video file. | Add the filter. | Connect one to another. | Connect the filter output to the viewport. | Add an automation to control the opacity. | . Here is a complete example: . ",
    "url": "https://ossia.io/score-docs/common-practices/5-video.html#fades",
    "relUrl": "/common-practices/5-video.html#fades"
  },"48": {
    "doc": "Video techniques",
    "title": "Making audio-reactive visuals",
    "content": "The core idea is to extract a parameter from the sound, and use it to modify a parameter of a video filter. The Envelope process can be used to extract the average volume of an audio source. The volume is often small and needs to be adjusted to fit the control values ; the Micromap process allows to do that very easily. Here is a video example: . ",
    "url": "https://ossia.io/score-docs/common-practices/5-video.html#making-audio-reactive-visuals",
    "relUrl": "/common-practices/5-video.html#making-audio-reactive-visuals"
  },"49": {
    "doc": "Scenes",
    "title": "Scenes",
    "content": "Scenes are a common pattern in intermedia creation: you want to split a show for instance in a sequence of acts, chapters, etc. To achieve this in score, the general principle is to have sequences of intervals, each containing a sub-scenario. ",
    "url": "https://ossia.io/score-docs/common-practices/6-scenes.html",
    "relUrl": "/common-practices/6-scenes.html"
  },"50": {
    "doc": "Scenes",
    "title": "Structuring a score for dynamic scenes",
    "content": "To go from one scene to the next dynamically by responding to an interaction, it is sufficient to add triggers. It is also possible to use the Play from here tool to transport the timeline to a specific point. Don’t forget to label your scenes in the inspector to make the score easier to read: . ",
    "url": "https://ossia.io/score-docs/common-practices/6-scenes.html#structuring-a-score-for-dynamic-scenes",
    "relUrl": "/common-practices/6-scenes.html#structuring-a-score-for-dynamic-scenes"
  },"51": {
    "doc": "Scenes",
    "title": "Working with scenes",
    "content": "To work on a specific scene, simply go in “full view”. That is, either double-click on the interval header, or press the full view button in the interval inspector. If you have a lot of scenes, you can use the object finder (at the top-right) to find your scene by name or label: . ",
    "url": "https://ossia.io/score-docs/common-practices/6-scenes.html#working-with-scenes",
    "relUrl": "/common-practices/6-scenes.html#working-with-scenes"
  },"52": {
    "doc": "Start/stop cues",
    "title": "Start and stop cues",
    "content": "We want to send a cue whenever the score starts playing, and whenever it is stopped. To do so: . | Dropping a cue from the Device explorer on the first state at the top left of the score, in timeline view, will make that state being played: | Whenever the score is started (for instance when pressing the Global Play button). | Whenever the score is reinitialized (for instance when pressing the Reinitialize button). | Dropping a cue on the last state at the top right of the score, in timeline view, will make that state being played: | Whenever the score is stopped (for instance when pressing the Stop button). | . Remember that the transport bar’s button are in the following order: . | Local play | Global play | Stop | Reinitialize | . ",
    "url": "https://ossia.io/score-docs/common-practices/7-start-stop-cues.html#start-and-stop-cues",
    "relUrl": "/common-practices/7-start-stop-cues.html#start-and-stop-cues"
  },"53": {
    "doc": "Start/stop cues",
    "title": "Example",
    "content": ". Consider the above score. When pressing “Global Play”: . | test:/lights 1 is sent. | The score plays. | . Then, when pressing “Stop”: . | The playback is stopped. | test:/sound 0 is sent. | . If instead of pressing “Stop”, “Reinitialize” had been pressed: . | The playback is stopped. | test:/sound 0 is sent. | test:/lights 1 is sent. | . If “Reinitialize” is pressed while the score isn’t playing: . | test:/lights 1 is sent. | . ",
    "url": "https://ossia.io/score-docs/common-practices/7-start-stop-cues.html#example",
    "relUrl": "/common-practices/7-start-stop-cues.html#example"
  },"54": {
    "doc": "Start/stop cues",
    "title": "Start/stop cues",
    "content": " ",
    "url": "https://ossia.io/score-docs/common-practices/7-start-stop-cues.html",
    "relUrl": "/common-practices/7-start-stop-cues.html"
  },"55": {
    "doc": "Live coding",
    "title": "Live coding",
    "content": "The timeline nature of ossia score may make it look like it is not very amenable to live coding ; that could not be farther from the truth ! . ",
    "url": "https://ossia.io/score-docs/common-practices/8-live-coding.html",
    "relUrl": "/common-practices/8-live-coding.html"
  },"56": {
    "doc": "Live coding",
    "title": "Editing the score during playback",
    "content": "It is possible to edit every part of the score while it plays, and most importantly, start or restart those parts. Most places in a score should be editable during playback ; if you encounter issues, please file a bug report ! In particular, processes, sounds, shaders, etc. can all be added, removed, altered during playback. There is one important exception, that we have not lifted yet: it is not possible to add a new device during playback ; you must prepare the devices to be used before hitting play. For instance, it is not possible as of ossia score 3.0.0-b1 to open a new window for visuals or plug a new MIDI keyboard in the middle of a performance. A very simple trick is then to use triggers to keep the parts running forever: this way, the intervals that are running that way will keep running their processes forever, like for instance would a Max or Pure Data patch. Here is a small example: . ",
    "url": "https://ossia.io/score-docs/common-practices/8-live-coding.html#editing-the-score-during-playback",
    "relUrl": "/common-practices/8-live-coding.html#editing-the-score-during-playback"
  },"57": {
    "doc": "Live coding",
    "title": "Code-based processes",
    "content": "A few processes in score use textual scripts: . | Javascript | Shaders | Bytebeat | Texture generator | Faust | C++ JIT | . In all cases, the script can be edited with the small “Window” button on the header of each of the corresponding nodes (the second button). ",
    "url": "https://ossia.io/score-docs/common-practices/8-live-coding.html#code-based-processes",
    "relUrl": "/common-practices/8-live-coding.html#code-based-processes"
  },"58": {
    "doc": "Live coding",
    "title": "Editing scripts",
    "content": "When that button is pressed, this opens the script editor, which can be used to change the code. When you are done editing, press “Compile” ; this will update the code for the execution engine. Invalid code won’t change the current state to prevent unwanted loud noises and flashes :-) . It is possible to use the Ctrl+Enter(Win / Linux) or⌘+Enter(Mac) shortcut to update the execution engine with the current code. The pane at the bottom of the window will display the error log: here, we have some slightly invalid code on line 9 for instance. ",
    "url": "https://ossia.io/score-docs/common-practices/8-live-coding.html#editing-scripts",
    "relUrl": "/common-practices/8-live-coding.html#editing-scripts"
  },"59": {
    "doc": "Seek and transport",
    "title": "Seek and transport",
    "content": "This page explains all the possible ways to control the transport in score. There are three ways to control transport: . | Manually, with the “play from here” feature which allows to seek at a given point explicitly. | In a pre-determined or processed way with a specific process which allows to control the speed of its parent interval. | Through an external transport system. For now only JACK transport is supported. | . ",
    "url": "https://ossia.io/score-docs/common-practices/9-seek-and-transport.html",
    "relUrl": "/common-practices/9-seek-and-transport.html"
  },"60": {
    "doc": "Seek and transport",
    "title": "Semantics of transport",
    "content": "Before explaining how to use the actual feature, it is important to explain the semantics of transport in score, as due to the interactive nature of scores, behaviour of transport can be somewhat surprising. Consider the following score: . Thanks to the various interactive features of score such as interactive triggers and interval speed control the three following executions are possible: . This of course begs the question of: what should happen when asking score to transport at any given point when the score has not started playing ? . The policy taken by score is to follow the visual duration set for intervals. That is, that visual duration even for a fully interactive interval is not entirely devoid of semantic meaning: it can be taken as to mean: . The duration that I expect this part of the score to last. In particular, this means that any interactive point before the point to which the transport is performed will be triggered. All intervals that are visually at that point will be positioned accordingly. That is, here are successive transports done in the above score. ",
    "url": "https://ossia.io/score-docs/common-practices/9-seek-and-transport.html#semantics-of-transport",
    "relUrl": "/common-practices/9-seek-and-transport.html#semantics-of-transport"
  },"61": {
    "doc": "Seek and transport",
    "title": "Value compilation",
    "content": "Consider a score where a sound is being played through an external sound player, controlled through OSC. This sound player’s API is: . player:/play &lt;bool&gt; player:/volume &lt;float&gt; . The score is: . Now, if we want to play our score from the middle of the automation, if nothing else was done other than positioning the playhead and starting playback, the player:/play true OSC message would never be sent and the remote software would not start playing, thus making the feature somewhat useless. Thankfully, score takes this into account: by default, when running a transport action if the score is not playing, every state leading to the transported point is computed from the beginning of the score. If multiple states send different values, then the last one is taken into account: that is, if making a transport after the end of the example score shown above, the player will receive the messages: . player:/play false player:/volume 0 . The software settings contain two options to control this behaviour, one for the first time a transport is done, and one for subsequent transports when execution is already running: . ",
    "url": "https://ossia.io/score-docs/common-practices/9-seek-and-transport.html#value-compilation",
    "relUrl": "/common-practices/9-seek-and-transport.html#value-compilation"
  },"62": {
    "doc": "Seek and transport",
    "title": "Offset behaviour",
    "content": "A more complex case is related to conditions. In this case, a choice must be made when processing the conditions. However, sometime we may need to explore the different outcomes of a score when doing transport: for instance, if a condition requires a performer to be at a specific place on the stage, we may want to be able to perform a transport without having to ask the performer to go to the designed place for the transport to take place as expected. Thus, the condition inspector provides the “offset behaviour” setting which allows to toggle whether the condition will be true, false, or evaluated with the live value in the device tree, when it is evaluated during a transport operation: . ",
    "url": "https://ossia.io/score-docs/common-practices/9-seek-and-transport.html#offset-behaviour",
    "relUrl": "/common-practices/9-seek-and-transport.html#offset-behaviour"
  },"63": {
    "doc": "Seek and transport",
    "title": "Using transport",
    "content": " ",
    "url": "https://ossia.io/score-docs/common-practices/9-seek-and-transport.html#using-transport",
    "relUrl": "/common-practices/9-seek-and-transport.html#using-transport"
  },"64": {
    "doc": "Seek and transport",
    "title": "Play from here",
    "content": "This feature allows to move the global time bar. To use it, right-click on a scenario and hit “Play from here”: . You can also use the “Play” tool: . ",
    "url": "https://ossia.io/score-docs/common-practices/9-seek-and-transport.html#play-from-here",
    "relUrl": "/common-practices/9-seek-and-transport.html#play-from-here"
  },"65": {
    "doc": "Seek and transport",
    "title": "Playing a single state",
    "content": "Either the play tool or a right-click menu allow to launch the content of a single state at any point. ",
    "url": "https://ossia.io/score-docs/common-practices/9-seek-and-transport.html#playing-a-single-state",
    "relUrl": "/common-practices/9-seek-and-transport.html#playing-a-single-state"
  },"66": {
    "doc": "Seek and transport",
    "title": "Controlling speed and transport programmatically",
    "content": "See the documentation of the Tempo process. ",
    "url": "https://ossia.io/score-docs/common-practices/9-seek-and-transport.html#controlling-speed-and-transport-programmatically",
    "relUrl": "/common-practices/9-seek-and-transport.html#controlling-speed-and-transport-programmatically"
  },"67": {
    "doc": "Seek and transport",
    "title": "Controlling global transport through an external API",
    "content": "Right now, only JACK is supported. The plan is to include synchronization with SMTPE, Midi Clock, Ableton Link, etc. over time. The setting is currently in the global software settings: score can act both as a JACK client or master: . ",
    "url": "https://ossia.io/score-docs/common-practices/9-seek-and-transport.html#controlling-global-transport-through-an-external-api",
    "relUrl": "/common-practices/9-seek-and-transport.html#controlling-global-transport-through-an-external-api"
  },"68": {
    "doc": "Seek and transport",
    "title": "Setting a start marker",
    "content": "It is possible to set a start marker by right-clicking into the musical metrics area, at the top of the score. When a start marker is set, play / pause will always start from this point: this is mainly useful to play a specific part of a score quickly in succession. ",
    "url": "https://ossia.io/score-docs/common-practices/9-seek-and-transport.html#setting-a-start-marker",
    "relUrl": "/common-practices/9-seek-and-transport.html#setting-a-start-marker"
  },"69": {
    "doc": "Release build",
    "title": "Build",
    "content": "This page describes how to build score on various operating systems. Dear packagers: here are specific build instructions to make packages for Linux/BSD/… : Packaging score for Linux. ",
    "url": "https://ossia.io/score-docs/development/build/release.html#build",
    "relUrl": "/development/build/release.html#build"
  },"70": {
    "doc": "Release build",
    "title": "Dependencies",
    "content": "To build, you will need the following dependencies : . | Qt 5 (&gt;= 5.12) | CMake (&gt;= 3.15) | Boost (automatically downloaded) | (optional) FFMPEG (&gt;= 3.3) | A recursive clone of the score repository : git clone --recursive https://github.com/ossia/score. | . The easiest way to get most dependencies in a prebuilt form is by downloading our SDK for your platform. Important: do not use the source releases produced by GitHub : they do not have the submodules and compiling with them won’t work. Your compiler need to be recent; supported compilers are: . | gcc &gt;= 8 | clang &gt;= 8 | Xcode &gt;= 11 | Visual Studio 2019 (the very latest version !) | . What does not work : . | GCC &lt;= 7. | Older MSVC versions | . ",
    "url": "https://ossia.io/score-docs/development/build/release.html#dependencies",
    "relUrl": "/development/build/release.html#dependencies"
  },"71": {
    "doc": "Release build",
    "title": "Debian-like systems",
    "content": "Ubuntu, Debian . Dependencies . sudo apt-get update -qq sudo apt-get install wget software-properties-common wget -nv https://github.com/Kitware/CMake/releases/download/v3.19.1/cmake-3.19.1-Linux-x86_64.tar.gz -O cmake-linux.tgz tar xaf cmake-linux.tgz rm cmake-linux.tgz mv cmake* /opt/ echo 'deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-9 main' | sudo tee /etc/apt/sources.list.d/llvm.list sudo apt-key adv --recv-keys --keyserver keyserver.ubuntu.com 1397BC53640DB551 sudo apt-key adv --recv-keys --keyserver keyserver.ubuntu.com 15CF4D18AF4F7421 sudo add-apt-repository --yes ppa:ubuntu-toolchain-r/test sudo add-apt-repository --yes ppa:beineri/opt-qt-5.13.2-bionic sudo apt-get update -qq sudo apt-get install -qq --force-yes \\ g++-9 binutils libasound-dev ninja-build \\ gcovr lcov \\ qt513-meta-minimal qt513svg qt513quickcontrols2 qt513websockets qt513serialport \\ qt513base qt513declarative \\ libgl1-mesa-dev \\ libavcodec-dev libavutil-dev libavfilter-dev libavformat-dev libswresample-dev \\ portaudio19-dev clang-9 lld-9 \\ libbluetooth-dev \\ libsdl2-dev libsdl2-2.0-0 libglu1-mesa-dev libglu1-mesa \\ libgles2-mesa-dev \\ libavahi-compat-libdnssd-dev . Build . mkdir -p build_folder cd build_folder /opt/cmake-3.19.1-Linux-x86_64/bin/cmake path/to/score \\ -DCMAKE_C_COMPILER=/usr/bin/gcc-9 \\ -DCMAKE_CXX_COMPILER=/usr/bin/g++-9 \\ -DCMAKE_PREFIX_PATH=/opt/qt513 \\ -DCMAKE_BUILD_TYPE=release \\ -DPORTAUDIO_ONLY_DYNAMIC=1 make all_unity # you can add -j$(nproc) to make it faster . NOTE : if you have installed Qt with Qt installer instead of your distro package manager, then you may need to specify where CMake should look for Qt with, for example : . cmake -GNinja -DCMAKE_PREFIX_PATH=~/Qt/5.13.2/gcc_64 ../score/ . Run ./score . Raspberry Pi . Dependencies . First edit /etc/apt/sources.list. Replace : . deb http://archive.raspbian.org/raspbian jessie main . By : . deb http://archive.raspbian.org/raspbian stretch main . Then : . sudo apt -y install git cmake wget ninja-build libqt5websockets5-dev qtbase5-dev qtdeclarative5-dev qt5-default qtbase5-dev-tools qttools5-dev libqt5svg5-dev g++-7 libportmidi0 libasound-dev mesa-common-dev libboost-dev libavahi-compat-libdnssd-dev . Build . mkdir -p build_folder cd build_folder cmake -GNinja -DCMAKE_C_COMPILER=/usr/bin/gcc-7 -DCMAKE_CXX_COMPILER=/usr/bin/g++-7 path/to/score ninja . Run : . $ ./score . ",
    "url": "https://ossia.io/score-docs/development/build/release.html#debian-like-systems",
    "relUrl": "/development/build/release.html#debian-like-systems"
  },"72": {
    "doc": "Release build",
    "title": "macOS :",
    "content": "There is a build.sh script at the root of the repository, it requires Homebrew . So either : ./build.sh open build/score.app . Or ./build.sh release open build-release/score.app . ",
    "url": "https://ossia.io/score-docs/development/build/release.html#macos-",
    "relUrl": "/development/build/release.html#macos-"
  },"73": {
    "doc": "Release build",
    "title": "Build on Windows with Clang",
    "content": ". | Download and extract the latest MinGW SDK here : https://github.com/ossia/sdk/releases/tag/sdk16 in c:\\score-sdk (so you should have a c:\\score-sdk\\llvm\\ folder for instance). | Install dependencies: CMake and ninja. | . With chocolatey: . cinst -y cmake ninja . | Build from a cmd shell (note: this will take 10-15 minutes on a good machine) | . mkdir build cd build set PATH=%PATH%;c:\\score-sdk\\llvm\\bin cmake -GNinja c:/path/to/score ^ -DCMAKE_C_COMPILER=c:/score-sdk/llvm/bin/clang.exe ^ -DCMAKE_CXX_COMPILER=c:/score-sdk/llvm/bin/clang++.exe ^ -DCMAKE_BUILD_TYPE=Release ^ -DOSSIA_SDK=c:\\score-sdk ^ -DCMAKE_INSTALL_PREFIX=release ^ -DCMAKE_PREFIX_PATH=\"c:/score-sdk/qt5-static;c:/score-sdk/llvm-libs;c:/score-sdk/SDL2;c:/score-sdk\" ^ -DCMAKE_UNITY_BUILD=1 ^ -DOSSIA_STATIC_EXPORT=1 ^ -DSCORE_INSTALL_HEADERS=1 ^ -DDEPLOYMENT_BUILD=1 cmake --build . cmake --build . --target package . This will create an installer for the latest version. Alternatively, replace cmake --build . --target package by cmake --build . --target install to install the executable directly in the release subfolder of your build folder. ",
    "url": "https://ossia.io/score-docs/development/build/release.html#build-on-windows-with-clang",
    "relUrl": "/development/build/release.html#build-on-windows-with-clang"
  },"74": {
    "doc": "Release build",
    "title": "Build on Windows with MSVC (currently broken !)",
    "content": "This requires at least Visual Studio 2017 15.9.6, freely available from Microsoft’s website. First, install the dependencies with the mechanism of your choice. Then, on a command shell, run : . mkdir score-build cd score-build cmake -T host=x64 -A x64 ../score -DCMAKE_BUILD_TYPE=release -DCMAKE_PREFIX_PATH=path/to/Qt5Config.cmake cmake --build . --target package . The relevant folders are : . | For boost : the path to the folder contained in the archive downloaded, for instance c:\\Libraries\\boost_1_63_0 ; it should contain boost, libs, doc subfolders. e.g. -DBOOST_ROOT=c:/Libraries/boost_1_63_0. | For Qt : the path to the Qt5Config.cmake, e.g. -DCMAKE_PREFIX_PATH=c:/Libraries/Qt/5.7/msvc2015/lib/cmake/Qt5. | . This creates an installable package, install it and run score from your desktop. Else you have to copy the Qt DLLs and plug-ins to the folder where score.exe was built. ",
    "url": "https://ossia.io/score-docs/development/build/release.html#build-on-windows-with-msvc-currently-broken-",
    "relUrl": "/development/build/release.html#build-on-windows-with-msvc-currently-broken-"
  },"75": {
    "doc": "Release build",
    "title": "Android",
    "content": "Clone qt5 from git : . git clone https://github.com/qt/qt5 cd qt5 git submodule update --init --recursive . Apply the following patch : https://bugreports.qt.io/browse/QTBUG-60455 if it has not been merged, in the folder qt5/qtbase : . cd qt5/qtbase git-apply 0001-Android-....patch . Also add #include &lt;QtMath&gt; in qtbase/src/plugins/platforms/android/androidjniinput.cpp. Configure and build Qt5 : ../qt5/configure -opensource -confirm-license -xplatform 'android-clang-libc++' -nomake tests -nomake examples -android-ndk /opt/android-ndk-r15b -android-sdk /opt/android/sdk -android-arch armeabi-v7a -no-warnings-are-errors -opengl es2 -opengles3 -android-ndk-platform android-22 -prefix /opt/qt-android make -j8 make install . Build the player library : . cd ~/build cmake ~/score -DCMAKE_TOOLCHAIN_FILE=~/score/API/CMake/android_toolchain.cmake -DCMAKE_PREFIX_PATH=/opt/qt-android/lib/cmake/Qt5 -DISCORE_CONFIGURATION=android-debug -DISCORE_PLAYER=1 -Wno-dev -DOSSIA_PROTOCOL_MIDI=0 . Put the library in the correct folder : . mkdir -p /opt/qt-android/qml/Ossia/ ln -s ~/score/API/ossia/ossia-qml/Ossia/*.qml /opt/qt-android/qml/Ossia/ cp ~/score/API/ossia/ossia-qml/Ossia/qmldir /opt/qt-android/qml/Ossia/ ln -s ~/build/libiscore_player_plugin.so /opt/qt-android/qml/Ossia/ . Change the name of the library in the qmldir (iscore_player_plugin instead of ossia) . To run with QtCreator, add the following library in the android build : . /opt/android-ndk-r14b/sources/cxx-stl/llvm-libc++/libs/armeabi-v7a/libc++_shared.so . (adapt the architecture, paths, etc… for your phone / tablet) . ",
    "url": "https://ossia.io/score-docs/development/build/release.html#android",
    "relUrl": "/development/build/release.html#android"
  },"76": {
    "doc": "Release build",
    "title": "Sanitization",
    "content": "clang-tidy -p ~/iscore-tidy/compile_commands.json base/**/*.cpp --header-filter=base/ . ",
    "url": "https://ossia.io/score-docs/development/build/release.html#sanitization",
    "relUrl": "/development/build/release.html#sanitization"
  },"77": {
    "doc": "Release build",
    "title": "Release build",
    "content": " ",
    "url": "https://ossia.io/score-docs/development/build/release.html",
    "relUrl": "/development/build/release.html"
  },"78": {
    "doc": "Hacking",
    "title": "Very very quickstart",
    "content": "The developer.sh will try to download and install the required dependencies, and compile score in a way suitable for development. ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#very-very-quickstart",
    "relUrl": "/development/build/hacking.html#very-very-quickstart"
  },"79": {
    "doc": "Hacking",
    "title": "Quickstart",
    "content": "This page presents how to start developing things on ossia score. We recommend heavily to use QtCreator as IDE to do so, or at least an IDE with native support for CMake. ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#quickstart",
    "relUrl": "/development/build/hacking.html#quickstart"
  },"80": {
    "doc": "Hacking",
    "title": "The SDK",
    "content": "Required dependencies and libraries, except CMake and Ninja, can be downloaded from a pre-built SDK. This will give you exactly the library used for the official ossia score releases. This is recommended on Windows and Linux distributions older than Ubuntu 22.04. This script will download the latest version of the SDK automatically. Otherwise: . | On Windows: . | Install git with git bash. | Download the SDK and extract it in c:\\ossia-sdk. | You must also install CMake. | Ninja is extremely recommended for build speed - download it and extract ninja.exe in c:\\ossia-sdk\\llvm\\bin\\. | . | On Linux: Download the SDK and extract it in /opt/ossia-sdk. You must also install CMake (from your distribution’s repositories). | On macOS: Download the SDK and extract it in /opt/ossia-sdk-x86_64. You must also install XCode (sorry) and CMake+Ninja (for instance through Homebrew). | . ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#the-sdk",
    "relUrl": "/development/build/hacking.html#the-sdk"
  },"81": {
    "doc": "Hacking",
    "title": "Quick development build",
    "content": " ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#quick-development-build",
    "relUrl": "/development/build/hacking.html#quick-development-build"
  },"82": {
    "doc": "Hacking",
    "title": "Cloning the project",
    "content": "Make sure to make a recursive clone of the project, or you will encounter build issues: . $ git clone --recursive -j16 https://github.com/ossia/score . ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#cloning-the-project",
    "relUrl": "/development/build/hacking.html#cloning-the-project"
  },"83": {
    "doc": "Hacking",
    "title": "Build the project on Windows",
    "content": "With git bash: . $ export PATH=/c/ossia-sdk/llvm/bin:$PATH $ cmake c:/path/to/score \\ -GNinja \\ -DCMAKE_C_COMPILER=c:/ossia-sdk/llvm/bin/clang \\ -DCMAKE_CXX_COMPILER=c:/ossia-sdk/llvm/bin/clang++ \\ -DOSSIA_SDK=c:/ossia-sdk \\ -DCMAKE_BUILD_TYPE=Debug \\ -DSCORE_PCH=1 $ cmake --build . Or with cmd.exe, the native command shell: . &gt; set PATH=c:\\ossia-sdk\\llvm\\bin;%PATH% &gt; cmake c:\\path\\to\\score ^ -GNinja ^ -DCMAKE_C_COMPILER=c:\\ossia-sdk\\llvm\\bin\\clang ^ -DCMAKE_CXX_COMPILER=c:\\ossia-sdk\\llvm\\bin\\clang++ ^ -DOSSIA_SDK=c:\\ossia-sdk ^ -DCMAKE_BUILD_TYPE=Debug ^ -DSCORE_PCH=1 &gt; cmake --build . Note: on Windows, the system antivirus slows build times a lot. Be sure to exclude recursively: . | The ossia-sdk folder | The score source folder | The score build folder | . from antivirus scans if things are slow as it seems that every file access is checked, and compilers do those a lot. ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#build-the-project-on-windows",
    "relUrl": "/development/build/hacking.html#build-the-project-on-windows"
  },"84": {
    "doc": "Hacking",
    "title": "Build the project on Linux",
    "content": "It is harder to give a single set of build instructions for Linux, as every distribution differs. Check out the build scripts for your distros here. For instance, for Ubuntu 20.04: . | focal.deps.sh will install the required dependencies. | focal.build.sh will build. | . You should change the CMake invocation a bit, as the one on the CI scripts is optimized for a fast complete rebuild on the CI server, but changing a single file and rebuilding will be excruciatingly slow: . Instead of . $ cmake .. \\ -GNinja \\ -DCMAKE_BUILD_TYPE=Release \\ -DCMAKE_INSTALL_PREFIX=install \\ -DSCORE_DYNAMIC_PLUGINS=1 \\ -DCMAKE_UNITY_BUILD=1 . You really want (adapted with the clang version you have): . $ cmake ~/path/to/score \\ -GNinja \\ -DCMAKE_C_COMPILER=\"clang-14\" \\ -DCMAKE_CXX_COMPILER=\"clang++-14\" \\ -DCMAKE_SHARED_LINKER_FLAGS=\"-fuse-ld=lld\" \\ -DCMAKE_EXE_LINKER_FLAGS=\"-fuse-ld=lld\" \\ -DCMAKE_BUILD_TYPE=Debug \\ -DSCORE_PCH=1 \\ -DSCORE_DYNAMIC_PLUGINS=1 $ cmake --build . which will make individual changes much faster (the difference can be between waiting a couple minutes instead of a couple seconds after each rebuild). If you have an up-to-date distribution, you can also install the mold linker which is even faster than lld, and replace -fuse-ld=lld with -fuse-ld=mold in the lines above. ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#build-the-project-on-linux",
    "relUrl": "/development/build/hacking.html#build-the-project-on-linux"
  },"85": {
    "doc": "Hacking",
    "title": "Build the project on macOS",
    "content": "$ xcrun cmake ~/path/to/score \\ -GNinja \\ -DOSSIA_SDK=/opt/ossia-sdk-x86_64 \\ -DCMAKE_BUILD_TYPE=Debug \\ -DSCORE_PCH=1 \\ -DSCORE_DYNAMIC_PLUGINS=1 $ xcrun cmake --build . ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#build-the-project-on-macos",
    "relUrl": "/development/build/hacking.html#build-the-project-on-macos"
  },"86": {
    "doc": "Hacking",
    "title": "Rebuild the project after an initial build",
    "content": "Once you have a build folder, only the cmake --build . command is necessary. ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#rebuild-the-project-after-an-initial-build",
    "relUrl": "/development/build/hacking.html#rebuild-the-project-after-an-initial-build"
  },"87": {
    "doc": "Hacking",
    "title": "Installing dependencies manually",
    "content": "Ensure that you have the latest version of Qt, boost, and your C++ compiler installed. Note : to ensure a very fast build time, it is recommended to use clang as compiler and ninja for building, on every platform. Additionally, on Linux and Windows lld can be used as a linker. It is quite faster than GNU ld and gold. On recent Linux, mold can also be used, which is even faster. At the time of this writing, this means : . | Software | Version | . | Compiler | clang 14 or gcc 12 or msvc 2022 | . | Qt | 5.15 or Qt 6.2+ | . | Boost | 1.80 | . | CMake | 3.24 | . However, to get a complete build with support for more features, more is needed : . | Software | Version |   | . | FFMPEG | 5.x | # Required for sound playback | . | LLVM | 14.x | # Required for Faust support | . | OpenSSL | 1.1.x | # Required to connect to wss / https | . | Faust | Latest | # Required to load Faust plug-ins | . | suil, lilv | Latest | # Required to load LV2 plug-ins | . | PortAudio | Latest | # Required to playback sound using Coreaudio, ASIO, ALSA, Pulseaudio… | . | JACK2 | Latest | # Required to playback sound using JACK | . | SDL2 | Latest | # Required to have gamepad support | . | Qt | 5.15+ | # Required for the GFX addon | . | qtshadertools | 5.15+ | # Required for the GFX addon | . Or you can install them with your package manager of choice - see the packages for each platform at the end of this document. ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#installing-dependencies-manually",
    "relUrl": "/development/build/hacking.html#installing-dependencies-manually"
  },"88": {
    "doc": "Hacking",
    "title": "Useful documentation",
    "content": ". | (Using) CMake | (Writing) CMake | Qt | Qt Creator | . ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#useful-documentation",
    "relUrl": "/development/build/hacking.html#useful-documentation"
  },"89": {
    "doc": "Hacking",
    "title": "Building on the command line",
    "content": "First get a recursive clone of the repository : . $ git clone --recursive -j16 https://github.com/ossia/score . The preferred way to build when hacking on the software is with cninja: . cninja ~/path/to/score developer . Alternatively, one can build with CMake. Pass the following options to cmake to ensure maximal build speed: (note that the instructions later on this page may not be entirely up-to-date) . -GNinja # Makes the build much faster -DCMAKE_C_COMPILER=/path/to/clang # Makes the build faster (only needed on Linux) -DCMAKE_CXX_COMPILER=/path/to/clang++ # Makes the build faster (only needed on Linux) -DCMAKE_SHARED_LINKER_FLAGS=\"-fuse-ld=lld\" # Makes the linking faster (only needed on Linux) -DCMAKE_EXE_LINKER_FLAGS=\"-fuse-ld=lld\" # Makes the linking faster (only needed on Linux) -DCMAKE_BUILD_TYPE=Debug # For having debug symbols -DSCORE_PCH=1 # Makes the build much much faster -DSCORE_DYNAMIC_PLUGINS=1 # Makes the linking faster (only on Mac / Linux ; on Windows it does not work without rebuilding every dependency) . Important: Run the cmake command in a separate build folder, especially not in the source directory of score ! . For instance, for generating the build files on Ubuntu, Debian or Linux Mint, that gives : . cmake /path/to/score \\ -GNinja \\ -DCMAKE_C_COMPILER=/usr/bin/clang \\ -DCMAKE_CXX_COMPILER=/usr/bin/clang++ \\ -DCMAKE_SHARED_LINKER_FLAGS=\"-fuse-ld=lld\" \\ -DCMAKE_EXE_LINKER_FLAGS=\"-fuse-ld=lld\" \\ -DCMAKE_BUILD_TYPE=Debug \\ -DSCORE_PCH=1 \\ -DSCORE_DYNAMIC_PLUGINS=1 . If you are using the SDK mentioned above, add: . -DOSSIA_SDK=/path/to/sdk . If you are not using your distribution’s Qt version because it’s too old, pass the path to a recent version with, for instance, . -DCMAKE_PREFIX_PATH=/home/yourname/Qt/5.15.3/gcc_64 . The path must contain a lib folder in which CMake is going to look for Qt. Once CMake has ran successfully, do : . cmake --build . To be safe, you should have at least 8 gigabytes free on your hard drive before starting a build. ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#building-on-the-command-line",
    "relUrl": "/development/build/hacking.html#building-on-the-command-line"
  },"90": {
    "doc": "Hacking",
    "title": "Building with Qt Creator",
    "content": "Refer to this video : https://www.youtube.com/watch?v=LSifHFbuky0 . ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#building-with-qt-creator",
    "relUrl": "/development/build/hacking.html#building-with-qt-creator"
  },"91": {
    "doc": "Hacking",
    "title": "Windows with Visual Studio",
    "content": "First install: . | The latest version of Visual Studio 2022 | git | CMake | Python | Take a few seconds to contemplate the easiness of building on the above Unix platforms | Extract https://github.com/ossia/sdk/releases/download/sdk14/win-audio-sdk-msvc.zip in your c:\\ so that the folders once extracted look like c:\\score-sdk-msvc\\portaudio and c:\\score-sdk-msvc\\ffmpeg | . Run a x64 Native Tools Command Prompt for VS 2022: . In the command prompt, install Qt: . (Assuming your development environment is in a c:\\dev folder) . cd c:\\dev # Install dependencies ## Qt pip install aqtinstall aqt install --outputdir c:\\Qt 5.15.3 windows desktop win64_msvc2019_64 # Build cmake ../score -DCMAKE_PREFIX_PATH=\"c:/Qt/5.15.3/msvc2019_64\" -DOSSIA_SDK=\"c:/score-sdk-msvc\" -DSCORE_PCH=1 -DCMAKE_INSTALL_PREFIX=installed -DCMAKE_BUILD_TYPE=Debug cmake --build . --config Debug cmake --build . --config Debug --target install # Run cd installed score.exe . ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#windows-with-visual-studio",
    "relUrl": "/development/build/hacking.html#windows-with-visual-studio"
  },"92": {
    "doc": "Hacking",
    "title": "Hacking",
    "content": " ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html",
    "relUrl": "/development/build/hacking.html"
  },"93": {
    "doc": "Packaging",
    "title": "General information",
    "content": "Score has many build options, modules, etc… but there is one canonical way to build a release tailored for Unix distributions. Please use the package versions provided with score / libossia as much as possible and not the distribution-provided packages, else we get bug reports because the version of TBB / PortAudio / … of $DISTRO has known problems. In particular RtMidi and oscpack have been more or less entirely rewritten. If you don’t want to, then it’s better to let the users use the AppImage because those are known to be working. If your distro has a PortAudio package, please ensure that its PortAudio version is not linking against JACK, because else it can cause hangs (e.g. in Debian, Ubuntu). If it does, then please ensure that score does not link against PortAudio. An example of package is the one provided in the ArchLinux AUR : https://aur.archlinux.org/cgit/aur.git/tree/PKGBUILD?h=ossia-score . ",
    "url": "https://ossia.io/score-docs/development/build/packaging.html#general-information",
    "relUrl": "/development/build/packaging.html#general-information"
  },"94": {
    "doc": "Packaging",
    "title": "Dependencies",
    "content": ". | CMake (&gt;= 3.9) | Qt (&gt;= 5.12) | Boost (whatever is the latest version, at least 1.68) | FFMPEG (libavcodec, etc., at least FFMPEG 3) | . ",
    "url": "https://ossia.io/score-docs/development/build/packaging.html#dependencies",
    "relUrl": "/development/build/packaging.html#dependencies"
  },"95": {
    "doc": "Packaging",
    "title": "Building a release",
    "content": "The procedure is straightforward: . # Configure step cmake -Wno-dev \\ -DCMAKE_BUILD_TYPE=Release \\ -DCMAKE_UNITY_BUILD=1 \\ -DDEPLOYMENT_BUILD=1 \\ -DCMAKE_SKIP_RPATH=ON \\ -DCMAKE_INSTALL_PREFIX=\"/usr\" \\ \"srcdir\" # Build step # Just running make is possible but will be much slower. cmake --build . # adding -- -j4 at least will greatly increase build speed # Install step # do **not** just run make install, else score will install a lot of unneeded headers (boost, etc). cmake -DCMAKE_INSTALL_DO_STRIP=1 -DCOMPONENT=OssiaScore -P cmake_install.cmake . Important note . Due to a bug not fixed in mainline LLVM yet, we recommend disabling the JIT plug-in which may cause crashes (will be fixed in LLVM-12 ; LLVM-11 and LLVM-10 won’t work). Add the following to the CMake invocation: . -DSCORE_DISABLED_PLUGINS=\"score-plugin-jit\" . ",
    "url": "https://ossia.io/score-docs/development/build/packaging.html#building-a-release",
    "relUrl": "/development/build/packaging.html#building-a-release"
  },"96": {
    "doc": "Packaging",
    "title": "Packaging",
    "content": " ",
    "url": "https://ossia.io/score-docs/development/build/packaging.html",
    "relUrl": "/development/build/packaging.html"
  },"97": {
    "doc": "Analysis",
    "title": "Analysis processes",
    "content": "Real-time music information retrieval (MIR) processes are available, thanks to the Gist library. They allow to easily build audio-reactive visuals, by extracting meaningful parameters from a live or pre-recorded audio signal. Here is a video example of their usage: . ",
    "url": "https://ossia.io/score-docs/processes/analysis.html#analysis-processes",
    "relUrl": "/processes/analysis.html#analysis-processes"
  },"98": {
    "doc": "Analysis",
    "title": "Envelope",
    "content": ". These processes allow to extract the volume of an audio signal. ",
    "url": "https://ossia.io/score-docs/processes/analysis.html#envelope",
    "relUrl": "/processes/analysis.html#envelope"
  },"99": {
    "doc": "Analysis",
    "title": "Onset detection",
    "content": ". These processes allow to detect hits and impacts and are useful for beat detection. The first outlet outputs the detection signal. The second outlet outputs an impulse when an onset is detected. ",
    "url": "https://ossia.io/score-docs/processes/analysis.html#onset-detection",
    "relUrl": "/processes/analysis.html#onset-detection"
  },"100": {
    "doc": "Analysis",
    "title": "Pitch detection",
    "content": ". These processes allow to estimate the pitch of a monophonic signal (between 150 and 1500 Hz). ",
    "url": "https://ossia.io/score-docs/processes/analysis.html#pitch-detection",
    "relUrl": "/processes/analysis.html#pitch-detection"
  },"101": {
    "doc": "Analysis",
    "title": "Spectral parameters",
    "content": ". These processes allow to extract parameters related to the spectrum and the timbre of an audio signal. ",
    "url": "https://ossia.io/score-docs/processes/analysis.html#spectral-parameters",
    "relUrl": "/processes/analysis.html#spectral-parameters"
  },"102": {
    "doc": "Analysis",
    "title": "Spectrum extraction",
    "content": ". These processes convert the input audio signal in an “audio” signal containing the spectra, and are mainly useful for further processing in custom processes. ",
    "url": "https://ossia.io/score-docs/processes/analysis.html#spectrum-extraction",
    "relUrl": "/processes/analysis.html#spectrum-extraction"
  },"103": {
    "doc": "Analysis",
    "title": "Analysis",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/analysis.html",
    "relUrl": "/processes/analysis.html"
  },"104": {
    "doc": "Architecture",
    "title": "Score API documentation",
    "content": "The API documentation is available at the following link. ",
    "url": "https://ossia.io/score-docs/development/architecture.html#score-api-documentation",
    "relUrl": "/development/architecture.html#score-api-documentation"
  },"105": {
    "doc": "Architecture",
    "title": "UML model",
    "content": "A draft UML model of the software is available in the git repository, at the following link. It can be opened with Qt Creator. ",
    "url": "https://ossia.io/score-docs/development/architecture.html#uml-model",
    "relUrl": "/development/architecture.html#uml-model"
  },"106": {
    "doc": "Architecture",
    "title": "Architecture",
    "content": " ",
    "url": "https://ossia.io/score-docs/development/architecture.html",
    "relUrl": "/development/architecture.html"
  },"107": {
    "doc": "Art-Net device",
    "title": "Art-Net device",
    "content": ". It is possible to communicate through DMX with ossia score, in order to control and automate light fixtures. The user library contains a built-in fixture library that can be added. The fixture library is based on Open Fixture Library and uses the same JSON format. If no fixtures are added, then the device will instead provide the 512 raw DMX channels. Otherwise, each fixture will appear as a node of the device. ",
    "url": "https://ossia.io/score-docs/devices/artnet-device.html",
    "relUrl": "/devices/artnet-device.html"
  },"108": {
    "doc": "Art-Net device",
    "title": "Custom fixtures",
    "content": "It is possible to add your custom fixtures, following the OFL format in the user library. To do so: . | Create a fixtures folder somewhere. | Inside it, add a manufacturers.json file with the fixture brands you want to add. | . For instance: . { \"$schema\": \"https://raw.githubusercontent.com/OpenLightingProject/open-fixture-library/master/schemas/manufacturers.json\", \"my_custom_fixtures\": { \"name\": \"My custom fixtures\" } } . | Create a subfolder my_custom_fixtures | Add your fixtures JSON files to the folder. | . ",
    "url": "https://ossia.io/score-docs/devices/artnet-device.html#custom-fixtures",
    "relUrl": "/devices/artnet-device.html#custom-fixtures"
  },"109": {
    "doc": "Audio device",
    "title": "Audio device",
    "content": "This device allows to expose the physical inputs and outputs of the sound card as device tree nodes, which can then be used at any place in the score to route a part of the score to a specific sound card output for instance. ",
    "url": "https://ossia.io/score-docs/devices/audio-device.html",
    "relUrl": "/devices/audio-device.html"
  },"110": {
    "doc": "Audio device",
    "title": "Audio parameters",
    "content": "It is possible to set a float value between 0 and 1 on the audio parameters, for instance to automate the global volume of a given output. Multiple processes sending audio to the same parameter will be summed. ",
    "url": "https://ossia.io/score-docs/devices/audio-device.html#audio-parameters",
    "relUrl": "/devices/audio-device.html#audio-parameters"
  },"111": {
    "doc": "Audio device",
    "title": "Device tree",
    "content": "For a sound card with two mono inputs and outputs, creating the device would look like this: . | The address audio:/out/0 will refer to the first channel on the sound card. | The addresses audio:/in/main and audio:/out/main respectively refer to the entirety of the available channels. | In a score, the root interval is routed to audio:/out/main. | The volume control at the bottom of the user interface is a shortcut to control audio:/out/main’s volume. | . ",
    "url": "https://ossia.io/score-docs/devices/audio-device.html#device-tree",
    "relUrl": "/devices/audio-device.html#device-tree"
  },"112": {
    "doc": "Audio device",
    "title": "Adding busses",
    "content": "It is possible to create busses, for instance to create stereo pairs. To do so, just add a child to the device : . Physical busses . The matrix shows which channels from the soundcard will be mapped to which channels of the port, in ascending order. For instance, the above screenshot creates a bus which will send its first channel to the second output of the soundcard, and its second channel to the fourth output of the soundcard. Virtual busses . These are abstract busses that can be used for communication within score (for instance to send the output of a set of processes to another process, to make e.g. an aux track). ",
    "url": "https://ossia.io/score-docs/devices/audio-device.html#adding-busses",
    "relUrl": "/devices/audio-device.html#adding-busses"
  },"113": {
    "doc": "Audio plugins",
    "title": "Audio plug-in support",
    "content": ". Plug-ins can simply be dropped from the process library), under the Audio section, into the main view. If the plug-in has a custom UI, it is possible to make it show up with the small “window” icon on the plug-in header. For plug-ins with many controls, controls won’t show up by default in the score user interface. When changed from the plug-in UI, if any, will show up in score and be automatable. The little “x” allows to remove an unwanted parameter. ",
    "url": "https://ossia.io/score-docs/processes/audio-plugins.html#audio-plug-in-support",
    "relUrl": "/processes/audio-plugins.html#audio-plug-in-support"
  },"114": {
    "doc": "Audio plugins",
    "title": "Common formats: VST, VST3, LV2, JSFX",
    "content": "Common plug-in formats are supported: . | VST 2.4 on all platforms. | VST 3 on all platforms. | LV2 on Linux. It is yet not shipped in the official releases, score needs to be built for source for LV2 support (or be used as a distribution package) | JSFX on all platforms. | . Plug-ins are started automatically on startup. If for some reason this must be disabled, because the scanning process causes issues, one can set the SCORE_DISABLE_AUDIOPLUGINS=1 environment variable. Already scanned plug-ins will still be available for VST and VST3. It is possible to save and reload presets ; however the built-in VST presets are not supported yet. VST2 plug-ins can be rescanned from the preferences. ",
    "url": "https://ossia.io/score-docs/processes/audio-plugins.html#common-formats-vst-vst3-lv2-jsfx",
    "relUrl": "/processes/audio-plugins.html#common-formats-vst-vst3-lv2-jsfx"
  },"115": {
    "doc": "Audio plugins",
    "title": "Controlling VST parameters",
    "content": "To be able to automate and connect VST parameters to other parts of the session, it is necessary to make them visible in the nodes. For plug-ins with less than a dozen parameters, they will always be shown by default. For plug-ins with more parameters, this is however opt-in. The first button allows to show / hide the audio plug-in UI. The second, when enabled, means that the plug-in’s parameters will be checked for changes: whenever a value changes, it will appear in the score UI and be open to automation, etc. Here is the complete procedure: . This is currently only implemented for VST2, other plug-in APIs have all their parameters shown until the feature is implemented there too. ",
    "url": "https://ossia.io/score-docs/processes/audio-plugins.html#controlling-vst-parameters",
    "relUrl": "/processes/audio-plugins.html#controlling-vst-parameters"
  },"116": {
    "doc": "Audio plugins",
    "title": "Adding JSFX plug-ins",
    "content": "JSFX plug-ins can be added in the user library. Score will look for files ending with the .jsfx extension. If you are on Unix or a system with bash, you can rename the JSFX plugins without extensions this way: . $ find . -type f ! -name '*.*' -exec perl-rename 's/$/.jsfx/' {} \\; . Here are some links to free JSFX collections: . | https://github.com/chkhld/jsfx | https://github.com/JoepVanlier/JSFX | https://geraintluff.github.io/jsfx | https://github.com/Justin-Johnson/ReJJ | . Some JSFX plug-ins need separate data files. To ensure that they can find it, the following organization is recommended: . jsfx_folder/Effects/foo/effect.jsfx jsfx_folder/Data/&lt;matching data files&gt; . For instance, a complete path on a Mac with the default user library location would look like: . /Users/you/Documents/ossia/score/packages/jsfx/Effects/dynamics/general_dynamics.jsfx /Users/you/Documents/ossia/score/packages/jsfx/Data/amp_models/SomeImpulse.wav . ",
    "url": "https://ossia.io/score-docs/processes/audio-plugins.html#adding-jsfx-plug-ins",
    "relUrl": "/processes/audio-plugins.html#adding-jsfx-plug-ins"
  },"117": {
    "doc": "Audio plugins",
    "title": "Advanced plug-in and extensions formats",
    "content": "It is also possible to use less common systems for audio processing: . | Faust DSPs | Pure Data patches | Javascript | Math expressions | Custom C++ plug-ins | . Some of these plug-in systems, like Faust are source-based: that is, score will compile the source code of the plug-in directly, which can take a few seconds when dropping the plug-in in the session. Preset support for these plug-ins is a work-in-progress. ",
    "url": "https://ossia.io/score-docs/processes/audio-plugins.html#advanced-plug-in-and-extensions-formats",
    "relUrl": "/processes/audio-plugins.html#advanced-plug-in-and-extensions-formats"
  },"118": {
    "doc": "Audio plugins",
    "title": "Audio plugins",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/audio-plugins.html",
    "relUrl": "/processes/audio-plugins.html"
  },"119": {
    "doc": "Audio routing",
    "title": "Audio routing",
    "content": ". | There is an implicit routing from child process to parent interval, and from interval to parent scenario, recursively up to the top of the score. | The audio output of the top interval is routed by default to the main stereo output of the audio interface defined in Audio Preferences. | When connecting an audio outlet to another audio inlet, propagation is removed. This means that the dry output of the source process will not be mixed in its parent interval. This can be toggled by selecting the port, in the Inspector. | . ",
    "url": "https://ossia.io/score-docs/in-depth/audio-routing.html",
    "relUrl": "/in-depth/audio-routing.html"
  },"120": {
    "doc": "Audio utilities",
    "title": "Gain",
    "content": ". This plug-in simply multiplies its input audio by a gain value. ",
    "url": "https://ossia.io/score-docs/processes/audio-utilities.html#gain",
    "relUrl": "/processes/audio-utilities.html#gain"
  },"121": {
    "doc": "Audio utilities",
    "title": "Envelope",
    "content": ". This plug-in allows to take the envelope (first outlet is RMS, second outlet is peak) of an input audio signal. The output will be an array with as many values than there are channels in the input signal. The signal is often a small value, which can be boosted for instance with a mapping. ",
    "url": "https://ossia.io/score-docs/processes/audio-utilities.html#envelope",
    "relUrl": "/processes/audio-utilities.html#envelope"
  },"122": {
    "doc": "Audio utilities",
    "title": "Metronome",
    "content": ". This plug-in outputs a metronome sound, based on the time signature of its parent interval. The metronome sounds used can be changed: they are in the user library, in the folder “Util” ; the process looks for files named metro_tick.wav and metro_tock.wav. The second outlet outputs an impulse on each tick. ",
    "url": "https://ossia.io/score-docs/processes/audio-utilities.html#metronome",
    "relUrl": "/processes/audio-utilities.html#metronome"
  },"123": {
    "doc": "Audio utilities",
    "title": "Stereo merger",
    "content": ". This process combines stereo audio signal from N inlets, into one outlet whose channels correspond to the inputs’s channels one after each other (mono input channels are duplicated ; no input means silence on the output). That is, in the example below, the output of the Merger process will be a 4-channel signal with: . | Channel 0, 1: the audio generator (originally mono). | Channel 2, 3: the drum loop. | . ",
    "url": "https://ossia.io/score-docs/processes/audio-utilities.html#stereo-merger",
    "relUrl": "/processes/audio-utilities.html#stereo-merger"
  },"124": {
    "doc": "Audio utilities",
    "title": "Audio utilities",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/audio-utilities.html",
    "relUrl": "/processes/audio-utilities.html"
  },"125": {
    "doc": "Audio looper",
    "title": "Audio Looper",
    "content": ". Different options are available when you use the audio looper: the operation mode and the passthrough. | If passthrough is enabled, while recording and overdubbing, the input audio will be copied to the output of the looper. | The looper’s state change can be quantized. | In the inspector, it is possible to make the looper automatically change mode after a fixed amount of bars instead of waiting on an automated change: the second “loop” parameter will control the state on which the looper moves after N bars in the initial state. | . ",
    "url": "https://ossia.io/score-docs/processes/audio-looper.html#audio-looper",
    "relUrl": "/processes/audio-looper.html#audio-looper"
  },"126": {
    "doc": "Audio looper",
    "title": "Play",
    "content": "Play what the looper recorded. ",
    "url": "https://ossia.io/score-docs/processes/audio-looper.html#play",
    "relUrl": "/processes/audio-looper.html#play"
  },"127": {
    "doc": "Audio looper",
    "title": "Recording",
    "content": "Record the actual sound the looper is going to loop to. ",
    "url": "https://ossia.io/score-docs/processes/audio-looper.html#recording",
    "relUrl": "/processes/audio-looper.html#recording"
  },"128": {
    "doc": "Audio looper",
    "title": "Overdub",
    "content": "Record on top of the already recorded sound. ",
    "url": "https://ossia.io/score-docs/processes/audio-looper.html#overdub",
    "relUrl": "/processes/audio-looper.html#overdub"
  },"129": {
    "doc": "Audio looper",
    "title": "Stop",
    "content": "Output nothing. ",
    "url": "https://ossia.io/score-docs/processes/audio-looper.html#stop",
    "relUrl": "/processes/audio-looper.html#stop"
  },"130": {
    "doc": "Audio looper",
    "title": "Audio looper",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/audio-looper.html",
    "relUrl": "/processes/audio-looper.html"
  },"131": {
    "doc": "Automation (float)",
    "title": "Automation (float)",
    "content": ". The Automation (float) process allows to control single value parameter using a breakpoints function. ",
    "url": "https://ossia.io/score-docs/processes/automation_float.html",
    "relUrl": "/processes/automation_float.html"
  },"132": {
    "doc": "Automation (float)",
    "title": "Basic editing",
    "content": "Create new points on curve . Multiple points can be added on an automation. To add a point, double-click in the automation slot to create a point under the mouse cursor. You can also create a new point using Ctrl+click(Win / Linux) or⌘+click(Mac) in the automation’s slot. Remove points from curve . To delete a point from an automation, click on a point to select it, then from its contextual menu select Remove. Multiple points and attached segments can be selected and removed at once using the Remove contextual menu entry. Edit points . To edit a point value of position in time, select it using the mouse and move it along the x axis to adjust in position in time, or along the y axis to adjust its value. You will note that when selecting a point, its value gets displayed next to the mouse cursor . For fine control, you can also use the dedicated number boxes from the inspector. Click on a point to select it and display its inspector then use the value number box to adjust to the desired value. Adjust segment’s curve . Power type segments (default) can be added a curve factor. To do so, click a segment and use Shift+Drag. Dragging the curve upward add a log-like curvature to the segment, while dragging downward add a exp-like curvature. ",
    "url": "https://ossia.io/score-docs/processes/automation_float.html#basic-editing",
    "relUrl": "/processes/automation_float.html#basic-editing"
  },"133": {
    "doc": "Automation (float)",
    "title": "Segment shapes",
    "content": "Segments between two points can be set to various predefined shapes. To do so, click a segment and from its contextual menu, choose the desired segment shape in the Type category. Shapes include: . | Power (default) | Linear (a slightly optimized version of Power with zero curve factor) | Standard Easing curves | . | backIn | quadraticIn | quarticIn | sineIn | exponentialIn | . | backOut | quadraticOut | quarticOut | sineOut | exponentialOut | . | backInOut | quadraticInOut | quarticInOut | sineInOut | exponentialInOut | . |   |   |   |   |   | . | bounceIn | cubicIn | quinticIn | circularIn | elasticIn | . | bounceOut | cubicOut | quinticOut | circularOut | elasticOut | . | bounceInOut | cubicInOut | quinticInOut | circularInOut | elasticInOut | . |   |   |   |   |   | . | PerlinInOut |   |   |   |   | . ",
    "url": "https://ossia.io/score-docs/processes/automation_float.html#segment-shapes",
    "relUrl": "/processes/automation_float.html#segment-shapes"
  },"134": {
    "doc": "Automation (float)",
    "title": "Freehand function",
    "content": "Automation’s function can be hand-drawn using Alt+Drag in Automation editor. Drawn function will get optimized and transformed onto a beak-point function on mouse release so you can edit various points individually. ",
    "url": "https://ossia.io/score-docs/processes/automation_float.html#freehand-function",
    "relUrl": "/processes/automation_float.html#freehand-function"
  },"135": {
    "doc": "Automation (float)",
    "title": "Advanced edits",
    "content": "Lock between points . By default, moving a point in the automation is limited horizontally by previous and next points’ position in automation. This can be turned on and off using the Lock between points option in the automation contextual menu. When off, points can be freely moved along the whole automation’s slot. Suppress on overlap . When Lock between points option is unset, crossing adjacent points can be handled in two different ways. By default, crossing an adjacent point in automation will remove this point. This can be turned off using by unsetting the option in the automation’s contextual menu. When off, moved point will get inserted at its new position without removing other points in automation. ",
    "url": "https://ossia.io/score-docs/processes/automation_float.html#advanced-edits",
    "relUrl": "/processes/automation_float.html#advanced-edits"
  },"136": {
    "doc": "Automation (float)",
    "title": "Tween mode",
    "content": "Tweening allows an automation to ramp smoothly from the running value of an address which was assigned to, during the first segment. This means that, assuming an OSC address /foo, if tweening is enabled, no matter the visual “start value” of the first point of the automation curve, the actual first point during execution will be taken from the value of /foo when the score reaches that part. This allows smooth transitions from a live control, to a scripted one. ",
    "url": "https://ossia.io/score-docs/processes/automation_float.html#tween-mode",
    "relUrl": "/processes/automation_float.html#tween-mode"
  },"137": {
    "doc": "Automations",
    "title": "Automations",
    "content": "Automations are a specific kind of score Processes, which will change the value of a parameter in time according to a visual curve. ",
    "url": "https://ossia.io/score-docs/in-depth/automations.html",
    "relUrl": "/in-depth/automations.html"
  },"138": {
    "doc": "Automations",
    "title": "Automation types",
    "content": ". | Normal, 1D automation: documented here. | 2D automation: documented here. | Color automation: documented here. | . ",
    "url": "https://ossia.io/score-docs/in-depth/automations.html#automation-types",
    "relUrl": "/in-depth/automations.html#automation-types"
  },"139": {
    "doc": "Automations",
    "title": "Creating automations",
    "content": "It is possible to create automations in various ways besides dropping an automation process from the Library: . | By drag’n’dropping a parameter from the Device explorer to the score. | By using the Interpolate States feature. | By right-clicking on a value (green) port and pressing the “Create Automation” button. | . ",
    "url": "https://ossia.io/score-docs/in-depth/automations.html#creating-automations",
    "relUrl": "/in-depth/automations.html#creating-automations"
  },"140": {
    "doc": "Automations",
    "title": "Tweening",
    "content": "Automations can be tweened: that is, instead of starting from a fixed value, the automation can instead ramp from the current value of the parameter it is automating, in order to allow for smooth transitions. Check the inspector to enable the feature. ",
    "url": "https://ossia.io/score-docs/in-depth/automations.html#tweening",
    "relUrl": "/in-depth/automations.html#tweening"
  },"141": {
    "doc": "Automations",
    "title": "Units",
    "content": "Automations can use the ossia address and unit system. ",
    "url": "https://ossia.io/score-docs/in-depth/automations.html#units",
    "relUrl": "/in-depth/automations.html#units"
  },"142": {
    "doc": "Automations",
    "title": "Recording",
    "content": "It is possible to Recording messages from external devices as automations. See also the Score preferences for various options concerning the way these automations are recorded. ",
    "url": "https://ossia.io/score-docs/in-depth/automations.html#recording",
    "relUrl": "/in-depth/automations.html#recording"
  },"143": {
    "doc": "Breaking the timeline",
    "title": "Breaking the timeline",
    "content": "In previous steps of this Quick Start guide, we used score to write simple scenario use cases following a timeline-based approach pretty similar to the one found in usual DAW software. While such an approach allows to write very precise temporal developments of a scenario, it may also hit some limits in live performance situation or installation where a much more flexible approach is required. score offers a number of features to bridge the gap between different approaches and thus combine timeline-based workflow and cue-based workflow. One of them is the use of trigger points. ",
    "url": "https://ossia.io/score-docs/quick-start/breaking-the-timeline.html",
    "relUrl": "/quick-start/breaking-the-timeline.html"
  },"144": {
    "doc": "Breaking the timeline",
    "title": "Enabling triggers",
    "content": "Introducing trigger points in your scenario allows to keep organizing things in time while allowing interactive triggering of elements: when executing the scenario, parts of the scenario starting with a trigger point will be put “on hold” until they get triggered. When triggered, following automations and states will get executed at the speed and duration specified in the scenario. To add a trigger point, simply select a state on the scenario, then from its inspector, toggle on the trigger icon. When turning on the trigger, you can see a T-like icon appearing on top of the selected state. You can also note that a dashed line appears on top of the preceding automation slot. This indicates that the duration of the preceding automations is now undefined: preceding automations will get executed up until the trigger is, well… triggered. In the example above, the scenario start with a simple fade-in. Notice that it gets executed as the scenario play-head goes across the automation slot. While the scenario play-head continues its progression, you will notice though that the green progression bar at the top of the automation stops as it reaches the trigger point. Execution of the following automations is then on hold until the trigger point is triggered by a mouse click. From then, execution follow its curse until the next trigger point in the scenario. Here again, execution is put on hold until trigger point is clicked by mouse. ",
    "url": "https://ossia.io/score-docs/quick-start/breaking-the-timeline.html#enabling-triggers",
    "relUrl": "/quick-start/breaking-the-timeline.html#enabling-triggers"
  },"145": {
    "doc": "Breaking the timeline",
    "title": "Triggers remote control",
    "content": "In the example above, we used the mouse to trigger the followup of the scenario execution. While convenient for demo purpose, you are most likely to rely on other inputs in creation situation such as some controller gear. You may use as an input for some trigger points, any parameter from your device. To set an input for a trigger point, just grab the desired parameter in the Device explorer and drop it on the trigger icon. In the example above, we use as an input, one button of a Korg nanoKontrol Midi controller. When done, you will see in the inspector the address of the dropped parameter in the address field. You may also drop the parameter on the address field of the trigger point inspector. When playing your scenario, part of your scenario will now get triggered as you press the dedicated button on your controller. ",
    "url": "https://ossia.io/score-docs/quick-start/breaking-the-timeline.html#triggers-remote-control",
    "relUrl": "/quick-start/breaking-the-timeline.html#triggers-remote-control"
  },"146": {
    "doc": "Building from source",
    "title": "Building from source",
    "content": "Depending on the reasons that landed you on this page, you may want to look at the following instructions : . | If you want to package ossia score for a Linux distribution or something like that, please refer to Packaging score for Linux. | If you are an user of score and want to build the latest version, please refer to Creating a release build. | If you want to develop score then follow Hacking on score. | . ",
    "url": "https://ossia.io/score-docs/development/build-from-source.html",
    "relUrl": "/development/build-from-source.html"
  },"147": {
    "doc": "Bytebeat",
    "title": "What is bytebeat?",
    "content": ". Bytebeat is a minimal programming language for synthetic sounds, using various bit-level properties of numbers. Here are multiple guides to that language: . | Countercomplex’s blogpost which introduced Bytebeat | The absolute beginner’s guide to coding Bytebeats! | Greggman’s implementation | Radavis’s implementation | . ",
    "url": "https://ossia.io/score-docs/processes/bytebeat.html#what-is-bytebeat",
    "relUrl": "/processes/bytebeat.html#what-is-bytebeat"
  },"148": {
    "doc": "Bytebeat",
    "title": "Usage",
    "content": "Bytebeat code can be edited when pressing the small “window” button on the process. Each line of code can be treated independently. The bytebeat code is compiled with a C++ compiler, so technically it’s possible to go a little bit outside the bounds of traditional beats ; in particular, if the SDK is installed, the &lt;cmath&gt; C++ header will be available. ",
    "url": "https://ossia.io/score-docs/processes/bytebeat.html#usage",
    "relUrl": "/processes/bytebeat.html#usage"
  },"149": {
    "doc": "Bytebeat",
    "title": "Examples",
    "content": ". | A simple yet efficient tune: (((t&lt;&lt;1)^((t&lt;&lt;1)+(t&gt;&gt;7)&amp;t&gt;&gt;12))|t&gt;&gt;(4-(1^7&amp;(t&gt;&gt;19)))|t&gt;&gt;7) . | Lots of examples are available at the following link (they are partly backed up below for reference - note that due to the most used implementation being based on javascript, some changes to the code may be necessary, e.g. going from Math.abs to abs). | . (t%255&amp;t)-(t&gt;&gt;13&amp;t) (t&amp;t%255)-(t&gt;&gt;13&amp;(t%(t&gt;&gt;8|t&gt;&gt;16))) t*(t&gt;&gt;10&amp;((t&gt;&gt;16)+1)) //cycles through all t*(t&gt;&gt;10&amp;) melodies, like the 42 melody (t&gt;&gt;10)^(t&gt;&gt;14)|(t&gt;&gt;12)*42319 //basic rng w/ slight bias to fliping between high and low t&gt;&gt;t //odd thing (t&gt;&gt;8&amp;t)*t //chaotic (t&gt;&gt;13&amp;t)*(t&gt;&gt;8) //Slower version, has interesting properties (t&gt;&gt;8&amp;t)*(t&gt;&gt;15&amp;t) //Ambient (t%(t&gt;&gt;8|t&gt;&gt;16))^t //mod fractal tree cycles through different rhythms t%(t&gt;&gt;8|t&gt;&gt;16) //Acts like t and can be used for cool effect. Generates interesting and infinite rhythm variations. -0.99999999*t*t //Add more 9s to make slower, remove to make faster. t%(t&gt;&gt;13&amp;t) //Quiet, do -1 for to make louder and change the rhythm slightly. ((t&gt;&gt;8&amp;t&gt;&gt;4)&gt;&gt;(t&gt;&gt;16&amp;t&gt;&gt;8))*t //Not really sure. (((t*t) &amp; t&gt;&gt;8)/t)-1 //t&gt;&gt;8&amp;t variation? t%(t&gt;&gt;8^t&gt;&gt;4) // 11 khz only t%(t&gt;&gt;11^t&gt;&gt;12) //Another t like formula. Also a sweet 11khz song t%(t&gt;&gt;4^t&gt;&gt;16) // 22 khz only t*(t&gt;&gt;(t&gt;&gt;13&amp;t)) //i don't even (t-(t&gt;&gt;4&amp;t&gt;&gt;8)&amp;t&gt;&gt;12)-1 //The 8-bit echo, to play with, edit t&gt;&gt;12 to a number. Powers of 2 give square waves, powers of 2-1 give sawtooth, others are from t&gt;&gt;8&amp;t. Change t&gt;&gt;12 to t&gt;&gt;n to speed up or slow down. Remove -1 for starting quiet. (((t%(t&gt;&gt;16|t&gt;&gt;8))&gt;&gt;2)&amp;t)-1 //WARNING LOUD! Some kind of glitchcore thing? (((t%(t&gt;&gt;1|t&gt;&gt;9))&gt;&gt;2)&amp;t)-1 //Variation on above. (((t &amp; t&gt;&gt;8)-(t&gt;&gt;13&amp;t))&amp;((t &amp; t&gt;&gt;8)-(t&gt;&gt;13)))^(t&gt;&gt;8&amp;t) //Differences t&lt;&lt;((t&gt;&gt;8&amp;t)|(t&gt;&gt;14&amp;t)) //strange rhythms (t&lt;&lt;(t/(t&gt;&gt;8&amp;t))) //(t&gt;&gt;8&amp;t)-1 chaos remix t&lt;&lt;((t&gt;&gt;1|t&gt;&gt;8)^(t&gt;&gt;13)) //call and respond, 11kHz t&lt;&lt;((t&gt;&gt;1|t&gt;&gt;8)*(t&gt;&gt;13&amp;t&gt;&gt;12)) //call and respond 2, 11kHz t&lt;&lt;(t&gt;&gt;8&amp;(t/(t&gt;&gt;10&amp;t))) //another chaos remix t/(t%(t&gt;&gt;8|t&gt;&gt;16)) //8 or 11khz best, extremely loud grinding machine (t&gt;&gt;8&amp;t&gt;&gt;16)*t&gt;&gt;4 //32kHz, super Sierpinski scale (t &amp; (t&gt;&gt;15+(t&gt;&gt;8&amp;t)))*t //quarternoisemachine (t*(t&gt;&gt;5|t&gt;&gt;8))&gt;&gt;(t&gt;&gt;16&amp;t) //tejeez's t&gt;&gt;5|t&gt;&gt;8 song, edited to last forever and be scariers ((t&gt;&gt;8&amp;t)-(t&gt;&gt;3&amp;t&gt;&gt;8|t&gt;&gt;16))&amp;128 //Pulse wave heaven, General formula: ((BYTEBEAT1)-(BYTEBEAT2))&amp;MULTOF2, bytebeat1 can be just \"1\" (t^t&gt;&gt;8)*(t&gt;&gt;16&amp;t) //dance of the fractals (t*t)/(t^t&gt;&gt;12) //Voice changes ((t*t)/(t^t&gt;&gt;8))&amp;t //fractal heaven (t&gt;&gt;4 &amp; t&gt;&gt;8)*(t&gt;&gt;16&amp;t) //t&gt;&gt;4&amp;t&gt;&gt;8 builder (t&gt;&gt;4 &amp; t&gt;&gt;8)/(t&gt;&gt;16&amp;t) //dialtones ((2*(t&amp;1)-1)*t)-(t&gt;&gt;8) //weaoowwwoooooiiinnn (t&gt;&gt;5)*((t&amp;1)+(t&gt;&gt;16)) //eeclicks, change t&gt;&gt;16 to t&gt;&gt;16&amp;t for a variation. (((sin(t*t/10000000))&gt;0.5)-1)*t //speedupupup (((-t&amp;t&gt;&gt;12)/32)-1)*t //filterspinsky (((-t&amp;128)/64)-1)*t //triangle wave, todo: find a way to allow for any pitch. sin(t/40)&gt;0.5\\?t:-t //tertiary operator maddness sin(t/5+(sin(t/5))+t/1000)*64+t/2500 //wowaowowao sin(t/5+((sin(t/5)/(t/(4000*(t&gt;&gt;8^t&gt;&gt;4))))))*64+128 //signal to noise ratio (sin(sin(t/5)+t*t/(t&gt;&gt;8^t&gt;&gt;4))*100)+128 //sine wave harmonics and such (t*t)/(t&gt;&gt;8&amp;t) //signal decay2 t*t/(t&gt;&gt;n) //replace n with a smallish number (1 to 16 best) for a variety of effects. (t*t/(1+(t&gt;&gt;9&amp;t&gt;&gt;8)))&amp;128 //everything is broken t*(1/t*t)^t //fire crackles t%(t&gt;&gt;10&amp;t) (t &amp; t&gt;&gt;8)-(t&gt;&gt;16&amp;t) (sin(sin(t/10)*t*t/10000000000)*32)+128 //generic: (sin(sin(t/pitch))*t*t/speed)*amplitude)+128 (sin(tan(t/50)*t*t/10000000000)*32)+128 ((sin(t/10000)*t)&gt;&gt;4&amp;t&gt;&gt;8)*t //Speedupslowdown (sin(t/10000)*t&gt;&gt;n)/(sin(t/10001)) //t&gt;&gt;n like formula, where n is which t&gt;&gt;_ to act like. It's glitchy-ish. (sin(t/10000)*t&gt;&gt;8)/(sin(t/10001))&amp;t //Example of formula (sin(t/10)*(((t&gt;&gt;8&amp;t)%256)/2)+128) //non-cliping, sine form of t&gt;&gt;8&amp;t sin(t/(1+(t&gt;&gt;8&amp;t&gt;&gt;13)))*64+128 //Sine wave heaven t*t/(10000*(t&gt;&gt;8&amp;t&gt;&gt;13)) (t&amp;(t&gt;&gt;7|t&gt;&gt;8|t&gt;&gt;16)^t)*t w=Math.pow(2,t&gt;&gt;8&amp;t&gt;&gt;13),(128/w&amp;t)&gt;1?w*t:-w*(t+1) //Triangle wave song. t*((t/401)^(t/400)) //it wont stop (t&gt;&gt;(t&gt;&gt;(t/4)))^t //Chain dance ((t/256)&gt;&gt;(t&gt;&gt;t)) //Slow n Noisy chain (sin(t/10+sin(t*Math.pow(2,t&gt;&gt;10))))*64+128 //creepy t/64&gt;&gt;(t&gt;&gt;t/4) //ambient (t%256)&gt;(cos(t/40000)*128+128)?0:128 //conditional expression experiment. Pulse wave duty cycle cycler t*((t&gt;&gt;8&amp;t&gt;&gt;3)&gt;&gt;(t&gt;&gt;16&amp;t)) //Use with below (t*(t&gt;&gt;8&amp;t&gt;&gt;3))&gt;&gt;(t&gt;&gt;16&amp;t) //Use with above (t*((t%(t&gt;&gt;8|t&gt;&gt;16))&gt;&gt;8|t&gt;&gt;5))^(t*(t&gt;&gt;5)) //break t%(t&gt;&gt;(t/4)) //ambient sin(t/(t&gt;&gt;8&amp;t&amp;t&gt;&gt;13))&gt;0?128:64 //more conditional expressions! sin(t/((t&gt;&gt;8&amp;t&gt;&gt;7)%3))&gt;0?128:0 //morse code dialoge (sin(t/((t&gt;&gt;8&amp;t&gt;&gt;7)%3))*64)+128 //alternate version (uses sine waves instead of square) (t*(-(t&gt;&gt;8|t|t&gt;&gt;9|t&gt;&gt;13)))^t //ststututterter ((Math.abs(sin(t/(\"34543\"[t&gt;&gt;13&amp;3])))+sin(t/\"23432\"[t&gt;&gt;14&amp;3])))*40+128 //basic array thing (((t/91)&amp;t)^((t/90)&amp;t))-1 //waiver (t*t)/(t&gt;&gt;13 ^ t&gt;&gt;8) //glissando (t/(t%(t&gt;&gt;8|t&gt;&gt;16)))|(t*t/(t&gt;&gt;8|t&gt;&gt;13)) //(t/(t%(t&gt;&gt;8|t&gt;&gt;16))) and (t*t/(t&gt;&gt;8|t&gt;&gt;13)) mashup (t/(t%(t&gt;&gt;8|t&gt;&gt;16)))|(t*t/(t&gt;&gt;8|t&gt;&gt;16)) //variation w=t/10,sin((w&gt;&gt;8&amp;w))*64+128 //run (sin(sin(t/10)+t/(1000-(t&gt;&gt;10|t&gt;&gt;12)))*64)+128 //click and pop (sin(sin(t/10)+t/(1000-(t&gt;&gt;10^t&gt;&gt;12)))*64)+128 //click and pop 2 (sin(sin(t/10)+t/(1000-(t&gt;&gt;10^t&gt;&gt;12)))*64)^(sin(sin(t/10)+t/(1000-(t&gt;&gt;10|t&gt;&gt;12)))*64)+128 //Distort (sin(sin(t/10)+t/(1000-(t&gt;&gt;10&amp;t&gt;&gt;4))))*64+128 //bit crusher t&gt;&gt;(t%(t&gt;&gt;1&amp;t)) //Broken Signal sin((t%(t&gt;&gt;8|t&gt;&gt;16))/10)*64+128 //click and pop 3 w=(sin(t&gt;&gt;16)*6890866887),(t&gt;&gt;5|t&gt;&gt;8)*(t|w) //RNG changes stuff. Replace the big number with another for a variation. w=t%(t&gt;&gt;8|t&gt;&gt;16),b=w&gt;&gt;5|t&gt;&gt;8,(b*t)^(t*(t&gt;&gt;8)) //what's left behind t*t/(t&gt;&gt;8&amp;t&gt;&gt;4) //chaos ((t/(t&gt;&gt;8&amp;t&gt;&gt;7))&amp;t)-1 //beep ((t/(t&gt;&gt;8&amp;t&gt;&gt;4))&amp;t&gt;&gt;8)*t //t&gt;&gt;4&amp;t&gt;&gt;8 remix t/(t%(t&gt;&gt;8|t&gt;&gt;12)) //32kHz sin(sin(t/100)-t/((2+(t&gt;&gt;10&amp;t&gt;&gt;12)%9)))*64+128 //trill w=t%(t&gt;&gt;8|t&gt;&gt;16),b=w&gt;&gt;5|t&gt;&gt;8,(b*t)-(t*(t&gt;&gt;8)) //(t&gt;&gt;5|t&gt;&gt;8)*t builder (1.001*t^-t*1.001)+t/(500+(t&gt;&gt;16&amp;t&gt;&gt;8)) //process complete (t&amp;t&gt;&gt;4)-(t&gt;&gt;13&amp;t) //dark kick r=sin(t&gt;&gt;12)*30,w=sin(t/(r%5))+sin(t/(r%6)),w*64+128 //replace \"30\" with another number to get a new song w=t%(t&gt;&gt;15)&gt;0?t:-t,((w&gt;&gt;4&amp;w&gt;&gt;8)*w) //green noise, black noise ((t*.98)%(t&gt;&gt;13&amp;t&gt;&gt;12))+(t%(t&gt;&gt;13&amp;t&gt;&gt;10)) //duo team. Based off of mu6k's \"Long Line Theory\" t%50.01+t%40.1+t%30.1+t%60.01 //harmony. Based off of mu6k's \"Long Line Theory\" w=[1,2,3,4,3,4,1][(t&gt;&gt;13)%7]*t,(w%50.01+w%40.1+w%30.1+w%60.01) //harmony v2. Based off of mu6k's \"Long Line Theory\" n=50+([4,6,4,6,1,3,1,3][(t&gt;&gt;13)%8]),w=([1,1,1][(t&gt;&gt;13)%3])*t,(w%n)+(w%(n-10)+(w%(n+10))) //sad chords, again based off of mu6k's \"Long Line Theory\" (t&gt;&gt;8&amp;(t/(t&gt;&gt;4&amp;t&gt;&gt;8))&gt;&gt;4)*t //glitch s=((t&gt;&gt;8&amp;t&gt;&gt;4)%24)+1,v=128,(t*(t&gt;&gt;8&amp;t&gt;&gt;4))&amp;128?sin(t/s)*v+128:-sin(t/s)*v+128 //not quite a sine wave (((t&gt;&gt;8)+(t&gt;&gt;16&amp;t))&amp;t&gt;&gt;2)*t //use with below (((t&gt;&gt;8)+(t&gt;&gt;16&amp;t))&amp;t&gt;&gt;3)*t //use with above, tag team swish a=[1,1,2,3,1,1,2,3,1,1,2,4,4,4,5,5,5][(t&gt;&gt;12)%17],b=[5,4,3,2][(t&gt;&gt;16)%4],(t*b/a)%50.1+(t*b/a)%50 //array song. First real one i promise this time. t&gt;&gt;(8/((t/32)%3)) //reverse t*((((t&gt;&gt;8)&amp;t&gt;&gt;2)*t)/(((t&gt;&gt;8)&amp;t&gt;&gt;3)*t)+(((t&gt;&gt;8)&amp;t&gt;&gt;3)*t)/(((t&gt;&gt;8)&amp;t&gt;&gt;2)*t)) //everytype smasher ((t&gt;&gt;10|t&gt;&gt;1)&amp;t|(t&gt;&gt;18&amp;t))-t //muncher ((t/4)&gt;&gt;(t/4))&gt;&gt;(t&gt;&gt;(t/8))|t&gt;&gt;2 //plucker ((t/4)&gt;&gt;t/4)|(t&gt;&gt;2) //plucker v2 (t &amp; ((t%(t&gt;&gt;1&amp;t))|t&gt;&gt;3^t&gt;&gt;4)&gt;&gt;7)-1 //fractal glitcher (t &amp; ((t%(t&gt;&gt;1&amp;t))|t&gt;&gt;13^t&gt;&gt;5)&gt;&gt;7)-1 //fractal glitcher v2 ((t/1000)^(t/1001))*t //jumper t/((t%(t&gt;&gt;13&amp;t))) //noisecore synthcore t/(t^(t+1+(t&gt;&gt;16))) //cyclic . ",
    "url": "https://ossia.io/score-docs/processes/bytebeat.html#examples",
    "relUrl": "/processes/bytebeat.html#examples"
  },"150": {
    "doc": "Bytebeat",
    "title": "Bytebeat",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/bytebeat.html",
    "relUrl": "/processes/bytebeat.html"
  },"151": {
    "doc": "Camera device",
    "title": "Example: showing the raw camera feed",
    "content": "In this example, we perform the following steps: . | Add the camera input through the device explorer. | Likewise, add a window device in which the camera is going to be rendered. | Add a “passthrough” video effect, to connect the camera input to the window output. | Set up the passthrough ports. | Press play and enjoy ! | . The passthrough effect can be found in the user library, in the folder Presets/GLSL_Shaders/utility. ",
    "url": "https://ossia.io/score-docs/devices/camera-device.html#example-showing-the-raw-camera-feed",
    "relUrl": "/devices/camera-device.html#example-showing-the-raw-camera-feed"
  },"152": {
    "doc": "Camera device",
    "title": "Technical information",
    "content": "The video input system uses FFMPEG, which itself leverages the operating system’s video input decoding mechanism as far as possible. ",
    "url": "https://ossia.io/score-docs/devices/camera-device.html#technical-information",
    "relUrl": "/devices/camera-device.html#technical-information"
  },"153": {
    "doc": "Camera device",
    "title": "V4L2 support",
    "content": "V4L2 is the Linux video subsystem API. The v4l2loopback kernel module allows for a lot of useful things. Grabbing the screen with v4l2loopback . $ sudo modprobe v4l2loopback $ ffmpeg -f x11grab -framerate 60 -video_size 3840x2160 -i :0.0+0,0 -f v4l2 /dev/video0 . Forwarding an external video file to score through v4l2loopback . $ sudo modprobe v4l2loopback $ while 1 ; do ffmpeg -re -i ./test.mp4 -f v4l2 /dev/video0 ; done . ",
    "url": "https://ossia.io/score-docs/devices/camera-device.html#v4l2-support",
    "relUrl": "/devices/camera-device.html#v4l2-support"
  },"154": {
    "doc": "Camera device",
    "title": "Special camera support",
    "content": "Microsoft Kinect . Support for Kinect cameras has been implemented through the Freenect library. However, the support is still experimental and requires building score from source with the Freenect libraries. Spout, Syphon, PipeWire . Spout is supported as output on Windows. Syphon on Mac is not yet supported, neither is PipeWire on Linux. Complete support for both systems is slated for a 3.x release of score. ",
    "url": "https://ossia.io/score-docs/devices/camera-device.html#special-camera-support",
    "relUrl": "/devices/camera-device.html#special-camera-support"
  },"155": {
    "doc": "Camera device",
    "title": "Camera device",
    "content": ". Score supports using camera inputs in its VFX graph. The camera can be used as the input of a texture port. ",
    "url": "https://ossia.io/score-docs/devices/camera-device.html",
    "relUrl": "/devices/camera-device.html"
  },"156": {
    "doc": "Command line API",
    "title": "Command-line reference",
    "content": " ",
    "url": "https://ossia.io/score-docs/reference/commandline.html#command-line-reference",
    "relUrl": "/reference/commandline.html#command-line-reference"
  },"157": {
    "doc": "Command line API",
    "title": "List of command-line options",
    "content": "Getting the list of options . $ ossia-score --help . Loading a score on startup: . $ ossia-score filename # For example: $ ossia-score /home/oscar/my-score.score . Playing a score on startup . $ ossia-score --autoplay filename # For example: $ ossia-score --autoplay /home/oscar/my-score.score . Playing a score on startup after some delay . This is useful if for instance the score has audio plug-ins that take some time to load, such as orchestral plug-ins with large sound banks. $ ossia-score --autoplay filename --wait delay_in_seconds # For example: $ ossia-score --autoplay /home/oscar/my-score.score --wait 5 . Loading score without showing the GUI . $ ossia-score --no-gui . (note: this is not very useful without specifying a file to load). Loading score without showing the “do you want to restore” pop-up dialog . This is useful if you are quitting score for instance by killing the process, as score will register that as a crash, which will cause the pop-up to show up next time. $ ossia-score --no-restore . Loading score in software rendering mode . ossia score uses as of v3 OpenGL for rendering the main timeline. On some old machines or machines with bad GL drivers, this can cause issues. We then recommend using that switch to launch it. $ ossia-score --no-opengl . ",
    "url": "https://ossia.io/score-docs/reference/commandline.html#list-of-command-line-options",
    "relUrl": "/reference/commandline.html#list-of-command-line-options"
  },"158": {
    "doc": "Command line API",
    "title": "Complete recommended command line to launch a score on startup",
    "content": "On Linux: . $ /usr/bin/ossia-score --no-gui --no-restore --wait 5 --autoplay \"/path/to/your/score.score\" . On macOS: . $ /Applications/Score.app/Contents/MacOS/score --no-gui --no-restore --wait 5 --autoplay \"/path/to/your/score.score\" . On Windows: . &gt; \"c:\\Program Files\\ossia score\\score.exe\" --no-gui --no-restore --wait 5 --autoplay \"c:\\path\\to\\your\\score.score\" . ",
    "url": "https://ossia.io/score-docs/reference/commandline.html#complete-recommended-command-line-to-launch-a-score-on-startup",
    "relUrl": "/reference/commandline.html#complete-recommended-command-line-to-launch-a-score-on-startup"
  },"159": {
    "doc": "Command line API",
    "title": "List of useful environment variables",
    "content": ". | SCORE_DISABLE_ALSA=1: on Linux, disables the ALSA backend. | SCORE_DISABLE_AUDIOPLUGINS=1: disables scanning of VST, LV2 plug-ins on startup. | FAUST_LIB_PATH=/some/path: can override the default path where score looks for Faust libraries (by default they ship with score). | . ",
    "url": "https://ossia.io/score-docs/reference/commandline.html#list-of-useful-environment-variables",
    "relUrl": "/reference/commandline.html#list-of-useful-environment-variables"
  },"160": {
    "doc": "Command line API",
    "title": "Command line API",
    "content": "You can launch ossia score from the command line or shell scripts with various useful options. ",
    "url": "https://ossia.io/score-docs/reference/commandline.html",
    "relUrl": "/reference/commandline.html"
  },"161": {
    "doc": "Common practices",
    "title": "Common practices",
    "content": "The following pages will guide you through recurring patterns and snippets that apply to various use-cases common in the creation of media artworks. For instance, how to spatialize sound beyond stereo, how to organize a score in scenes, how to play cues, what are the possibilities for live-coding in score… . ",
    "url": "https://ossia.io/score-docs/common-practices",
    "relUrl": "/common-practices"
  },"162": {
    "doc": "Console",
    "title": "Console panel",
    "content": "The console panel (shortcut: Ctrl+Shift+C(Win / Linux) or⌘+Shift+C(Mac)) allows to create and run macros written in Javascript (ES7). See Scripting API for detailed information on the script features. ",
    "url": "https://ossia.io/score-docs/panels/console.html#console-panel",
    "relUrl": "/panels/console.html#console-panel"
  },"163": {
    "doc": "Console",
    "title": "Console",
    "content": " ",
    "url": "https://ossia.io/score-docs/panels/console.html",
    "relUrl": "/panels/console.html"
  },"164": {
    "doc": "Control utilities",
    "title": "Impulse metronome",
    "content": ". The simplest possible metronome, synchronized to its parent interval. Will send an impulse on each beat. ",
    "url": "https://ossia.io/score-docs/processes/control-utilities.html#impulse-metronome",
    "relUrl": "/processes/control-utilities.html#impulse-metronome"
  },"165": {
    "doc": "Control utilities",
    "title": "Free metronome",
    "content": ". A desynchronized metronome. It can ignore the parent interval’s tempo and will instead beat at its own unrelated speed, a bit like the [metro] objects in Pure Data or Max/MSP. If “Quantify” is set on “Free”, then the raw frequency in Hertz will be used as tempo source. Else, the parent tempo is used. The rate can be chosen with the musical division selector. ",
    "url": "https://ossia.io/score-docs/processes/control-utilities.html#free-metronome",
    "relUrl": "/processes/control-utilities.html#free-metronome"
  },"166": {
    "doc": "Control utilities",
    "title": "Control utilities",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/control-utilities.html",
    "relUrl": "/processes/control-utilities.html"
  },"167": {
    "doc": "Controlling score with OSCQuery",
    "title": "Controlling score remotely with OSCQuery",
    "content": "A score can be controlled through OSC and OSCQuery with the Local device. See also the WebSocket remote control protocol. ",
    "url": "https://ossia.io/score-docs/faq/controlling-score-with-oscquery.html#controlling-score-remotely-with-oscquery",
    "relUrl": "/faq/controlling-score-with-oscquery.html#controlling-score-remotely-with-oscquery"
  },"168": {
    "doc": "Controlling score with OSCQuery",
    "title": "Controlling score with OSCQuery",
    "content": " ",
    "url": "https://ossia.io/score-docs/faq/controlling-score-with-oscquery.html",
    "relUrl": "/faq/controlling-score-with-oscquery.html"
  },"169": {
    "doc": "Control surface",
    "title": "Control surface process",
    "content": ". This process allows to control remote parameters defined in the Device explorer from the central timeline / nodal view. To add an address, drag’n’drop it from the explorer to the process’s central area. This will add it as an automatable and controllable parameter for the duration of the execution of that process, with a meaningful user interface widget depending on the metadata associated with the OSC node (unit, data type, range…). Note that like every other score process, it will only have an effect during the execution of the score. ",
    "url": "https://ossia.io/score-docs/processes/controlsurface.html#control-surface-process",
    "relUrl": "/processes/controlsurface.html#control-surface-process"
  },"170": {
    "doc": "Control surface",
    "title": "Remote control API",
    "content": "The control surface process provides remote control features, through the system discussed in Remote Control. When such a process starts executing, the following message is sent: . { \"Message\": \"ControlSurfaceAdded\", \"Path\": \"/path/to/the/surface\", \"Controls\": [ ... list of control objects... ] } . When the process ends, the following message is sent: . { \"Message\": \"ControlSurfaceRemoved\", \"Path\": \"/path/to/the/surface\" } . Controls . A control object defines a given control and has the following format. { \"Custom\": \"The name of the control\", \"Domain\": { ... domain object ... }, \"Value\": { ... value object ... }, \"id\": 1234, // the identifier of the individual control \"uuid\": \"af2b4fc3-aecb-4c15-a5aa-1c573a239925\" // the identifier of the control kind } . The remote can send the following message to change a parameter in score: . { \"Message\": \"ControlSurface\", \"Path\": \"/path/to/the/surface\", \"id\": 1234, // the id of the individual control that changed \"Value\": { ... the value object ... } } . Value object . The Value object has the following format: . { \"TYPE\": VALUE } . Where TYPE can be any of Int, Float, Bool, String, Char, Vec2f, Vec3f, Vec4f, Tuple, Impulse. For instance, valid values are: . { \"Float\": 1.23456 } { \"Int\": 127 } { \"String\": \"hello world\" } { \"Vec2f\": [0.5, 1.54] } { \"Bool\": true } { \"Impulse\": 1 } { \"Tuple\": [ { \"Float\": 1.234}, { \"String\": \"hello\" } ] } . Domain object . The Domain object has the following format: . { \"TYPE\": { \"Min\": THE_MIN, \"Max\": THE_MAX } } . where TYPE is the same than above. The most common cases are of course Int and Float as it does not really make sense for bools, etc. Example to have a slider that goes from -10 to 100: . { \"Float\": { \"Min\": -10 \"Max\": 100 } } . It is also possible to define a domain through a set of acceptable values instead of a range: . { \"TYPE\": { \"Values\": [ ... array of acceptable values ...] } } . ",
    "url": "https://ossia.io/score-docs/processes/controlsurface.html#remote-control-api",
    "relUrl": "/processes/controlsurface.html#remote-control-api"
  },"171": {
    "doc": "Control surface",
    "title": "Control surface",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/controlsurface.html",
    "relUrl": "/processes/controlsurface.html"
  },"172": {
    "doc": "C++ JIT",
    "title": "C++ JIT",
    "content": "This process allows to compile C++ code into a score process at run-time. You can complete the process by opening the programming window in the inspector panel on the right. This allows ‘Just-in-time’ programming in C++ . ",
    "url": "https://ossia.io/score-docs/processes/cpp_jit.html",
    "relUrl": "/processes/cpp_jit.html"
  },"173": {
    "doc": "Cues",
    "title": "Cues",
    "content": "Cues are an essential part of interactive shows: they allow to record a set of controls and messages that will be applied at a single point in time: OSC or DMX messages, MIDI control changes, etc. In score, cues are messages that are contained inside states. ",
    "url": "https://ossia.io/score-docs/cues.html",
    "relUrl": "/cues.html"
  },"174": {
    "doc": "Cues",
    "title": "Creating a cue",
    "content": "Cues are created by drag’n’drop, from a set of Device explorer nodes, to the score. It is possible to add messages to a cue by dropping on it. Existing messages to a given address will be replaced by the value that is being dropped. ",
    "url": "https://ossia.io/score-docs/cues.html#creating-a-cue",
    "relUrl": "/cues.html#creating-a-cue"
  },"175": {
    "doc": "Cues",
    "title": "Updating a cue",
    "content": "If you want to replace the parameters of a cue with their current value in the explorer, you can click on the state. The state inspector has a “Snapshot” feature which will update all the values stored in the cue, with their current live value. | The first icon with the camera, “Snapshot” (Ctrl+L(Win / Linux) or⌘+L(Mac)), takes all the parameters currently selected in the Device explorer and copies them to the cue. | The second icon, with the circled camera, “Refresh” (Ctrl+R(Win / Linux) or⌘+R(Mac)), takes all the parameters inside the saved cue, and updates them to their current “live” value as shown in the device explorer. | . ",
    "url": "https://ossia.io/score-docs/cues.html#updating-a-cue",
    "relUrl": "/cues.html#updating-a-cue"
  },"176": {
    "doc": "Cues",
    "title": "Playing a cue",
    "content": "Cues will be played automatically when the score execution reaches them: . ",
    "url": "https://ossia.io/score-docs/cues.html#playing-a-cue",
    "relUrl": "/cues.html#playing-a-cue"
  },"177": {
    "doc": "Cues",
    "title": "Playing a cue manually",
    "content": "It is possible to play a cue through the “Play” tool in the user interface. ",
    "url": "https://ossia.io/score-docs/cues.html#playing-a-cue-manually",
    "relUrl": "/cues.html#playing-a-cue-manually"
  },"178": {
    "doc": "Cues",
    "title": "Playing a cue with an external control",
    "content": "It is possible to entirely control when a cue is going to be sent, by adding a trigger on it and let it “float” in the scenario. Such a floating cue can originally be created by double-clicking on the scenario (or drag’n’dropping directly from the Device explorer, and removing the created interval afterwards). Then, one needs to add a trigger (through the inspector or by pressing T when the state is selected), and configure it for out-of-time playback. Here is how this would work: . The set-up on the triggers look like this: . Notice in particular that the two buttons, “Auto-Trigger” and “Start on play”, are checked. It would be possible for instance to trigger the cue when a MIDI CC reaches a specific value or similar. See Breaking the timeline for more information on triggers. ",
    "url": "https://ossia.io/score-docs/cues.html#playing-a-cue-with-an-external-control",
    "relUrl": "/cues.html#playing-a-cue-with-an-external-control"
  },"179": {
    "doc": "Development",
    "title": "score development manual",
    "content": "This section of the manual gives an overview of the score development processes. It explains how to make a local build, create a plug-in, discusses the software architecture, etc. ",
    "url": "https://ossia.io/score-docs/development#score-development-manual",
    "relUrl": "/development#score-development-manual"
  },"180": {
    "doc": "Development",
    "title": "Development",
    "content": " ",
    "url": "https://ossia.io/score-docs/development",
    "relUrl": "/development"
  },"181": {
    "doc": "Devices",
    "title": "Devices",
    "content": " ",
    "url": "https://ossia.io/score-docs/devices.html",
    "relUrl": "/devices.html"
  },"182": {
    "doc": "Devices",
    "title": "What are devices ?",
    "content": "Devices are pieces of software or hardware used in your project to be controlled from score or used as input for your score scenario. Score currently support the following devices types: . | OSC | Utilities | Hardware | Web | Lights | Audio | Video | . | OSCQuery | Mapper | Midi in | HTTP | Artnet | Audio | Window | . | OSC | Local | Midi out | WS |   |   | Camera | . | Minuit |   | Serial |   |   |   | Spout | . |   |   | Joystick |   |   |   | Syphon | . |   |   | Wiimote |   |   |   | Shmdata | . ",
    "url": "https://ossia.io/score-docs/devices.html#what-are-devices-",
    "relUrl": "/devices.html#what-are-devices-"
  },"183": {
    "doc": "Devices",
    "title": "Setting up devices",
    "content": "From score main window, right-click in the Device explorer on the left of window and choose Add device from the Device explorer contextual menu. This brings score’s device setup window. In the Device setup window, in the left column, select the desired device type. Each device type has its setup panel depending of the used protocol. Please see the relevant device reference page to setup your device. ",
    "url": "https://ossia.io/score-docs/devices.html#setting-up-devices",
    "relUrl": "/devices.html#setting-up-devices"
  },"184": {
    "doc": "Embedded devices",
    "title": "Hardware support",
    "content": "ossia score supports running on ARM under Raspberry Pi 3 and 4. We recommend a Raspberry Pi 4 for much better performance for audio processing, as well as better support for graphics feature due to its more advanced GPU. Other embedded boards will also likely work, they have just not been tested yet. If Qt runs on the hardware then most likely score will also run – see the following page for the reference hardware supported by Qt: . https://doc.qt.io/QtForDeviceCreation/qtdc-supported-platforms.html . Please report to us if you try to build and run score on any other kind of exotic system ! . ",
    "url": "https://ossia.io/score-docs/in-depth/embedded.html#hardware-support",
    "relUrl": "/in-depth/embedded.html#hardware-support"
  },"185": {
    "doc": "Embedded devices",
    "title": "Running on the Raspberry Pi (Raspbian)",
    "content": "Raspberry Pi 3 and 4 pre-made builds are accessible on Github Actions. Pi Zero, 1, 2 can technically work but no builds are currently being made for them. To use ossia score on the Pi, it is necessary to: . | Use an up-to-date Raspbian Buster distribution (Stretch is not supported). You can follow this guide. | Update the firmware to the kernel 5.10 at least: sudo rpi-update and reboot. | Enable Full KMS OpenGL settings in sudo raspi-config. Launch the utility, go to 6 Advanced Options, then GL Driver, then select GL (Full KMS) and reboot. Check this link for more information on the configuration process. | . If done correctly, /boot/config.txt should contain the following uncommented line near the end: . dtoverlay=vc4-kms-v3d . Then you are good to go. Two scripts are provided: ossia-score-x11 and ossia-score-eglfs. | ossia-score-x11 is for running under the normal desktop environment of the Pi. | ossia-score-eglfs will run the graphics pipeline full-screen, bypassing the desktop environment entirely, which can be much more efficient - you don’t even need to run X11 that way. But it is mostly useful in player mode, not for the score edition as there won’t be any window borders / chrome. | . Note that we recommend not using the default Pi desktop environment: in our testing, switching to a lighter environment such as i3wm or fluxbox instead of the default Pi desktop made a large difference in performance and drop-outs for the scores. ",
    "url": "https://ossia.io/score-docs/in-depth/embedded.html#running-on-the-raspberry-pi-raspbian",
    "relUrl": "/in-depth/embedded.html#running-on-the-raspberry-pi-raspbian"
  },"186": {
    "doc": "Embedded devices",
    "title": "Dependencies for minimal RPi installs",
    "content": "If you installed an OS without any GUI on your Raspberry, some packages may be missing at first when launching score. You can install them with the following command: . $ sudo apt install libasound2 libblkid1 libbsd0 libc6 libdbus-1-3 libdouble-conversion1 libdrm2 libevdev2 libexpat1 libffi6 libgbm1 libgcc1 libgcc-8-dev libgcrypt20 libglib2.0-0 libgpg-error0 libgudev-1.0-0 libinput10 libjbig0 libjpeg62-turbo liblz4-1 liblzma5 libmount1 libmtdev1 libpcre3 libselinux1 libstdc++6 libsystemd0 libtiff5 libtinfo6 libudev1 libuuid1 libwacom2 libwayland-client0 libwayland-cursor0 libwayland-egl1 libwayland-server0 libwebp6 libxcb1 libxcb-icccm4 libxcb-image0 libxcb-keysyms1 libxcb-randr0 libxcb-render0 libxcb-render-util0 libxcb-shape0 libxcb-shm0 libxcb-sync1 libxcb-util0 libxcb-xfixes0 libxcb-xinerama0 libxcb-xkb1 libxkbcommon0 libxkbcommon-x11-0 libzstd1 raspi-copies-and-fills zlib1g . ",
    "url": "https://ossia.io/score-docs/in-depth/embedded.html#dependencies-for-minimal-rpi-installs",
    "relUrl": "/in-depth/embedded.html#dependencies-for-minimal-rpi-installs"
  },"187": {
    "doc": "Embedded devices",
    "title": "Configuring the resolution under EGLFS",
    "content": ". | First create a config.json file with the following content: | . { \"device\": \"/dev/dri/card0\", \"pbuffers\": true, \"outputs\": [ { /* change to HDMI2 depending on the used output */ \"name\": \"HDMI1\", /* refresh rate can be specified with 1920x1080@60 for instance */ \"mode\": \"1280x720\" } ] } . | Then set the following environment variables before running ossia-score-eglfs: | . export QT_QPA_EGLFS_KMS_ATOMIC=1 export QT_QPA_EGLFS_KMS_CONFIG=$PWD/config.json . ",
    "url": "https://ossia.io/score-docs/in-depth/embedded.html#configuring-the-resolution-under-eglfs",
    "relUrl": "/in-depth/embedded.html#configuring-the-resolution-under-eglfs"
  },"188": {
    "doc": "Embedded devices",
    "title": "Building for the Raspberry Pi (Raspbian)",
    "content": ". | ossia score build scripts: https://github.com/ossia/score/tree/master/ci | ossia SDK build scripts (building latest Qt, FFMPEG, etc): https://github.com/ossia/sdk/tree/master/ARM/RPi4 | . They will produce binaries optimized for Pi 4, and that will also work on Pi 3. ",
    "url": "https://ossia.io/score-docs/in-depth/embedded.html#building-for-the-raspberry-pi-raspbian",
    "relUrl": "/in-depth/embedded.html#building-for-the-raspberry-pi-raspbian"
  },"189": {
    "doc": "Embedded devices",
    "title": "Arch Linux ARM",
    "content": "Experimental builds have been confirmed to work on Arch Linux ARM. The simplest is to use the AUR package ossia-score. ",
    "url": "https://ossia.io/score-docs/in-depth/embedded.html#arch-linux-arm",
    "relUrl": "/in-depth/embedded.html#arch-linux-arm"
  },"190": {
    "doc": "Embedded devices",
    "title": "Caveats",
    "content": "Some features are currently disabled – namely, VST3 support as there aren’t many Linux ARM VST3s. ",
    "url": "https://ossia.io/score-docs/in-depth/embedded.html#caveats",
    "relUrl": "/in-depth/embedded.html#caveats"
  },"191": {
    "doc": "Embedded devices",
    "title": "Performance optimization",
    "content": ". | If possible do not use PulseAudio but instead use ALSA directly. | If possible use a RT kernel. | If possible run with as few processes as possible - if you can avoid running any desktop environment / X11 / Wayland it will be faster. | . ",
    "url": "https://ossia.io/score-docs/in-depth/embedded.html#performance-optimization",
    "relUrl": "/in-depth/embedded.html#performance-optimization"
  },"192": {
    "doc": "Embedded devices",
    "title": "Embedded devices",
    "content": " ",
    "url": "https://ossia.io/score-docs/in-depth/embedded.html",
    "relUrl": "/in-depth/embedded.html"
  },"193": {
    "doc": "Execution engine",
    "title": "Execution engine",
    "content": " ",
    "url": "https://ossia.io/score-docs/in-depth/execution.html",
    "relUrl": "/in-depth/execution.html"
  },"194": {
    "doc": "Execution engine",
    "title": "libossia execution",
    "content": " ",
    "url": "https://ossia.io/score-docs/in-depth/execution.html#libossia-execution",
    "relUrl": "/in-depth/execution.html#libossia-execution"
  },"195": {
    "doc": "Device explorer",
    "title": "Device explorer",
    "content": "The device explorer (shortcut: Ctrl+Shift+D(Win / Linux) or⌘+Shift+D(Mac)) is where external devices and hardware can be interacted with and added to a score. ",
    "url": "https://ossia.io/score-docs/panels/explorer.html",
    "relUrl": "/panels/explorer.html"
  },"196": {
    "doc": "Math expressions",
    "title": "ExprTK support",
    "content": "Several processes allow to write simple math expressions. Such processes include: . | Micromap: for very simple math expressions, e.g. x * 100. | Expression Audio Generator: generates multi-channel audio. | Expression Audio Filter: filters multi-channel audio. | Expression Value Generator: generates values suitable for the device explorer. | Expression Value Filter: filters values suitable for the device explorer. | . These expressions are evaluated within score using the ExprTK library. The expression can be written in the process built-in editor on multiple lines. Numerous math functions are available: sin, cos, abs, log, as well as the usual pi, etc. constants. ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#exprtk-support",
    "relUrl": "/processes/exprtk.html#exprtk-support"
  },"197": {
    "doc": "Math expressions",
    "title": "Audio handling",
    "content": "For audio processes, the processing is done per-frame. The input x is an array, where x[0] is the first channel, x[1] the second channel, etc. Note that ExprTK has powerful array processing features; the following two codes implement the same distortion: . // This is the syntax to get the size of the array // e.g. the number of channels here: var n := x[]; for (var i := 0; i &lt; n; i += 1) { var dist := tan(x[i]*log(1 + 200 * a)); out[i] := clamp(-1, dist, 1); } . out := clamp(-1, tan(x * log(1 + 200 * a)), 1); . ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#audio-handling",
    "relUrl": "/processes/exprtk.html#audio-handling"
  },"198": {
    "doc": "Math expressions",
    "title": "Array handling",
    "content": "For value processes, the same expression syntax cannot be used for single-value or array input: . | Use x, px, po to write an expression that processes single values, e.g. a float input. | Use xv, pxv, pov to write an expression that processes arrays. | . For instance: . tanh(x + 1) . will process a single float as input, while: . return [ xv[0] cos(xv[1]), xv[0] sin(xv[1]) ]; . will take a vec2 that contains polar coordinates [r, theta] and convert it into cartesian coordinates [x, y]. ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#array-handling",
    "relUrl": "/processes/exprtk.html#array-handling"
  },"199": {
    "doc": "Math expressions",
    "title": "Available variables",
    "content": "Everywhere . | t: the current time | pos: the position in the interval | a, b, c: three provided controls | pa, pb, pc: previous value of a, b, c | m1, m2, m3: three provided variables (which will keep their value across a tick) . | In the audio cases they are arrays. | . | . Value mapping . | x: the value of the current input if it’s a single value | px: the value of the previous input if it was a single value | po: the value of the previous output if it was a single value | xv: the value of the current input if it’s an array | pxv: the value of the previous input if it was an array | pov: the value of the previous output if it was an array | dt: the time delta | . Audio mapping . | x: the value of the current sample | out: where to write the output | px: the value of the previous sample | fs: the sampling rate | . Value generator . | dt: the time delta | . Audio generator . | out: where to write the output | fs: the sampling rate | . ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#available-variables",
    "relUrl": "/processes/exprtk.html#available-variables"
  },"200": {
    "doc": "Math expressions",
    "title": "Available functions",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#available-functions",
    "relUrl": "/processes/exprtk.html#available-functions"
  },"201": {
    "doc": "Math expressions",
    "title": "ExprTK-provided functions:",
    "content": ". | Basic math: min, max, avg, sum, abs, ceil, floor, round, roundn, exp, log, log10, logn, pow, root, sqrt, clamp, inrange, swap | Trigonometry: sin, cos, tan, acos, asin, atan, atan2, cosh, cot, csc, sec, sinh, tanh, d2r, r2d, d2g, g2d, hyp | Numeric integration and differentiation | Vector Processing: BLAS-L1 (axpy, axpby, axpb), all/any-true/false, count, rotate-left/right, shift-left/right, sort, nth_element, iota, sum, kahan-sum, dot-product, copy | . ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#exprtk-provided-functions",
    "relUrl": "/processes/exprtk.html#exprtk-provided-functions"
  },"202": {
    "doc": "Math expressions",
    "title": "score-provided functions",
    "content": ". | random(min, max): returns a random real number in the given interval. | random(0, 1) can be 0., 0.3, 0.23455436, 1. | round(random(1, 20)) is a 20-sided dice with lower probabilities for 1, 20. | floor(random(1, 21)) is a 20-sided dice with same probabilities for everyone. | . | noise(t, octaves, persistence): Perlin noise. | t should be something that increases ; pos is generally a good candidate. | octaves: the higher this is, the more detailed the noise is. 2 would be smooth, 7 very detailed but more computationally intensive. Between 1 and 10. | persistence: how much each octave fades. 1: no fade, very noisy. 0: very smooth. | 5 * (noise(pos * 100, 4, 0.5) - 0.5) gives a convincing fairly dynamic noise between -1 and 1. | noise(pos * 10, 3, 0.1) gives a very smooth evolution between 0 and 1. | . | . ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#score-provided-functions",
    "relUrl": "/processes/exprtk.html#score-provided-functions"
  },"203": {
    "doc": "Math expressions",
    "title": "Examples",
    "content": "The user library comes with a few utility functions, be sure to check them in the preset pane ! . Contributing useful functions to the library is also very welcome. | Audio Filter | Audio Generator | Value Filter | Value Generator | Micromap | . ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#examples",
    "relUrl": "/processes/exprtk.html#examples"
  },"204": {
    "doc": "Math expressions",
    "title": "Value generator",
    "content": "Logistic function . Implemented as a preset (Logistic): . if(m1 == 0) { m2 := 0.8; m1 := 1; } var r := 4 * a; m2 := r * m2 * (1 - m2) . ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#value-generator-1",
    "relUrl": "/processes/exprtk.html#value-generator-1"
  },"205": {
    "doc": "Math expressions",
    "title": "Value mapper",
    "content": "Add noise . Implemented as a preset (Noisify): . var rnd_m := pow(2, 31); var rnd_a := 1103515245; var rnd_c := 12345; if(m2 == 0) { m2 := 1; m1 := 12345678; } var r := (rnd_a * m1 + rnd_c) % rnd_m; m1 := r; x + a * r / (2^33); . ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#value-mapper",
    "relUrl": "/processes/exprtk.html#value-mapper"
  },"206": {
    "doc": "Math expressions",
    "title": "Audio generator",
    "content": "Sine wave . Implemented as a preset (Sine): . var phi := 2 * pi * (20 + a * 500) / fs; m1[0] += phi; out[0] := b * cos(m1[0]); out[1] := b * cos(m1[0]); . Square wave . Implemented as a preset (Square): . var phi := 2 * pi * (20 + a * 500) / fs; m1[0] += phi; var f := cos(m1[0]) &gt; 0 ? b : -b; out[0] := f; out[1] := f; . Wobbly synth . Implemented as a preset (Wobbly): . var freq_l := 225 + cos(t/(100*(a+0.1))); freq_l := 2 * pi * m1[0] * freq_l * b / fs; var freq_r := 215 + sin(t/(100*(a+0.1))); freq_r := 2 * pi * m1[0] * freq_l * b / fs; m1[0] += 1; out[0] := b * cos( freq_l ); out[1] := b * cos( freq_r ); . ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#audio-generator-1",
    "relUrl": "/processes/exprtk.html#audio-generator-1"
  },"207": {
    "doc": "Math expressions",
    "title": "Audio filter",
    "content": "Crude distortion . 2-channel version: . out[0] := clamp(0, tan(x[0]*log(1 + 200 * a)), 1); out[1] := clamp(0, tan(x[1]*log(1 + 200 * a)), 1); . Any number of channel version: . var n := x[]; for (var i := 0; i &lt; n; i += 1) { var dist := tan(x[i]*log(1 + 200 * a)); out[i] := clamp(-1, dist, 1); } . ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#audio-filter",
    "relUrl": "/processes/exprtk.html#audio-filter"
  },"208": {
    "doc": "Math expressions",
    "title": "Math expressions",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html",
    "relUrl": "/processes/exprtk.html"
  },"209": {
    "doc": "FAQ",
    "title": "Frequently Asked Questions",
    "content": "Here is a list of (not necessarily) frequently asked questions. In case none of these answer yours, feel more than welcome to ask for help on the ossia.io forum or send a message on ossia score Gitter channel where you will most likely find a handful of score users and developers. ",
    "url": "https://ossia.io/score-docs/faq.html#frequently-asked-questions",
    "relUrl": "/faq.html#frequently-asked-questions"
  },"210": {
    "doc": "FAQ",
    "title": "FAQ",
    "content": " ",
    "url": "https://ossia.io/score-docs/faq.html",
    "relUrl": "/faq.html"
  },"211": {
    "doc": "Faust",
    "title": "Faust",
    "content": ". Faust is a domain-specific programming language, tailored for writing digital signal processing code, for instance audio effects and synthesizers, super easily. It is mainly developed at Grame, with an international community of contributors. Faust DSP files can be drag’n’dropped directly inside a score. This will compile the DSP and embed it as a signal processor in the score. Additionally, any .dsp file found recursively in the library folder will be detected and added under the Faust section in the process library. Faust code can be edited directly from within the user interface, by clicking on the small “window” icon on the node header. One must press “Compile” when the code is ready to update it to the audio engine. ",
    "url": "https://ossia.io/score-docs/processes/faust.html",
    "relUrl": "/processes/faust.html"
  },"212": {
    "doc": "Faust",
    "title": "Important links",
    "content": ". | Faust website &amp; docs | User library | . ",
    "url": "https://ossia.io/score-docs/processes/faust.html#important-links",
    "relUrl": "/processes/faust.html#important-links"
  },"213": {
    "doc": "Faust",
    "title": "Video tutorial",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/faust.html#video-tutorial",
    "relUrl": "/processes/faust.html#video-tutorial"
  },"214": {
    "doc": "Faust",
    "title": "Faust packages",
    "content": "It is possible to provide new Faust libraries as score packages. This is done for instance with Alain Bonardi’s abclib which is packaged here : most importantly, the library folder in such a package will be added to the Faust library path so that new functions can be provided. ",
    "url": "https://ossia.io/score-docs/processes/faust.html#faust-packages",
    "relUrl": "/processes/faust.html#faust-packages"
  },"215": {
    "doc": "Glossary",
    "title": "Glossary",
    "content": ". | Automation | Branch | Condition | Device | Device explorer | Graph inspector | Interval | Process | Processes explorer | Project folder | Protocol | Slot | State | Timeline | Trigger | User library | . Automation . Branch . Condition . Device . Devices are pieces of equipment you want to use with score in your creative project. These can be hardware (a Midi controller, a synthesizer) or software running locally or on the network. Device explorer . The device explorer is the left panel. This is where devices involved in your project can be set up, browsed or monitored. Graph inspector . The Graph inspector available in score’s top right panel allows to inspect a temporal object and its context. For example, select an interval on the scenario to list all attached processes. Interval . Some block of time in the scenario. Process . A process is an action used in the scenario to control some devices’ parameter or other processes’ parameters. score includes a number of processes such as breakpoint function-based automation, sub-scenarios, LFO or modulators or custom scripts. Processes explorer . The processes explorer is accessible at the left panel in score main window. This is where you can browse and select some processes to use in your scenario. Project folder . This is where you can browse the content of the current project. Protocol . Slot . State . Timeline . Trigger . User library . The User library can be accessed in the left panel in score main window. It can contains various uer defined components such as devices setups, processes, presets. ",
    "url": "https://ossia.io/score-docs/reference/glossary.html",
    "relUrl": "/reference/glossary.html"
  },"216": {
    "doc": "Gradient",
    "title": "Color automation",
    "content": ". This process allows to automate colors over time. ",
    "url": "https://ossia.io/score-docs/processes/gradient.html#color-automation",
    "relUrl": "/processes/gradient.html#color-automation"
  },"217": {
    "doc": "Gradient",
    "title": "Usage",
    "content": ". | Keypoints can be moved by dragging the vertical lines. | By pressing the little arrow at the top of each line, one can change the color. | Double-clicking adds a point. | Right-clicking removes a point. | . ",
    "url": "https://ossia.io/score-docs/processes/gradient.html#usage",
    "relUrl": "/processes/gradient.html#usage"
  },"218": {
    "doc": "Gradient",
    "title": "Gradient",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/gradient.html",
    "relUrl": "/processes/gradient.html"
  },"219": {
    "doc": "Graphics pipeline",
    "title": "Graphics pipeline",
    "content": "score uses Qt RHI as graphics abstraction for the video pipeline. It is able to use OpenGL ES 2.0, Vulkan, Metal, and Direct 3D 11 in a very efficient way. score shaders are written with the Interactive Shader Format specification. Video processes are combined into a dynamic render graph which is processed in a separate thread. Each process writes to a render target. ",
    "url": "https://ossia.io/score-docs/in-depth/video.html",
    "relUrl": "/in-depth/video.html"
  },"220": {
    "doc": "HTTP device",
    "title": "HTTP device",
    "content": ". Reference is not yet available. Feel more than welcome to ask for help on the ossia.io forum or send a message on ossia score Gitter channel where you will most likely find a handful of score users and developers. ",
    "url": "https://ossia.io/score-docs/devices/http-device.html",
    "relUrl": "/devices/http-device.html"
  },"221": {
    "doc": "Image process",
    "title": "Image Process",
    "content": ". This process displays an image in a viewport. Multiple image processes can display their images by outputting in a single port. ",
    "url": "https://ossia.io/score-docs/processes/image.html#image-process",
    "relUrl": "/processes/image.html#image-process"
  },"222": {
    "doc": "Image process",
    "title": "Creating the process",
    "content": "The process can be created simply by dropping an image or a set of images on the score, or on an interval. If multiple images are dropped, it will be possible to switch through those with the Index control. If those images are GIFs, then the index allows to sift through the gif’s frames. Here is an example of a simple score which loops over a set of images and applies a visual effect to the output, useful for VJ purposes: . ",
    "url": "https://ossia.io/score-docs/processes/image.html#creating-the-process",
    "relUrl": "/processes/image.html#creating-the-process"
  },"223": {
    "doc": "Image process",
    "title": "Image process",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/image.html",
    "relUrl": "/processes/image.html"
  },"224": {
    "doc": "In depth",
    "title": "Advanced features",
    "content": "This chapter describes various advanced use cases for ossia score, and explains how the software works. ",
    "url": "https://ossia.io/score-docs/in-depth#advanced-features",
    "relUrl": "/in-depth#advanced-features"
  },"225": {
    "doc": "In depth",
    "title": "In depth",
    "content": " ",
    "url": "https://ossia.io/score-docs/in-depth",
    "relUrl": "/in-depth"
  },"226": {
    "doc": "Home",
    "title": "Score documentation",
    "content": ". This is the documentation for ossia score 3.0.11. Browse by categories on the left, or if you are looking for a specific topic, check out the search bar at the top of the page. Disclaimer: the documentation is currently in-progress. If you spot a missing / incomplete / wrong information, or even just a spelling mistake, you can click the link at the bottom of the page which allows to submit a fix request to the documentation. In the meantime, feel more than welcome to ask for help on the ossia.io forum or send a message on the ossia score Gitter channel where you will most likely find a handful of score users and developers. You may also find some information watching the french video tutorials. ",
    "url": "https://ossia.io/score-docs/#score-documentation",
    "relUrl": "/#score-documentation"
  },"227": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "https://ossia.io/score-docs/",
    "relUrl": "/"
  },"228": {
    "doc": "Inspector",
    "title": "Inspector",
    "content": " ",
    "url": "https://ossia.io/score-docs/panels/inspector.html",
    "relUrl": "/panels/inspector.html"
  },"229": {
    "doc": "Interface overview",
    "title": "score interface overview",
    "content": "Score provides a unique window embedding all main features and toolboxes. From it, you can setup how your media applications and score will communicate, observe their parameters value navigate through their namespace in a structured way, store some parameters value in snapshots, draw some automations, structure you scenario in flexible ways and more. All can be done from one of the 3 UI areas described below. ",
    "url": "https://ossia.io/score-docs/quick-start/interface-overview.html#score-interface-overview",
    "relUrl": "/quick-start/interface-overview.html#score-interface-overview"
  },"230": {
    "doc": "Interface overview",
    "title": "Explorer panel",
    "content": "On the left of score main window is the Explorer panel. This is where you can browse and manage the various contents needed for your project. It comprises 4 main sections that can be switched using the icon at the bottom: . | Device explorer: This is where you can setup the devices (hardware or software devices on the network) you want to control from score. The Device explorer also offers a way to monitor or browse devices involved in your project, inspect its parameters and their behavior. This also is where you can grab parameters you want to save in a snapshot, write automations on as explained in the following pages. | Processes explorer: This is where you can browse and select some processes to use in your scenario to control various parameters of your devices or other processes. | User library explorer. This is where you can access some user defined assets. These can be devices setups, presets, processes collections amongst other things. | Project folder: This is where you can browse the content of the current project. | . ",
    "url": "https://ossia.io/score-docs/quick-start/interface-overview.html#explorer-panel",
    "relUrl": "/quick-start/interface-overview.html#explorer-panel"
  },"231": {
    "doc": "Interface overview",
    "title": "Scenario editor",
    "content": "At the center of the score window is the scenario editor. This is where you can write and edit the various parts of your project’s flexible and interactive scenario. From there you can create some snapshots by dragging some parameters from the Device explorer at a particular time frame, create some automations by dragging parameters from the Device explorer on an interval, drop some audio or video medias from your hard drive to integrate them in your scenario. ",
    "url": "https://ossia.io/score-docs/quick-start/interface-overview.html#scenario-editor",
    "relUrl": "/quick-start/interface-overview.html#scenario-editor"
  },"232": {
    "doc": "Interface overview",
    "title": "Zooming and dezooming",
    "content": "It is possible to zoom the main score horizontally and vertically. | Horizontal zoom: Ctrl+Mouse Up/Down(Win / Linux) or⌘+Mouse Up/Down(Mac) | Vertical zoom: Shift+Mouse Up/Down | . Note that it is also possible to zoom the entire UI of the software through the Score preferences. ",
    "url": "https://ossia.io/score-docs/quick-start/interface-overview.html#zooming-and-dezooming",
    "relUrl": "/quick-start/interface-overview.html#zooming-and-dezooming"
  },"233": {
    "doc": "Interface overview",
    "title": "Objects inspector panel",
    "content": "On the right part of score main window is the Object inspector. It allows to dynamically inspect and setup the selected objects in the scenario. | Top part of the inspector is the structural context of the selected object. For example, the parent interval a process is attached to, the time point a state is placed on and its linked states, etc. | Bottom part are the various parameters of the selected object in the scenario: start time, duration and parameter address of an automation, source and target addresses of a mapping, its domain ranges, etc. | . ",
    "url": "https://ossia.io/score-docs/quick-start/interface-overview.html#objects-inspector-panel",
    "relUrl": "/quick-start/interface-overview.html#objects-inspector-panel"
  },"234": {
    "doc": "Interface overview",
    "title": "UI controls",
    "content": ". | Use right-click to edit controls precisely. | Many controls are available: sliders, color choosers, toggles… . | . ",
    "url": "https://ossia.io/score-docs/quick-start/interface-overview.html#ui-controls",
    "relUrl": "/quick-start/interface-overview.html#ui-controls"
  },"235": {
    "doc": "Interface overview",
    "title": "Interface overview",
    "content": " ",
    "url": "https://ossia.io/score-docs/quick-start/interface-overview.html",
    "relUrl": "/quick-start/interface-overview.html"
  },"236": {
    "doc": "Javascript",
    "title": "Javascript support",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#javascript-support",
    "relUrl": "/processes/javascript.html#javascript-support"
  },"237": {
    "doc": "Javascript",
    "title": "Scripting in Javascript / QML.",
    "content": "score allows to write scripts using the JavaScript language. These scripts can be used to write specific processes such as value mappers, audio generators. score uses JavaScript version ES7. See the JavaScript reference for more information about the JS language. It also uses QML (property real, etc.). See the QML Reference for more information. Either code directly or a path to the file can be added to the Javascript code editor - if it’s a file it will be watched for changes. JS can be used as a process both for intervals, and in states. | To add a JS process to an interval, simply drag’n’drop it from the Process Library to the interval. | To add a JS process to a state, right-click on the state in the Object Explorer, and choose “Add Process”. | . ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#scripting-in-javascript--qml",
    "relUrl": "/processes/javascript.html#scripting-in-javascript--qml"
  },"238": {
    "doc": "Javascript",
    "title": "Editing code",
    "content": "An important thing to note is that the edited script will not be saved in the scenario if there are compilation errors. This is a known issue and likely to change. ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#editing-code",
    "relUrl": "/processes/javascript.html#editing-code"
  },"239": {
    "doc": "Javascript",
    "title": "General syntax",
    "content": "Every script must contain . import Score 1.0 . somewhere at the top. A script defines a javascript object, with : . | Input and output ports | Callbacks that are called either regularly on every tick, or on special events (start, stop, pause, resume). | . The smallest valid empty script looks like this: . import Score 1.0 Script { tick: function(token, state) { } } . The tick function’s two arguments give both timing and contextual information useful for writing algorithms. Please read the Timing page to understand the timing concepts used in ossia score, in particular how model, physical and musical dates relate to each other. Available functions . For now, only a very simple API to read / write messages from the device explorer is provided: . // Reads the current value of an address in the device explorer let value = Device.read(\"an:/address\"); // Sends a value to the device explorer Device.write(\"an:/address\", 123); . Token object . Important note: due to the way numbers work in Javascript (that is, double-precision floating point numbers), and due to the timing units, scripts can only be expected to be accurate for representing durations no greater than 147 days. That is, if a time interval lasts a year, after 147 days the timing values returned by prev_date, date, … may not be accurate anymore. This limit is pushed back to the hard limit of 414 years when using the C++ integer-based API instead. Note that this does not affect for instance, scores with normal durations which would loop back to the beginning - permanently running installations are safe. Properties . | previous_date: the model date at which the tick starts. | date: the model date at which the tick ends | parent_duration: the nominal model duration of the closest parent interval. | offset: the model date at which we must start reading from our input. | speed: current speed (a multiplicative factor). | tempo: current tempo. | musical_start_last_signature: what is the position in quarter notes of the closest previous musical signature change to previous_date. | musical_start_last_bar: what is the position in quarter notes of the closest previous bar change to previous_date. | musical_start_position: what is the position of previous_date in quarter notes. | musical_end_last_bar: what is the position in quarter notes of the closest previous musical signature change to date. | musical_end_position: what is the position of date in quarter notes. | signature_upper: 6 in “6/8”, at the start of the tick. | signature_lower: 8 in “6/8”, at the start of the tick. | . Methods . | logical_read_duration(): how long are we reading from the model data. | physical_start(ratio): at which sample in the output must we start to write. | physical_read_duration(ratio): how many samples are we reading from the input ports. | physical_write_duration(ratio): how many samples are we writing to the output ports. | to_physical_time_in_tick(time, ratio): convert a model time into a physical time. | from_physical_time_in_tick(time, ratio): convert a time in physical dates, to a time in model dates. | in_range(time): check that the model time given is indeed in the range of this tick. | position(): where are we in relation to our parent interval. 0 is the beginning, 1 is the nominal duration. If an interval has a greater max, or is infinite, this will go beyond 1. | forward(): is the time going forward in this tick (speed &gt; 0). | backward(): is the time going backward in this tick (speed &lt; 0). | paused(): is the time going anywhere in this tick (speed == 0). Note that there is a difference between setting the speed to zero, and pressing the “pause” button - in the first case, processes will still keep being executed, just with no duration. | get_quantification_date(quant): get a model date if there is a quantification date for the requested quantification in this tick. -1 is returned if there isn’t any. | get_physical_quantification_date(quant, ratio): get a physical date if there is a quantification date for the requested quantification in this tick. -1 is returned if there isn’t any. | . State object . The state object contains global properties relevant for the whole score execution. Properties . | sample_rate: explicit. | buffer_size: explicit. | model_to_physical: the ratio to pass to the token functions going from model to physical dates. | physical_to_model: the ratio to pass to the token functions going from physical to model dates. | physical_date: how many samples have elapsed since the score has started playing. | start_date_ns: the date in nanoseconds when the score started playing. | current_date_ns: the current date in nanoseconds. | timings(token): given the token object, this gives back a timings object, which has the following properties: . | start_sample: at which index is the first sample to write in an audio buffer. | length: how many samples must be written. | . | . timings is most of the time what you need ! . ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#general-syntax",
    "relUrl": "/processes/javascript.html#general-syntax"
  },"240": {
    "doc": "Javascript",
    "title": "Example of a value mapper",
    "content": "// Necessary for the Script object. // It is also possible to import QtQml 2.15 import Score 1.0 // Create our script object Script { // Define the inputs &amp; outputs - they are sub-objects of the script object ValueInlet { id: in1 } ValueOutlet { id: out1 } FloatSlider { id: slider; min: 10; max: 100; } // QML syntax for defining a floating-point constant readonly property real my_constant: 1.234 // This function is called on each tick. tick: function(token, state) { // has a message been received ? if (typeof in1.value !== 'undefined') { // print it in the console console.log(in1.value); // transform it with some math operations. var newValue = in1.value + slider.value * Math.random() + my_constant; // write it in the output out1.value = newValue; } } start: function() { console.log(\"I am called on start\"); } stop: function() { console.log(\"I am called on stop\"); } pause: function() { console.log(\"I am called on pause\"); } resume: function() { console.log(\"I am called on resume\"); } } . Note: it is also possible to access the list of messages with their precise timing, with values. ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#example-of-a-value-mapper",
    "relUrl": "/processes/javascript.html#example-of-a-value-mapper"
  },"241": {
    "doc": "Javascript",
    "title": "Example of an audio generator",
    "content": "import Score 1.0 Script { // Declare our inputs &amp; outputs FloatSlider { id: in1; min: 20; max: 800; init: 440; objectName: \"Frequency\" } AudioOutlet { id: out1 } // Index to keep track of the phase property real phase: 0; tick: function(token, state) { // Create an array to store our samples let arr = new Array(state.buffer_size); for (let i = 0; i &lt; state.buffer_size; ++i) arr[i] = 0; // How many samples we must write in this array // (the process could run for e.g. only frame 17 through 24 in a 128-frame buffer) const tm = state.timings(token); if(tm.length &gt; 0) { // Computer the sin() coefficient var freq = in1.value; // Notice how we get sample_rate from state. var phi = 2 * Math.PI * freq / state.sample_rate; // Fill our array for(var s = 0; s &lt; n; s++) { phase += phi; var sample = Math.sin(phase); sample = freq &gt; 0 ? sample : 0; arr[tm.start_sample + s] = 0.3 * sample; } } // Write two audio channels, which will give stereo output by default in score. out1.setChannel(0, arr); out1.setChannel(1, arr); } } . ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#example-of-an-audio-generator",
    "relUrl": "/processes/javascript.html#example-of-an-audio-generator"
  },"242": {
    "doc": "Javascript",
    "title": "Example of a MIDI transposer",
    "content": "See the user library: Presets/JS/transpose.qml . ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#example-of-a-midi-transposer",
    "relUrl": "/processes/javascript.html#example-of-a-midi-transposer"
  },"243": {
    "doc": "Javascript",
    "title": "Port types",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#port-types",
    "relUrl": "/processes/javascript.html#port-types"
  },"244": {
    "doc": "Javascript",
    "title": "Properties common to all ports",
    "content": "FloatSlider { id: myVariableName // &lt;- how you refer to it in the javascript Code objectName: \"The name shown in the score UI\" address: \"foo:/bar/baz\" // &lt;- default address used when the object is created } . ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#properties-common-to-all-ports",
    "relUrl": "/processes/javascript.html#properties-common-to-all-ports"
  },"245": {
    "doc": "Javascript",
    "title": "Audio",
    "content": "Create an audio input: . AudioInlet { id: in } ... var left = in.channel(0); var right = in.channel(1); console.log(left[0]); // print the first sample of the first channel for (var value in left) { ... } . Create an audio output: . AudioOutlet { id: out } ... // set the data of channel 0 to the following: out.setChannel(0, [0.1, 0.0, 0.2, 0.0, -0.1, 0.0]); . ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#audio",
    "relUrl": "/processes/javascript.html#audio"
  },"246": {
    "doc": "Javascript",
    "title": "Example of fetching various timings",
    "content": "This example shows how one can access both score-relative and global-time-relative timing information from a JS script. import Score 1.0 Script { ValueInlet { id: in1 } ValueOutlet { id: out1; objectName: \"logical\" } ValueOutlet { id: out2; objectName: \"physical\" } property int samples_since_beginning: 0 tick: function(token, state) { // Logical time: this time is affected // by the speed sliders in score. // The unit is the Flick. out1.value = token.date; // Logical time in seconds: out1.value = token.date / 705600000; // Physical time: the time in real-world clock since the interval started playing. // The physical time unit is the audio sample. samples_since_beginning += state.buffer_size; out2.value = samples_since_beginning; // Physical time in seconds: out2.value = samples_since_beginning / state.sample_rate; } } . ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#example-of-fetching-various-timings",
    "relUrl": "/processes/javascript.html#example-of-fetching-various-timings"
  },"247": {
    "doc": "Javascript",
    "title": "MIDI",
    "content": "Create a MIDI input: . MidiInlet { id: in } ... var messages = in.messages(); for (var message in messages) { // Print the MIDI bytes console.log(message[0], message[1], message[2]); } . Create a MIDI output: . MidiOutlet { id: out } ... // push a new message out.add([144, 64, 127]); // set &amp; replace all the messages to be pushed out.setMessages([ [144, 64, 127], [144, 68, 127], [127, 30, 0] ]); . ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#midi",
    "relUrl": "/processes/javascript.html#midi"
  },"248": {
    "doc": "Javascript",
    "title": "Messages",
    "content": "Receiving: . ValueInlet { id: in } ... // Print the latest message received console.log(in.value()); // Iterate through all the messages received for this tick, with their timestamp for (var message in in.values) { console.log(message.timestamp, message.value); } . Sending: . ValueOutlet { id: out } ... // Use either out.setValue(1.234); // or out.addValue(timestamp, 1.234); . ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#messages",
    "relUrl": "/processes/javascript.html#messages"
  },"249": {
    "doc": "Javascript",
    "title": "Controls",
    "content": "Controls behave exactly like ValueInlet but show up as actual UI controls. They have as such relevant properties: min, max, etc. FloatSlider { min: 0.0 max: 1.0 init: 0.5 } . IntSlider { min: 0 max: 127 init: 0 } . Enum { choices: [\"foo\", \"bar\", \"baz\"] index: 2 } . Toggle { checked: true } . LineEdit { text: \"Hello world\" } . ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#controls",
    "relUrl": "/processes/javascript.html#controls"
  },"250": {
    "doc": "Javascript",
    "title": "Javascript",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/javascript.html",
    "relUrl": "/processes/javascript.html"
  },"251": {
    "doc": "Joystick device",
    "title": "Joystick device",
    "content": ". Reference is not yet available. Feel more than welcome to ask for help on the ossia.io forum or send a message on ossia score Gitter channel where you will most likely find a handful of score users and developers. ",
    "url": "https://ossia.io/score-docs/devices/joystick-device.html",
    "relUrl": "/devices/joystick-device.html"
  },"252": {
    "doc": "LFO",
    "title": "LFO",
    "content": ". You can use the Low Frequency Oscillator in order to generate a value. This value can be used later to control other parameters. ",
    "url": "https://ossia.io/score-docs/processes/lfo.html",
    "relUrl": "/processes/lfo.html"
  },"253": {
    "doc": "LFO",
    "title": "Frequency",
    "content": "You can change the value between 0.10 and 100 Hz. ",
    "url": "https://ossia.io/score-docs/processes/lfo.html#frequency",
    "relUrl": "/processes/lfo.html#frequency"
  },"254": {
    "doc": "LFO",
    "title": "Wave Shape",
    "content": "There are 8 different wafeforms available : sinusoidal, triangle, saw, square, sample &amp; hold and 3 noise form. ",
    "url": "https://ossia.io/score-docs/processes/lfo.html#wave-shape",
    "relUrl": "/processes/lfo.html#wave-shape"
  },"255": {
    "doc": "LFO",
    "title": "Range",
    "content": "This value can take values between 0 and 1000. ",
    "url": "https://ossia.io/score-docs/processes/lfo.html#range",
    "relUrl": "/processes/lfo.html#range"
  },"256": {
    "doc": "LFO",
    "title": "Offset",
    "content": "The offset value is between -1000 and 1000. ",
    "url": "https://ossia.io/score-docs/processes/lfo.html#offset",
    "relUrl": "/processes/lfo.html#offset"
  },"257": {
    "doc": "LFO",
    "title": "Jitter",
    "content": "Allows to add some amount of noise to the signal. ",
    "url": "https://ossia.io/score-docs/processes/lfo.html#jitter",
    "relUrl": "/processes/lfo.html#jitter"
  },"258": {
    "doc": "LFO",
    "title": "Phase",
    "content": "Allows to alter the phase of the signal. ",
    "url": "https://ossia.io/score-docs/processes/lfo.html#phase",
    "relUrl": "/processes/lfo.html#phase"
  },"259": {
    "doc": "Library",
    "title": "Library",
    "content": "The library is split across multiple panels: . | The Process library: Ctrl+Shift+P(Win / Linux) or⌘+Shift+P(Mac) | The system library: Ctrl+Shift+B(Win / Linux) or⌘+Shift+B(Mac) | The project library: Ctrl+Shift+L(Win / Linux) or⌘+Shift+L(Mac) | . ",
    "url": "https://ossia.io/score-docs/panels/library.html",
    "relUrl": "/panels/library.html"
  },"260": {
    "doc": "Library",
    "title": "Process library",
    "content": "This pane shows the processes available to add to the score: automations, audio effects, etc. Everything is there ! . The top part shows the list of available processes, grouped by category. Processes there can be dragged to the score. The middle part shows available presets for the selected processes. Presets can also be dragged to the score. The bottom part shows information on the selected process. Fast creation of effect chains . To allow easy experimentation, double-clicking on a process or preset will add it and connect it, if possible, to the currently selected process in the score, or to the currently selected port if a port is selected. If nothing is selected, the process will be added to the currently displayed interval. Note: that means that by default, if nothing is selected, the processes may go at the bottom slot and won’t be visible without scrolling to the bottom of the score. ",
    "url": "https://ossia.io/score-docs/panels/library.html#process-library",
    "relUrl": "/panels/library.html#process-library"
  },"261": {
    "doc": "Library",
    "title": "System library",
    "content": "This pane displays content shared across all scores. By default, it will be in &lt;Documents&gt;/ossia/score/packages . The location can be changed in the settings. The User Library which contains pre-existing presets will be downloaded on first launch. Please contribute to it! . Packages installed through the package manager will also go there. Various actions are possible: . | Dragging and dropping one or multiple files to the score. | Double-clicking on files. For instance, double-clicking on a .score will open it. | Right-click allows to open a folder in the system file explorer. | Dragging and dropping processes from the score: one can save a preset at a specific place by dragging from the folder preset icon. | . Here is an example of saving and loading a whole score as a preset, to embed it recursively in itself. Important folders in the default library . | Skins: contains skins which can be changed in the settings. The currently provided screens are adaptations for various colour-blindness schemes. | Util/metro_tick.wav and Util/metro_tock.wav: replace these if you want to change the sound of the metronome. | . ",
    "url": "https://ossia.io/score-docs/panels/library.html#system-library",
    "relUrl": "/panels/library.html#system-library"
  },"262": {
    "doc": "Library",
    "title": "Project library",
    "content": "This pane displays the content of the current project folder: this is simply the folder in which the edited score is saved. Otherwise, it behaves exactly like the system library. ",
    "url": "https://ossia.io/score-docs/panels/library.html#project-library",
    "relUrl": "/panels/library.html#project-library"
  },"263": {
    "doc": "Library",
    "title": "Preview",
    "content": "For now, sound files are previewed when clicking on them ; playback can be started and stopped with the little play / stop button at the bottom-left. ",
    "url": "https://ossia.io/score-docs/panels/library.html#preview",
    "relUrl": "/panels/library.html#preview"
  },"264": {
    "doc": "Local device",
    "title": "Using score OSCQuery device",
    "content": "score exposes its scenario execution parameters through OSCQuery protocol so they can be monitored and controlled locally or from any device on the network. For example, using score’s own Device explorer, you will see when browsing available OSCQuery devices the score application and its address and port. Exposed parameters include: . | ‘exit’: close current scenario | ‘global_play’: play score’s current scenario | ‘play’: play score’s current scenario | ‘reconnect’: reconnect a device | ‘reinit’: stop score execution and recall init state | ‘running’: report whether score is playing | ‘stop’: stop scenario execution | ‘transport’: set scenario main playhead at a particular point (in ms.) | . Below is a simple Max patcher provided in ossia-max package illustrating remote control of score’s transport. ",
    "url": "https://ossia.io/score-docs/devices/local-device.html#using-score-oscquery-device",
    "relUrl": "/devices/local-device.html#using-score-oscquery-device"
  },"265": {
    "doc": "Local device",
    "title": "More parameters in the local tree",
    "content": "In the Score preferences of the software, it is possible to enable the extended tree. This tree will create nodes for every interval, process, etc. This means that it will become possible to control any parameter in your score from OSC / OSCQuery. ",
    "url": "https://ossia.io/score-docs/devices/local-device.html#more-parameters-in-the-local-tree",
    "relUrl": "/devices/local-device.html#more-parameters-in-the-local-tree"
  },"266": {
    "doc": "Local device",
    "title": "Local device",
    "content": "While score can synchronise and automate your media softwares and hardware, it can also be remote-controlled, should you need to control your scenario execution using some hyper advanced next generation IA software, a custom sensor interface or whatever fits your needs. ",
    "url": "https://ossia.io/score-docs/devices/local-device.html",
    "relUrl": "/devices/local-device.html"
  },"267": {
    "doc": "Mapper device",
    "title": "Mapper device",
    "content": "The mapper device allows mapping the parameters between devices directly. It will operate permanently, even when the score is not running. Like other devices such as Serial, HTTP and WebSockets, it is defined in Javascript within a QML script. The basic form is: . import Ossia 1.0 as Ossia Ossia.Mapper { function createTree() { return [ { name: \"node\", children: [ { name: \"sensor\" } ] } ] } } . This does nothing interesting and only creates a tree with a single address: Mapper:/node/sensor . ",
    "url": "https://ossia.io/score-docs/devices/mapper-device.html#mapper-device",
    "relUrl": "/devices/mapper-device.html#mapper-device"
  },"268": {
    "doc": "Mapper device",
    "title": "Mapping a node of the mapper to another",
    "content": "This is useful to give for instance an user-readable name to another parameter. For instance, to give a name to a specific MIDI CC: . import Ossia 1.0 as Ossia Ossia.Mapper { function createTree() { return [ { name: \"node\", children: [ { name: \"sensor\", bind: \"MidiDevice:/1/control/45\", type: Ossia.Type.Int } ] } ] } } . Which gives: . The mapping is bidirectional: . | When MidiDevice:/1/control/45 receives a message, it is written to Mapper:/node/sensor | When Mapper:/node/sensor receives a message, it is written to MidiDevice:/1/control/45 | . ",
    "url": "https://ossia.io/score-docs/devices/mapper-device.html#mapping-a-node-of-the-mapper-to-another",
    "relUrl": "/devices/mapper-device.html#mapping-a-node-of-the-mapper-to-another"
  },"269": {
    "doc": "Mapper device",
    "title": "Custom mappings with Javascript expressions",
    "content": "If one wants to transform the value, for instance to rescale it, it is possible to use small JS snippets: . import Ossia 1.0 as Ossia Ossia.Mapper { function createTree() { return [ { name: \"node\", children: [ { name: \"sensor\", bind: \"MidiDevice:/1/control/45\", type: Ossia.Type.Float, // What happens when the bound parameter (MidiDevice:/1/control/45) is written to: // // When MidiDevice:/1/control/45 receives the value 64, // Mapper:/node/sensor will get the value 64 / 127, roughly 0.5. read: function(orig, v) { return v.value / 127.; }, // What happens when the mapper parameter (Mapper:/node/sensor) is written to: // // When Mapper:/node/sensor receives the value 0.5, // MidiDevice:/1/control/45 will get the value 0.5 * 127, roughly 64. write: function(v) { return v.value * 127.; } } ] } ] } } . This example will scale the 0-127 integer values of the MIDI CC to 0-1 floating point values for the Mapper. Example: . ",
    "url": "https://ossia.io/score-docs/devices/mapper-device.html#custom-mappings-with-javascript-expressions",
    "relUrl": "/devices/mapper-device.html#custom-mappings-with-javascript-expressions"
  },"270": {
    "doc": "Mapper device",
    "title": "Binding to multiple parameters",
    "content": "bind: can be an array. import Ossia 1.0 as Ossia Ossia.Mapper { function createTree() { return [ { name: \"node\", children: [ { name: \"sensor\", bind: [\"MidiDevice:/1/control/45\", \"MidiDevice:/1/control/55\"], type: Ossia.Type.Float, // The first parameter, `orig` is the OSC address of the parameter which // was changed: it will be either \"/1/control/45\" or \"/1/control/55\". // The second parameter is the value. read: function(orig, v) { return v.value / 127.; }, // Here we now return an array of values, one for each address: // for instance, if a message \"0.5\" is sent to Mapper:/node/sensor from within score, // - MidiDevice:/1/control/45 will get 0.5 * 127 // - MidiDevice:/1/control/55 will get 0 write: function(v) { return [v.value * 127., 0]; } } ] } ] } } . ",
    "url": "https://ossia.io/score-docs/devices/mapper-device.html#binding-to-multiple-parameters",
    "relUrl": "/devices/mapper-device.html#binding-to-multiple-parameters"
  },"271": {
    "doc": "Mapper device",
    "title": "Writing to arbitrary parameters",
    "content": "Sometimes one may want to map an address to another only known at run-time, depending on a message. For instance, imagine a case where you want to send messages [channel, value] to control varying MIDI channels at run-time, e.g. sending the list message [12, 45, 127] to Mapper:/node/sensor should write the CC value 127 to the CC 45 on MIDI channel 12, e.g. at the address MidiDevice:/12/control/45. This can be done by returning a list of address-value pairs from write: . [ { address: \"foo:/bar\", value: 123 }, etc... ] . In this case one must not set bind: or read: as they do not make sense: . Example: . import Ossia 1.0 as Ossia Ossia.Mapper { function createTree() { return [ { name: \"node\", children: [ { name: \"sensor\", type: Ossia.Type.List, // What happens when the mapper parameter (Mapper:/node/sensor) is written to write: (v) =&gt; { // If v is [12, 45, 127], this gives: // MidiDevice:/12/control/45 let addr = `MidiDevice:/${v.value[0].value}/control/${v.value[1].value}` return [ { address: addr, value : v.value[2].value } ]; } } ] } ] } } . ",
    "url": "https://ossia.io/score-docs/devices/mapper-device.html#writing-to-arbitrary-parameters",
    "relUrl": "/devices/mapper-device.html#writing-to-arbitrary-parameters"
  },"272": {
    "doc": "Mapper device",
    "title": "Mapping and combining values from multiple addresses",
    "content": "To do this, one can simply add a custom member to the QML object. For instance, here we combine two distinct addresses which represent an XY coordinate, in a single parameter of type Vec2. import Ossia 1.0 as Ossia Ossia.Mapper { // Our custom member which will contain the current value for the address. property var xy: [0.0, 0.0] function createTree() { return [ { name: \"node\", children: [ { name: \"sensor\", bind: [\"Millumin:/millumin/layer/x/instance\", \"Millumin:/millumin/layer/y/instance\"], type: Ossia.Type.Vec2f, read: function(orig, v) { // Assign to xy depending on the origin if(orig === \"/millumin/layer/x/instance\") xy[0] = v.value; if(orig === \"/millumin/layer/y/instance\") xy[1] = v.value; return xy; }, // Write to the correct addresses. \"v.value\" is a Vec2, so two floats directly write: (v) =&gt; { return [v.value[0], v.value[1]]; } } ] } ] } } . ",
    "url": "https://ossia.io/score-docs/devices/mapper-device.html#mapping-and-combining-values-from-multiple-addresses",
    "relUrl": "/devices/mapper-device.html#mapping-and-combining-values-from-multiple-addresses"
  },"273": {
    "doc": "Mapper device",
    "title": "Using the mapper device as a generator",
    "content": "The device provides an easy way to create generic generative devices with Javascript. Here is a simple example which creates a device which gives the time. The interval: property is used to define at which granularity in milliseconds the parameters will be polled. import Ossia 1.0 as Ossia Ossia.Mapper { function createTree() { return [ { name: \"hours\", type: Ossia.Type.Int, interval: 1000, // The read function() will be called every 1000 millisecond (every second) read: function() { return new Date().getHours(); } }, { name: \"minutes\", type: Ossia.Type.Int, interval: 1000, read: function() { return new Date().getMinutes(); } }, { name: \"seconds\", type: Ossia.Type.Int, interval: 200, read: function() { return new Date().getSeconds(); } } ]; } } . ",
    "url": "https://ossia.io/score-docs/devices/mapper-device.html#using-the-mapper-device-as-a-generator",
    "relUrl": "/devices/mapper-device.html#using-the-mapper-device-as-a-generator"
  },"274": {
    "doc": "Mapper device",
    "title": "Mapper device",
    "content": ". ",
    "url": "https://ossia.io/score-docs/devices/mapper-device.html",
    "relUrl": "/devices/mapper-device.html"
  },"275": {
    "doc": "Mapping (float)",
    "title": "Mapping (float)",
    "content": ". This process allows to map a float value to another, by following a transfer curve. The inspector allows to choose the expected range for input and output values. ",
    "url": "https://ossia.io/score-docs/processes/mapping.html",
    "relUrl": "/processes/mapping.html"
  },"276": {
    "doc": "Mapping (float)",
    "title": "Example",
    "content": "Consider the following setup: . When a value gets into the mapping input, it is mapped as if it was a value of the horizontal axis of the diagram, where 0 is the left and 1 is at the right, to the value of the curve being drawn, where the bottom of the process is at -100 and the top of the process is at 100. Here are a table of some of the (approximative) outputs for various inputs in the above case: . | input = 0 =&gt; output = -100 | input = 0.1 =&gt; output = -50 | input = 0.2 =&gt; output = 0 | input = 0.3 =&gt; output = 0 | input = 0.4 =&gt; output = 0 | input = 0.5 =&gt; output = 1 | … | input = 0.8 =&gt; output = 10 | input = 0.9 =&gt; output = 50 | input = 1.0 =&gt; output = 100 | . ",
    "url": "https://ossia.io/score-docs/processes/mapping.html#example",
    "relUrl": "/processes/mapping.html#example"
  },"277": {
    "doc": "Media management",
    "title": "Media management",
    "content": " ",
    "url": "https://ossia.io/score-docs/in-depth/media.html",
    "relUrl": "/in-depth/media.html"
  },"278": {
    "doc": "Media management",
    "title": "Paths to media",
    "content": "If the path is relative, it will look in the project folder first. The project folder is the folder which contains the saved .score file. ",
    "url": "https://ossia.io/score-docs/in-depth/media.html#paths-to-media",
    "relUrl": "/in-depth/media.html#paths-to-media"
  },"279": {
    "doc": "MIDI utilities",
    "title": "MIDI utilities",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/midi-utilities.html",
    "relUrl": "/processes/midi-utilities.html"
  },"280": {
    "doc": "MIDI utilities",
    "title": "Arpeggiator",
    "content": ". The classic arpeggiator effect. Play a chord on your keyboard and let the process create new notes from it. The currently implemented modes are: . | Forward: plays the notes in order (1-2-3-1-2-3) | Backwards: plays the notes in reverse order (3-2-1-3-2-1) | F-&gt;B: first forward then backwards (1-2-3-3-2-1) | B-&gt;F: first backwards then forward (3-2-1-1-2-3) | Chord: repeats the chord currently being held | . ",
    "url": "https://ossia.io/score-docs/processes/midi-utilities.html#arpeggiator",
    "relUrl": "/processes/midi-utilities.html#arpeggiator"
  },"281": {
    "doc": "MIDI utilities",
    "title": "Chord",
    "content": ". This process transforms an input note into a chord. For instance, if “Major” is selected: C3 -&gt; C3 E3 G3 . ",
    "url": "https://ossia.io/score-docs/processes/midi-utilities.html#chord",
    "relUrl": "/processes/midi-utilities.html#chord"
  },"282": {
    "doc": "MIDI utilities",
    "title": "MIDI scale",
    "content": ". This process allows to transpose and make the input MIDI fit into predetermined scales, to prevent wrong notes for instance. ",
    "url": "https://ossia.io/score-docs/processes/midi-utilities.html#midi-scale",
    "relUrl": "/processes/midi-utilities.html#midi-scale"
  },"283": {
    "doc": "MIDI utilities",
    "title": "Quantifier",
    "content": ". This process quantifies input MIDI onto the musical grid. ",
    "url": "https://ossia.io/score-docs/processes/midi-utilities.html#quantifier",
    "relUrl": "/processes/midi-utilities.html#quantifier"
  },"284": {
    "doc": "MIDI utilities",
    "title": "MIDI pitch",
    "content": ". This process allows to extract the pitch of a MIDI note as a simple value. ",
    "url": "https://ossia.io/score-docs/processes/midi-utilities.html#midi-pitch",
    "relUrl": "/processes/midi-utilities.html#midi-pitch"
  },"285": {
    "doc": "MIDI utilities",
    "title": "Pulse to note",
    "content": ". This process allows to convert input signals into MIDI. | If the input is of type impulse, then the default velocity and default pitch are used. | If the input is of type int, then it is used as pitch and the velocity is set with the default velocity. | If the input is of type vec2, then the first element is the pitch, the second is the velocity. | . ",
    "url": "https://ossia.io/score-docs/processes/midi-utilities.html#pulse-to-note",
    "relUrl": "/processes/midi-utilities.html#pulse-to-note"
  },"286": {
    "doc": "MIDI utilities",
    "title": "Example: using the step sequencer to drive MIDI inputs",
    "content": ". ",
    "url": "https://ossia.io/score-docs/processes/midi-utilities.html#example-using-the-step-sequencer-to-drive-midi-inputs",
    "relUrl": "/processes/midi-utilities.html#example-using-the-step-sequencer-to-drive-midi-inputs"
  },"287": {
    "doc": "MIDI support",
    "title": "MIDI communication",
    "content": "MIDI communication is provided by two kind of devices, available from the Device explorer: . | MIDI input device can be used to plug a MIDI keyboard to score. | MIDI output device can be used to send MIDI data from score to an external sequencer. | . ",
    "url": "https://ossia.io/score-docs/in-depth/midi.html#midi-communication",
    "relUrl": "/in-depth/midi.html#midi-communication"
  },"288": {
    "doc": "MIDI support",
    "title": "MIDI processes",
    "content": "MIDI processes can write to a specific channel or directly to the root device through addresses. Simply drop either the MIDI node corresponding to the MIDI device, or the channel, to the port you want to connect to. The most important processes are: . | Piano roll | MIDI pattern sequencer | MIDI utilities | . ",
    "url": "https://ossia.io/score-docs/in-depth/midi.html#midi-processes",
    "relUrl": "/in-depth/midi.html#midi-processes"
  },"289": {
    "doc": "MIDI support",
    "title": "MIDI file support",
    "content": ". | The Piano roll process supports MIDI files. | . Simply drag’n’drop a MIDI file in the score, either on a scenario or on the interval, from the user library or from your file explorer ! . ",
    "url": "https://ossia.io/score-docs/in-depth/midi.html#midi-file-support",
    "relUrl": "/in-depth/midi.html#midi-file-support"
  },"290": {
    "doc": "MIDI support",
    "title": "MIDI processing",
    "content": ". | See MIDI utilities for a list of processes that can alter MIDI data: arpeggiator, etc. | You can write your custom MIDI processors, for instance with the Javascript or the C++ JIT process. | . ",
    "url": "https://ossia.io/score-docs/in-depth/midi.html#midi-processing",
    "relUrl": "/in-depth/midi.html#midi-processing"
  },"291": {
    "doc": "MIDI support",
    "title": "MIDI support",
    "content": " ",
    "url": "https://ossia.io/score-docs/in-depth/midi.html",
    "relUrl": "/in-depth/midi.html"
  },"292": {
    "doc": "MIDI input device",
    "title": "MIDI input device",
    "content": "To setup a device using Midi input, select Midi input in the Protocols column of the Add device window. In the Devices middle column, you can select your desired Midi input device. If you plugged in your Midi controller after launching score, you may need to restart score so your controller appears in the Devices column. Optionally, you can set a custom name (or use the default one). On platform that support it (macOS and Linux), you can create a virtual MIDI device. ",
    "url": "https://ossia.io/score-docs/devices/midiin-device.html",
    "relUrl": "/devices/midiin-device.html"
  },"293": {
    "doc": "MIDI input device",
    "title": "Create whole tree option",
    "content": "Under the name of your Midi input device, you can toggle on the Create whole tree option. This option will create all possible Midi messages as parameters of the device as illustrated below. Addresses in the namespace will be created using the following format: . &lt;device name&gt;/&lt;channel number&gt;/&lt;message type&gt;/message number&gt; . Should you want not to automatically create a whole Midi namespace (i.e. and use Midi learn instead), just leave the option unset. ",
    "url": "https://ossia.io/score-docs/devices/midiin-device.html#create-whole-tree-option",
    "relUrl": "/devices/midiin-device.html#create-whole-tree-option"
  },"294": {
    "doc": "MIDI input device",
    "title": "Use Midi learn",
    "content": "You can use the learn function to build your Midi input namespace with only the needed Midi message (rather than setting up the whole Midi namespace). To do so, once added the Midi device with the Create whole tree option off, in the Device explorer, right-click on your Midi input device name and select Learn from the contextual menu. This opens score Midi learn window. From then, score will monitor any incoming Midi message and store it under an address following the pattern mentioned above. When you are done sending the needed Midi message, click Done on the Midi learn window. All received Midi messages should now appear under your Midi input device name in the Device explorer. ",
    "url": "https://ossia.io/score-docs/devices/midiin-device.html#use-midi-learn",
    "relUrl": "/devices/midiin-device.html#use-midi-learn"
  },"295": {
    "doc": "MIDI output device",
    "title": "Midi output device",
    "content": "To setup a device using Midi output, select Midi output in the Protocols column of the Add device window. In the Devices middle column, you can select your desired Midi input device. If you plugged in your Midi device after launching score, you may need to restart score so your it appears in the Devices column. Optionally, you can set a custom name (or use the default one). On platform that support it (macOS and Linux), you can create a virtual MIDI device. ",
    "url": "https://ossia.io/score-docs/devices/midiout-device.html#midi-output-device",
    "relUrl": "/devices/midiout-device.html#midi-output-device"
  },"296": {
    "doc": "MIDI output device",
    "title": "MIDI output device",
    "content": " ",
    "url": "https://ossia.io/score-docs/devices/midiout-device.html",
    "relUrl": "/devices/midiout-device.html"
  },"297": {
    "doc": "Minuit device",
    "title": "Minuit device",
    "content": ". Reference is not yet available. Feel more than welcome to ask for help on the ossia.io forum or send a message on ossia score Gitter channel where you will most likely find a handful of score users and developers. ",
    "url": "https://ossia.io/score-docs/devices/minuit-device.html",
    "relUrl": "/devices/minuit-device.html"
  },"298": {
    "doc": "Mixer",
    "title": "Mixing busses",
    "content": "Intervals can become mixing busses for all their child process. To use that feature, mark an interval as a bus in its inspector. The Audio panel then allows to change its volume / pan. Things with more than 2 channels will be available once we figure a proper UI for it - designers welcome as the code already supports it ! . ",
    "url": "https://ossia.io/score-docs/panels/mixer.html#mixing-busses",
    "relUrl": "/panels/mixer.html#mixing-busses"
  },"299": {
    "doc": "Mixer",
    "title": "Mixing console",
    "content": " ",
    "url": "https://ossia.io/score-docs/panels/mixer.html#mixing-console",
    "relUrl": "/panels/mixer.html#mixing-console"
  },"300": {
    "doc": "Mixer",
    "title": "Audio in-out",
    "content": " ",
    "url": "https://ossia.io/score-docs/panels/mixer.html#audio-in-out",
    "relUrl": "/panels/mixer.html#audio-in-out"
  },"301": {
    "doc": "Mixer",
    "title": "Mixer",
    "content": " ",
    "url": "https://ossia.io/score-docs/panels/mixer.html",
    "relUrl": "/panels/mixer.html"
  },"302": {
    "doc": "Modular workflow",
    "title": "Modular workflow",
    "content": "ossia score is built upon an entirely modular foundation. At any point during edition, it is possible to switch from the temporal view, to the modular view, in order to patch processes together as easily as possible. The mode switching is operated by the buttons at the bottom of the software: . Some processes will always appear in patch view: audio effects, generators, and more generally any process for which the effect does not depend on time-relative data. Here is a small score viewed in temporal mode (the default): . Here is the same score viewed in modular mode: . It is also possible to disable the cables when the patching has been done and one wants to focus on the controls, the automations, etc: . This functionality is accessible through Alt+Shift+G. ",
    "url": "https://ossia.io/score-docs/in-depth/modular-workflow.html",
    "relUrl": "/in-depth/modular-workflow.html"
  },"303": {
    "doc": "How to monitor activity ?",
    "title": "How to monitor messages ?",
    "content": "With Logging option activated in score preferences, you can for example check messages coming in and out of a selected process in the Messages log panel (Ctrl+Shift+G(Win / Linux) or⌘+Shift+G(Mac)) . ",
    "url": "https://ossia.io/score-docs/faq/monitor-activity.html#how-to-monitor-messages-",
    "relUrl": "/faq/monitor-activity.html#how-to-monitor-messages-"
  },"304": {
    "doc": "How to monitor activity ?",
    "title": "How to monitor activity ?",
    "content": " ",
    "url": "https://ossia.io/score-docs/faq/monitor-activity.html",
    "relUrl": "/faq/monitor-activity.html"
  },"305": {
    "doc": "Musical metrics",
    "title": "Musical metrics",
    "content": "Processes and elements of a score can be quantized on musical metrics, and have independent tempo curves, &amp; time signatures. Musical metrics are propagated hierarchically: . | The tempo, and musical position in an interval is either relative to this interval (if the 4/4 button in the inspector is pressed) or it’s taking the musical information from its closest parent (recursively). | Processes take the quantization and metrics information from their parent. | . This means that polyrhythmic scores are possible: the root can be in 4/4 with a child interval in 3/4, 7/8. There are three “musical” controls available: time signatures, tempo curves, and quantization. ",
    "url": "https://ossia.io/score-docs/in-depth/musical.html",
    "relUrl": "/in-depth/musical.html"
  },"306": {
    "doc": "Musical metrics",
    "title": "Musical signatures",
    "content": "They are set on intervals and are used to delimit the start and end of bars, for quantization purposes. To change the musical signatures, go into an interval in full view and mark the interval as having its own metrics in the inspector if it does not already have some. ",
    "url": "https://ossia.io/score-docs/in-depth/musical.html#musical-signatures",
    "relUrl": "/in-depth/musical.html#musical-signatures"
  },"307": {
    "doc": "Musical metrics",
    "title": "Quantization",
    "content": "The quantization setting on an interval allows to say at which musical interval child elements will be triggered if they rely on hierarchy for synchronization. For instance, if the quantization setting is set at one bar, it means that the event will be processed at the start of the next bar. Most places that can be quantized thus have a choice of quantization intervals (bars, quarter notes, …), plus the Parent (uses the parent quantization setting, recursively) and Free (no quantization, things start directly) settings. ",
    "url": "https://ossia.io/score-docs/in-depth/musical.html#quantization",
    "relUrl": "/in-depth/musical.html#quantization"
  },"308": {
    "doc": "Musical metrics",
    "title": "Tempo",
    "content": "Likewise, by default the tempo is the global one. Intervals support tempo curves, which can give them a different speed behaviour. The interval’s children will all take this tempo unless another more precise tempo is given at a deeper nesting level by adding a tempo process to the interval. ",
    "url": "https://ossia.io/score-docs/in-depth/musical.html#tempo",
    "relUrl": "/in-depth/musical.html#tempo"
  },"309": {
    "doc": "Musical metrics",
    "title": "Usage",
    "content": ". | Processes which are able to use tempo &amp; metrics information (audio plug-ins, LFO, arpeggiator, etc) will do so automatically. | Triggers and intervals can be quantified to fall on the next quantification date from when they are triggered. | . ",
    "url": "https://ossia.io/score-docs/in-depth/musical.html#usage",
    "relUrl": "/in-depth/musical.html#usage"
  },"310": {
    "doc": "How to run score without GUI ?",
    "title": "How to run score without GUI ?",
    "content": "Score can run in the background while not opening its full UI (which may be handy for example when running score in a video installation). To do so, you can launch score from the Command line using the following: . $ ossia-score --no-gui --autoplay /home/oscar/my-score.score . You may find other useful commands in the command line reference page. ",
    "url": "https://ossia.io/score-docs/faq/nogui.html",
    "relUrl": "/faq/nogui.html"
  },"311": {
    "doc": "Non-linear timeline",
    "title": "Non-linear timeline",
    "content": "In previous example, we used trigger points to add variation during the execution of time-lined contents (device’s state recalling as well as automations) in the scenario. While trigger points bring flexibility in a timeline-based approach, things can be pushed a step further. You remember we noted in the Saving and recalling devices state page that score offers to connect dropped namespace selection to different preceding elements in the scenario. And score provides several ways to connect elements, one of them allowing to write and organize elements pretty much like you would do when designing a state machine. To learn about the various connections features, please refer to the in-depth topics as well as the reference manual to see how score engine works and the advanced authoring features it provides. In the scenario editor panel, you may create some elements by dragging a connection to a point in the timeline where you want to store a namespace state or start a process. This is where the create widget comes handy. In the illustration below, we can see that selecting a namespace state stored in the timeline brings the create widget: the yellow, blue and red crosses icons. We will focus here on the red one: it allows to escape the timeline constraint and automatically trigger elements attached to that connection. As seen above, clicking the red cross allows to drag a connection up to anywhere in the timeline. From there, we may adjust our device settings and drag a namespace selection from the Device explorer to store its state as seen earlier. What does happen here ? Well, we are starting to scratch the surface of score special strength. When playing our scenario, score will recall our parameters stored states and execute automations as the play-head runs through the timeline, just like we saw earlier. But when reaching the starting point of this dashed connection, the play-head will kind of jump to the connected elements and continue the reading as time regularly passes by. This might look weird coming from a timeline-based approach but is actually extremely useful. While score can help to author elements of precise duration and evolution over time using its timeline as a default grid, it also allows to author state machine-like scenarios by patching timed processes. ",
    "url": "https://ossia.io/score-docs/quick-start/non-linear-timelines.html",
    "relUrl": "/quick-start/non-linear-timelines.html"
  },"312": {
    "doc": "Non-linear timeline",
    "title": "From timeline-based scenario to state machine",
    "content": "This way of patching blocks of timed elements offers to construct your scenario in much more flexible ways that traditional DAW or timeline-based sequencers. As illustrated below, it allows to write scenarios running in loop for example as especially useful in interactive installations. In the simple scenario above, score will execute the scenario as an infinite loop alternating a simple fade in, then jumping to the fade-out automations then jump back to fade-in automations. Of course, you can still use some trigger points so the scenario waits before jumping to the next point. ",
    "url": "https://ossia.io/score-docs/quick-start/non-linear-timelines.html#from-timeline-based-scenario-to-state-machine",
    "relUrl": "/quick-start/non-linear-timelines.html#from-timeline-based-scenario-to-state-machine"
  },"313": {
    "doc": "OSC device",
    "title": "OSC device",
    "content": " ",
    "url": "https://ossia.io/score-docs/devices/osc-device.html",
    "relUrl": "/devices/osc-device.html"
  },"314": {
    "doc": "OSC device",
    "title": "Setting up communication with OSC device",
    "content": "Once opened a new score project, right-click in the Device explorer on the left of score window and choose Add device from the Device explorer contextual menu. This brings score’s device setup window. From the Protocols column, choose OSC and setup IP address your device is running on as well in &amp; out ports. You may also specify a name for your device. For the demo purpose here, we will use the default OSCdevice name. When done, the Device explorer pane should display our device top node. Note: Should you need to change settings of your OSC device, the setup panel can be brought back by choosing Edit in the device contextual menu. We can then setup our device’s OSC addresses we want to automate within score. ",
    "url": "https://ossia.io/score-docs/devices/osc-device.html#setting-up-communication-with-osc-device",
    "relUrl": "/devices/osc-device.html#setting-up-communication-with-osc-device"
  },"315": {
    "doc": "OSC device",
    "title": "Setting up OSC addresses",
    "content": "Using OSC learn . In the Device explorer pane, choose Learn in our device contextual menu. This opens up score’s OSC learning window. score will now monitor any OSC incoming value. For demo purpose here, we will use Vidvox’s handy OSC Test application. As soon as we send values to score from our OSC Test application, addresses get learned and displayed in the OSC learning window. When done, the Device explorer pane should display all learned OSC addresses. You can browse your device namespace, fold/unfold any node in the namespace hierarchy by clicking the arrow prepending each node. You can also see a parameter current value in your OSC device by selecting this parameter in score Device explorer and check its bottom section. Adding addresses manually . Should you need to setup your score project without having your OSC device opened, addresses can be added in the device explorer manually. Once having created an OSC device as explained above, choose Add child in the device contextual menu. As of score 3.0.0, each level of your parameter’s OSC address is to be declared separately. Assuming we want to add the address OSCdevice/track/1/volume, we first need to create the ‘track’ node. From the OSC editor window, type track in the Name text field and leave default type container (that is: a node in the namespace above other nodes or parameters). Then from the freshly created track node contextual menu, choose Add child to create a 1 node, then from this node, choose Add child again to create our volume parameter. For our volume parameter, we want to set the type as something else than container. For example, we will set up our parameter as a float value. You may also edits some of the parameter’s attributes as detailed in next step. ",
    "url": "https://ossia.io/score-docs/devices/osc-device.html#setting-up-osc-addresses",
    "relUrl": "/devices/osc-device.html#setting-up-osc-addresses"
  },"316": {
    "doc": "OSC device",
    "title": "Setting up parameters’ attributes",
    "content": "Once declared either using learn function or manually, parameter’s general behaviour can be further defined by setting up its various attributes. When selecting a parameter in the Device explorer pane, its attributes can be displayed and edited in the bottom section of the pane. A dedicated window can also be opened by choose Edit in the parameter contextual menu. For each value type, a number of attributes can be defined, such as: value domain (min. and max. value), clip mode (parameter handling of value exceeding its domain), repetition filter, etc. ",
    "url": "https://ossia.io/score-docs/devices/osc-device.html#setting-up-parameters-attributes",
    "relUrl": "/devices/osc-device.html#setting-up-parameters-attributes"
  },"317": {
    "doc": "OSC device",
    "title": "Saving OSC device for later use",
    "content": "When properly set up, your OSC device namespace can be exported and saved to disk for latter use. To do so, choose Export device in the device contextual menu. ",
    "url": "https://ossia.io/score-docs/devices/osc-device.html#saving-osc-device-for-later-use",
    "relUrl": "/devices/osc-device.html#saving-osc-device-for-later-use"
  },"318": {
    "doc": "OSCQuery device",
    "title": "OSCQuery device",
    "content": "score can communicate with devices using the OSCQuery protocol. ",
    "url": "https://ossia.io/score-docs/devices/oscquery-device.html",
    "relUrl": "/devices/oscquery-device.html"
  },"319": {
    "doc": "OSCQuery device",
    "title": "What is OSCQuery ?",
    "content": "As presented by Vidvox, the OSC Query Protocol is an agreed-upon specification that extends the base functionality of OSC to make it easier to construct impromptu or improvisational interfaces between different systems. The OSCQuery Protocol builds on top of OSC to provide a standardized way for systems to publish descriptions of their OSC Address Spaces in such a way that other environments can automatically interface with them with little or no setup. Within OSCQuery, a server is a host that provides a JSON data blob that describes the hierarchy of an OSC Address Space in a format that is both easy for humans and machine to interpret. Descriptions can include the type of data that is expected, the range of values that are accepted and other information about each container and method within the address space. Within OSCQuery, a client refers to a piece of software that browses and interacts with a remote server’s OSC address space. Read Vidvox’s detailed article to learn more about OSCQuery. ",
    "url": "https://ossia.io/score-docs/devices/oscquery-device.html#what-is-oscquery-",
    "relUrl": "/devices/oscquery-device.html#what-is-oscquery-"
  },"320": {
    "doc": "OSCQuery device",
    "title": "Adding OSCQuery device",
    "content": "Once opened a new score project, right-click in the Device explorer on the left of score window and choose Add device from the Device explorer contextual menu. This brings score’s device setup window. From the Protocols column, choose OSCQuery. You should see in the Devices column all OSCQuery compatibles devices available on the network. Select the desired one from the list and click Add. score will then query the selected device and receive its full namespace. All nodes and parameters of the device should now appear in the Device explorer. ",
    "url": "https://ossia.io/score-docs/devices/oscquery-device.html#adding-oscquery-device",
    "relUrl": "/devices/oscquery-device.html#adding-oscquery-device"
  },"321": {
    "doc": "Panels",
    "title": "Panels",
    "content": " ",
    "url": "https://ossia.io/score-docs/panels.html",
    "relUrl": "/panels.html"
  },"322": {
    "doc": "MIDI pattern sequencer",
    "title": "MIDI Pattern Sequencer",
    "content": ". A classic MIDI pattern sequencer. On the left of the sequencer, there is the actual note of the lane with a corresponding number. Each step correspond to a measure. If the step is activated (yellow), the note will be played. The note corresponding to each lane can be changed by clicking on it and dragging. This process can have multiple distinct patterns which can be switched. ",
    "url": "https://ossia.io/score-docs/processes/patternist.html#midi-pattern-sequencer",
    "relUrl": "/processes/patternist.html#midi-pattern-sequencer"
  },"323": {
    "doc": "MIDI pattern sequencer",
    "title": "Channel",
    "content": "On which MIDI channel the output goes. ",
    "url": "https://ossia.io/score-docs/processes/patternist.html#channel",
    "relUrl": "/processes/patternist.html#channel"
  },"324": {
    "doc": "MIDI pattern sequencer",
    "title": "Current Pattern",
    "content": "The index of the current pattern. ",
    "url": "https://ossia.io/score-docs/processes/patternist.html#current-pattern",
    "relUrl": "/processes/patternist.html#current-pattern"
  },"325": {
    "doc": "MIDI pattern sequencer",
    "title": "Lanes",
    "content": "Each lane corresponds to one MIDI note. ",
    "url": "https://ossia.io/score-docs/processes/patternist.html#lanes",
    "relUrl": "/processes/patternist.html#lanes"
  },"326": {
    "doc": "MIDI pattern sequencer",
    "title": "Step",
    "content": "How many steps there are in a pattern. The minimal amount of steps is 4 and the maximum is 32. ",
    "url": "https://ossia.io/score-docs/processes/patternist.html#step",
    "relUrl": "/processes/patternist.html#step"
  },"327": {
    "doc": "MIDI pattern sequencer",
    "title": "Rate",
    "content": "To which musical declination corresponds a step: quarter note, 16th note, etc. ",
    "url": "https://ossia.io/score-docs/processes/patternist.html#rate",
    "relUrl": "/processes/patternist.html#rate"
  },"328": {
    "doc": "MIDI pattern sequencer",
    "title": "MIDI pattern sequencer",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/patternist.html",
    "relUrl": "/processes/patternist.html"
  },"329": {
    "doc": "Piano roll",
    "title": "Piano roll",
    "content": ". The piano roll allows to output MIDI notes according to a score. MIDI files can be loaded by drag’n’drop, either on a scenario, interval, or on the piano roll process directly. Adding a note is done by double-clicking ; the note can be stretched with the mouse. When dropping a MIDI file, if Shift is held, the tracks are put in sequence instead of in parallel. Velocity of MIDI notes can now be changed with Shift+Click - the more saturated the note, the higher the velocity. ",
    "url": "https://ossia.io/score-docs/processes/piano-roll.html",
    "relUrl": "/processes/piano-roll.html"
  },"330": {
    "doc": "Plug-ins",
    "title": "Prerequisites",
    "content": "This guide assumes that a development environment with all required dependencies has been set-up. Check the “hacking on score” guide for more information on how to do that. ",
    "url": "https://ossia.io/score-docs/development/plug-ins.html#prerequisites",
    "relUrl": "/development/plug-ins.html#prerequisites"
  },"331": {
    "doc": "Plug-ins",
    "title": "Choosing the plug-in API to use",
    "content": "ossia score provides two plug-in APIs: . ",
    "url": "https://ossia.io/score-docs/development/plug-ins.html#choosing-the-plug-in-api-to-use",
    "relUrl": "/development/plug-ins.html#choosing-the-plug-in-api-to-use"
  },"332": {
    "doc": "Plug-ins",
    "title": "Fx API",
    "content": "A simple API that can be used to implement quick audio / midi / control effects and generators in a single file. Processes implemented with that API are available at the following address. To create a new plug-in, simply duplicate one of the files, change the metadata (name, UUID, etc. to differentiate it from other score plug-ins), and add it to the list in this file. When building score again, the plug-in should appear in the process list. A video explains the whole process: . ",
    "url": "https://ossia.io/score-docs/development/plug-ins.html#fx-api",
    "relUrl": "/development/plug-ins.html#fx-api"
  },"333": {
    "doc": "Plug-ins",
    "title": "Score API",
    "content": "A more advanced API that allows to customize pretty much every aspect of the software, but requires more work. The major part of the software is built with that API: every process in score comes from plug-ins. These plug-ins are located in the score git repository. The addon tutorial is an example of usage of the score API to showcase its capabilities. It is documented here. To develop new plug-ins that way, we provide a set of Github templates. Simply create a repository from the template, and follow the steps in the README. ",
    "url": "https://ossia.io/score-docs/development/plug-ins.html#score-api",
    "relUrl": "/development/plug-ins.html#score-api"
  },"334": {
    "doc": "Plug-ins",
    "title": "Plug-ins",
    "content": " ",
    "url": "https://ossia.io/score-docs/development/plug-ins.html",
    "relUrl": "/development/plug-ins.html"
  },"335": {
    "doc": "Score preferences",
    "title": "Audio",
    "content": "Audio settings allow to configure which sound card score is going to use for playback. If no sound is needed, it is possible to set the “Dummy” engine which won’t output sound. ",
    "url": "https://ossia.io/score-docs/reference/preferences.html#audio",
    "relUrl": "/reference/preferences.html#audio"
  },"336": {
    "doc": "Score preferences",
    "title": "Execution",
    "content": "Note that every execution settings change require stopping and restarting the playback of the current score. Enable listening during execution . This controls whether the Device Explorer panel updates its UI when the score is running. If there are thousands of parameters being updated all the time, monitoring them and updating the UI to show their new value can take some CPU usage which is not always required. Logging . When “Logging” is selected in the settings, if you click on the title of a process, then the Messages panel (Ctrl+Shift+G(Win / Linux) or⌘+Shift+G(Mac)) will show all the messages getting in and out of that process. Benchmark . When “Benchmark” is selected in the settings, the relative computation time of each process will be computed. This is useful for instance to find if there is a super intensive process taking too much CPU. Advanced execution settings . Parallel . Runs the processes on separate CPU cores as far as possible. Value compilation . When doing a “play from here”, this will try to guesstimate in which state the score should be at that point, by looking for the closest previous sent messages in the score and sending them to the devices. Transport value compilation . Same as value compilation, but redoes it every time you do a transport while the score is playing, with the “play” tool. ",
    "url": "https://ossia.io/score-docs/reference/preferences.html#execution",
    "relUrl": "/reference/preferences.html#execution"
  },"337": {
    "doc": "Score preferences",
    "title": "Score preferences",
    "content": " ",
    "url": "https://ossia.io/score-docs/reference/preferences.html",
    "relUrl": "/reference/preferences.html"
  },"338": {
    "doc": "Presets",
    "title": "Presets",
    "content": " ",
    "url": "https://ossia.io/score-docs/presets.html",
    "relUrl": "/presets.html"
  },"339": {
    "doc": "Presets",
    "title": "Process presets",
    "content": "Not available yet. ",
    "url": "https://ossia.io/score-docs/presets.html#process-presets",
    "relUrl": "/presets.html#process-presets"
  },"340": {
    "doc": "Presets",
    "title": "Scenario presets",
    "content": ". | Select a part of the score. | Drag it with Alt pressed into the user library, in some folder. | The selected part is now saved on the disk, in a .scenario file. | It can now be put in the score again by dragging it from the inspector. | . ",
    "url": "https://ossia.io/score-docs/presets.html#scenario-presets",
    "relUrl": "/presets.html#scenario-presets"
  },"341": {
    "doc": "Processes",
    "title": "Processes",
    "content": "score comes with a number of included processes. These cover various needs of action for advanced parameter control. This section of the manual covers the general usage of Processes as well a detailed documentation of each included Processes. ",
    "url": "https://ossia.io/score-docs/processes.html",
    "relUrl": "/processes.html"
  },"342": {
    "doc": "Processes",
    "title": "General description",
    "content": "score allows to handle a number of actions evolving either through some amount of time, or at a single instant. These processes can either be actions evolving during a given duration, such as automation of a given device’s parameter, or actions activated only in a defined duration, such as mapping or LFO modulations. Processes are attached to an interval in the scenario when they represent an evolving behaviour, and to a state when they are instantaneous. ",
    "url": "https://ossia.io/score-docs/processes.html#general-description",
    "relUrl": "/processes.html#general-description"
  },"343": {
    "doc": "Processes",
    "title": "Basics",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes.html#basics",
    "relUrl": "/processes.html#basics"
  },"344": {
    "doc": "Processes",
    "title": "Create processes on intervals",
    "content": "Using drag &amp; drop . From the Device explorer . Processes can be created by drag &amp; dropping parameters from the Device explorer onto an existing interval in the scenario. The interval to which processes will be attached turns to yellow as the mouse with selection hovers it. The Device explorer selection may contain one or several parameters. When multiple parameters are dropped, processes get stacked in different layers. From the libraries . Processes can also be created by drag &amp; dropping the desired process from the Process library or the User library in the scenario. When doing so, score automatically creates the interval to which process will get attached. You may as well drop a process onto an existing interval. Note that both namespace selection and processes selection can be dropped onto an interval to which some processes are already attached. Depending on the type of processes, these may be created on top of processes already in place or at a slot below. Audio, video and script files (Faust DSP, GLSL fragment shader, JS script…) can also be drag’n’dropped inside a scenario from your desktop’s file manager. By default, dropping several processes at the same time stacks them in the same interval. Holding the Maj key while dropping will create sequential intervals for each item in the selection. If a process is currently selected in the score, it is also possible to create a new process afterwards by double-clicking on it in the library. This will only work if the processes are compatible: the first output port of the selected process must be of the same type than the first input port of the process double-clicked in the library. A connection between the two ports will automatically be made. This allows to easily chain effects: . Likewise, if an output port is currently selected in the score, double-clicking on a process in the list will create and connect it afterwards if compatible. ",
    "url": "https://ossia.io/score-docs/processes.html#create-processes-on-intervals",
    "relUrl": "/processes.html#create-processes-on-intervals"
  },"345": {
    "doc": "Processes",
    "title": "Create processes on a state",
    "content": "Adding processes on a state is a way to run a computation at a single, precise point in the timeline. The processes will not be directly visible in the timeline ; the state has to be selected to edit their properties through the Inspector. It is done by right-clicking on the state in the object inspector, and selecting the Add process option. ",
    "url": "https://ossia.io/score-docs/processes.html#create-processes-on-a-state",
    "relUrl": "/processes.html#create-processes-on-a-state"
  },"346": {
    "doc": "Processes",
    "title": "Remove existing processes",
    "content": "Using keyboard . To remove a process, select it (for example by clicking on the slot background) and choose Remove from the Object menu (Suppr/Backspace key). Make sure the process you want to remove is properly selected when bringing it to front (for example, check the inspector) ! . From Graph inspector . Processes can also be deleted from the Graph inspector at the top of score’s right panel. In the scenario, select the interval the process to remove is attached to. In the Graph inspector, browse through the attached processes and select the one to remove. Right-click to open the contextual menu and choose Remove (or use Suppr/Backspace key). ",
    "url": "https://ossia.io/score-docs/processes.html#remove-existing-processes",
    "relUrl": "/processes.html#remove-existing-processes"
  },"347": {
    "doc": "Processes",
    "title": "Edit processes",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes.html#edit-processes",
    "relUrl": "/processes.html#edit-processes"
  },"348": {
    "doc": "Processes",
    "title": "Fullsize edit",
    "content": "Processes can be edited in full size. This is especially handy when you want to precisely edit a process such as an automation or mapping function. To display the process in full size, double-click on the interval the process is attached to. Process is now displayed using score central panel full width. Note that if several processes are attached to an interval, open them in full size will display all at once juxtaposed as shown below (see the Multiple processes interval). To exit full size mode (go back to parent scenario), click the desired node of the path displayed at the top or use the Ctrl+Alt+↑(Win / Linux) or⌘+Alt+↑(Mac) shortcut. ",
    "url": "https://ossia.io/score-docs/processes.html#fullsize-edit",
    "relUrl": "/processes.html#fullsize-edit"
  },"349": {
    "doc": "Processes",
    "title": "Process Loops",
    "content": "Time-based processes such as automations, media and sub-scenarios can be looped for as long as their parent interval is active. When selecting a process, either from the object panel or by clicking on process header, the loop option will appear in the Inspector. ",
    "url": "https://ossia.io/score-docs/processes.html#process-loops",
    "relUrl": "/processes.html#process-loops"
  },"350": {
    "doc": "Processes",
    "title": "Manage processes",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes.html#manage-processes",
    "relUrl": "/processes.html#manage-processes"
  },"351": {
    "doc": "Processes",
    "title": "Fold/unfold attached processes",
    "content": "Processes attached to an interval can easily be fold/unfold. This comes up especially usefull when working with a lot of processes while still maintaining some screen space and the scenario readable. To do so, click the blue arrow on top of the processes to fold/unfold. When selecting an interval, attached processes can also be fold/unfold using the Show processes &amp; Hide processes entries from the Object menu. ",
    "url": "https://ossia.io/score-docs/processes.html#foldunfold-attached-processes",
    "relUrl": "/processes.html#foldunfold-attached-processes"
  },"352": {
    "doc": "Processes",
    "title": "Stacked slots",
    "content": "Time-based processes (that is, processes whose x represents time, such as automations, media files) can be stacked on a same slot. This is the default presentation when dragging some parameters onto an interval or dragging a process from library onto an interval. In that case, top-most process is displayed in full color while processes in other layers or displayed in semi transparent color. You can of course re-arrange them as you want. Bring to front . To change which process to display top-most, mouse over to the top of the process slot displaying the destination address. Clicking the address bar opens up a contextual menu listing all layered processes. Selecting one in the menu brings it to front. Move to new slot . Processes can also be juxtaposed in several slots rather than stacked on top of the other. Grab the handle at the top left corner of the slot and drag &amp; drop it on another slot to move it above another process or between different slots to insert it. Processes can also be dragged &amp; attached to a new interval . ",
    "url": "https://ossia.io/score-docs/processes.html#stacked-slots",
    "relUrl": "/processes.html#stacked-slots"
  },"353": {
    "doc": "Supported protocols and formats",
    "title": "Operating systems",
    "content": "score works on Linux, macOS, Windows, and partially on the web platform. Its development mainly happens on an ArchLinux system. As score is built with Qt, it should be portable to any system where Qt runs. ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#operating-systems",
    "relUrl": "/reference/protocols-and-formats.html#operating-systems"
  },"354": {
    "doc": "Supported protocols and formats",
    "title": "Network protocols",
    "content": ". | OSC (Open Sound Control): the standard intermedia protocol. It is implemented through a heavily modified version of Ross Bencina’s oscpack library. | Documented here. | . | OSCQuery: . | Documented here. | . | Minuit. | Documented here. | . | HTTP. | Documented here. | . | WebSockets. | Documented here. | . | . ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#network-protocols",
    "relUrl": "/reference/protocols-and-formats.html#network-protocols"
  },"355": {
    "doc": "Supported protocols and formats",
    "title": "Hardware protocols",
    "content": ". | Art-Net / DMX: the standard for lighting fixtures. Support is implemented through libartnet, which has been integrated inside libossia. score is able to load fixtures definitions in the open-fixture-library format. | Documented here. | . | Serial port: score can read/write directly through serial ports, either directly or through Bluetooth. Support is currently based on the Qt SerialPort library but is being ported to ASIO to allow it to run in environments that cannot use Qt. | Documented here. | . | Game pads: they are supported through the SDL2 gamepad library. Most gamepads and joysticks should work without issue. | Documented here. | . | Wiimotes: they are supported through the WiiUse library. | Documented here. | . | Phidgets: they are supported through an implementation in libossia. Note that score must be built from source with the Phidgets API for the Phidgets protocol to be enabled. | . ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#hardware-protocols",
    "relUrl": "/reference/protocols-and-formats.html#hardware-protocols"
  },"356": {
    "doc": "Supported protocols and formats",
    "title": "Audio systems",
    "content": ". | JACK: support is implemented in libossia. | PulseAudio: experimental support is implemented in libossia. | PipeWire: experimental support is implemented in libossia and in score. | ALSA, the native Linux backend, supported through PortAudio. | CoreAudio: the native macOS backend, supported through PortAudio. | MME, WASAPI, WDMKS: the native Windows backends, supported through PortAudio. | ASIO: the low-latency pro-audio Windows backend developed by Steinberg, supported through PortAudio. | SDL: support is implemented in libossia. It is mainly used to provide audio for the WebAssembly build of score. | . ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#audio-systems",
    "relUrl": "/reference/protocols-and-formats.html#audio-systems"
  },"357": {
    "doc": "Supported protocols and formats",
    "title": "Video protocols",
    "content": ". | Spout is supported on Windows. | Documented here. | . | Syphon is supported on macOS. | Documented here. | . | Shmdata is supported on Linux and macOS. | Documented here. | . | An experimental NDI extension is available here. | . ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#video-protocols",
    "relUrl": "/reference/protocols-and-formats.html#video-protocols"
  },"358": {
    "doc": "Supported protocols and formats",
    "title": "Transport synchronisation",
    "content": ". | JACK transport: score can act as a master or a slave. | . ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#transport-synchronisation",
    "relUrl": "/reference/protocols-and-formats.html#transport-synchronisation"
  },"359": {
    "doc": "Supported protocols and formats",
    "title": "MIDI",
    "content": "All the MIDI support in score comes from the libremidi library: . For real-time communication, the following implementations are provided: . | ALSA, through either the raw or sequencer API. | JACK. | The native operating systems MIDI API: MME for Windows, CoreMIDI for macOS. | WebMIDI. | . In addition, score is able to load Standard MIDI files (SMF). See the MIDI documentation for more information. ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#midi",
    "relUrl": "/reference/protocols-and-formats.html#midi"
  },"360": {
    "doc": "Supported protocols and formats",
    "title": "Audio file formats",
    "content": "score uses FFMPEG for its audio needs. It should support most codecs and formats listed at this page. score handles WAV files in a specific way, through the dr_wav library, to allow for memory-mapping the data for large files. See the sound file process documentation for more information. ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#audio-file-formats",
    "relUrl": "/reference/protocols-and-formats.html#audio-file-formats"
  },"361": {
    "doc": "Supported protocols and formats",
    "title": "Video file formats",
    "content": "score uses FFMPEG for its video needs. It should support most codecs and formats listed at this page. The exception is the HAP codecs: for maximum performance, decoding is done by score (which allows doing it on the graphics card, while FFMPEG’s HAP decoding happens on the CPU which defeats the point of the codec). See the video process documentation for more information. ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#video-file-formats",
    "relUrl": "/reference/protocols-and-formats.html#video-file-formats"
  },"362": {
    "doc": "Supported protocols and formats",
    "title": "Image file formats",
    "content": "score uses Qt’s QImage for decoding images. The supported formats are PNG, GIF, JPEG. See the image process documentation for more information. ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#image-file-formats",
    "relUrl": "/reference/protocols-and-formats.html#image-file-formats"
  },"363": {
    "doc": "Supported protocols and formats",
    "title": "Real-time media sharing",
    "content": "score supports Spout. For now it is limited to outputting a texture. ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#real-time-media-sharing",
    "relUrl": "/reference/protocols-and-formats.html#real-time-media-sharing"
  },"364": {
    "doc": "Supported protocols and formats",
    "title": "Graphics APIs",
    "content": "score uses Qt RHI as graphics abstraction for the video pipeline. It is able to use OpenGL ES 2.0, Vulkan, Metal, and Direct 3D 11 in a very efficient way. score shaders are written with the Interactive Shader Format specification. See the shader process documentation for more information on how to write score shaders. See the general video documentation for general information on the score graphics rendering pipeline. ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#graphics-apis",
    "relUrl": "/reference/protocols-and-formats.html#graphics-apis"
  },"365": {
    "doc": "Supported protocols and formats",
    "title": "Audio plug-ins",
    "content": "score supports the following audio plug-in systems: . | Steinberg VST3 on all platforms. | Documented here. | . | LV2 on Linux. Note that currently this requires building score on your own computer or use a Linux distro package. | Documented here. | . | Faust, the Faust programming language developed by GRAME. score embeds the Faust compiler and libraries. | Documented here. | . | Pure Data is embedded in score through libpd. | Documented here. | . | It is possible to write simple audio instruments and effects with the various math-expression processes. | It is possible to write simple audio instruments and effects with the JavaScript process. | It is possible to write more advanced instruments and effects in C++ with the C++ JIT process. | . ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#audio-plug-ins",
    "relUrl": "/reference/protocols-and-formats.html#audio-plug-ins"
  },"366": {
    "doc": "Supported protocols and formats",
    "title": "Supported protocols and formats",
    "content": "This page lists all the systems, file formats, etc… that score is able to inter-operate with. ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html",
    "relUrl": "/reference/protocols-and-formats.html"
  },"367": {
    "doc": "Pure Data integration",
    "title": "Pure Data support",
    "content": "ossia score supports running Pure Data patches as processes. Simply drop a patch in the score to add it. This is done thanks to libpd. ",
    "url": "https://ossia.io/score-docs/processes/puredata.html#pure-data-support",
    "relUrl": "/processes/puredata.html#pure-data-support"
  },"368": {
    "doc": "Pure Data integration",
    "title": "Example",
    "content": "The following Pure Data patch: . Will look like this when loaded in score: . This particular example can be downloaded in the user library. Feel free to contribute your own useful patches here ! . ",
    "url": "https://ossia.io/score-docs/processes/puredata.html#example",
    "relUrl": "/processes/puredata.html#example"
  },"369": {
    "doc": "Pure Data integration",
    "title": "Limitations",
    "content": "For now do not use the “Parallel” execution mode when running Pd patches. ",
    "url": "https://ossia.io/score-docs/processes/puredata.html#limitations",
    "relUrl": "/processes/puredata.html#limitations"
  },"370": {
    "doc": "Pure Data integration",
    "title": "Usage",
    "content": "score will detect: . | Audio inlets/outlets: [adc~], [dac~] and create a corresponding audio input and output port. | Important ! You have to set in the inspector how many audio channels are needed, as they are multiplexed into a single port. | . | MIDI inlets/outlets: [midiin], [notein], [ctlin], [midiout], [noteout], [ctlout] and will create a MIDI input and / or output port. | Value inlets/outlets: [s] / [send], [r] / [receive]. | . It is possible (but still work-in-progress) to use the libossia ossia.parameter syntax for the receives, so that score is able to create nice GUI controls. Additionally, a widget attribute can be used, which will directly create the expected widget, among: . | intslider | floatslider | logfloatslider | intspinbox | toggle | button | lineedit | xyslider | hsvslider | . Valid cases would be (not all of them work yet): . [r myInput @type float @range -1 1] [r myInput @widget intslider @min 0 1000] [r myInput @type impulse] [r myInput @type bool @default true] [r myInput @unit color.hsv] . ",
    "url": "https://ossia.io/score-docs/processes/puredata.html#usage",
    "relUrl": "/processes/puredata.html#usage"
  },"371": {
    "doc": "Pure Data integration",
    "title": "Editing the patch",
    "content": "If a Pure Data binary is detected on the host computer (by looking into their default installations folders and in the PATH), then it will be possible to open the patch directly from score. There is one caveat that may be fixed in a future version of the integration: one must not close the main Pd UI window by quitting it like other OS windows. Instead, the window should be closed by pressing the “window” button in the score node. ",
    "url": "https://ossia.io/score-docs/processes/puredata.html#editing-the-patch",
    "relUrl": "/processes/puredata.html#editing-the-patch"
  },"372": {
    "doc": "Pure Data integration",
    "title": "Pure Data integration",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/puredata.html",
    "relUrl": "/processes/puredata.html"
  },"373": {
    "doc": "Pure Data integration",
    "title": "Pure Data integration",
    "content": "This documentation has moved. ",
    "url": "https://ossia.io/score-docs/docs/advanced/puredata.html",
    "relUrl": "/docs/advanced/puredata.html"
  },"374": {
    "doc": "Quick start",
    "title": "Quick start",
    "content": "ossia score 3.0.11 . This is the ossia score quick start manual. The following pages will guide you through score interface and general workflow. They also cover some of the basic elements available to author advanced scenarios such as snapshots saving and recalling, automations, as well as using audio and video files. These will get you started with the various ways score can be used to author flexible and structured scenarios for live performances, art installations or other media-based works. Enjoy advanced scenario authoring for your intermedia creation ! . ",
    "url": "https://ossia.io/score-docs/quick-start",
    "relUrl": "/quick-start"
  },"375": {
    "doc": "Rate Limiter",
    "title": "Rate Limiter",
    "content": ". The rate limiter can be used to synchronise the input stream to a subdivision of the tempo. When “None” is selected in the quantification spin box, an incoming value will only be output every N miliseconds, as specified by the ms slider. ",
    "url": "https://ossia.io/score-docs/processes/rate-limiter.html",
    "relUrl": "/processes/rate-limiter.html"
  },"376": {
    "doc": "Rate Limiter",
    "title": "Quantification",
    "content": "Set the subdivision of the tempo to synchronise to. ",
    "url": "https://ossia.io/score-docs/processes/rate-limiter.html#quantification",
    "relUrl": "/processes/rate-limiter.html#quantification"
  },"377": {
    "doc": "Rate Limiter",
    "title": "ms.",
    "content": "You can change the value between 0 and 1000 milliseconds. ",
    "url": "https://ossia.io/score-docs/processes/rate-limiter.html#ms",
    "relUrl": "/processes/rate-limiter.html#ms"
  },"378": {
    "doc": "Recording",
    "title": "Recording",
    "content": ". | Select addresses in the Device explorer. | Right-click in the score. | Select “Record automations from here”. | Press play: recording will start as soon as a message is received. This behaviour can be toggled in the Score preferences. | . ",
    "url": "https://ossia.io/score-docs/in-depth/recording.html",
    "relUrl": "/in-depth/recording.html"
  },"379": {
    "doc": "Reference",
    "title": "score reference manual",
    "content": "This section of the manual goes through the various sections of score and bring detailed explanations. ",
    "url": "https://ossia.io/score-docs/reference#score-reference-manual",
    "relUrl": "/reference#score-reference-manual"
  },"380": {
    "doc": "Reference",
    "title": "Reference",
    "content": " ",
    "url": "https://ossia.io/score-docs/reference",
    "relUrl": "/reference"
  },"381": {
    "doc": "Remote Control",
    "title": "Remote Control",
    "content": "The two main ways to remote control score from the network are: . | Through OSC and OSCQuery with the Local device. | Through a WebSocket API. The WebSocket API has been used to build a nice graphical remote application. | . This page describes the low-level WebSocket API used by score, so that anyone can build their custom remotes similar to the one mentioned above.. ",
    "url": "https://ossia.io/score-docs/in-depth/remote.html",
    "relUrl": "/in-depth/remote.html"
  },"382": {
    "doc": "Remote Control",
    "title": "Description",
    "content": "Exposes some properties of the score over WebSockets: . | Transport. | Viewing and controlling triggers. | Sending &amp; receiving messages through the Device Explorer. | Executing JS code in the console. | . ",
    "url": "https://ossia.io/score-docs/in-depth/remote.html#description",
    "relUrl": "/in-depth/remote.html#description"
  },"383": {
    "doc": "Remote Control",
    "title": "WebSocket API description",
    "content": "The message format is JSON. Score -&gt; client . { \"Message\": \"DeviceTree\" } . When a trigger starts executing: . { \"Message\": \"TriggerAdded\", \"Path\": \"/path/to/the/trigger\" } . When a trigger has finished executing: . { \"Message\": \"TriggerRemoved\", \"Path\": \"/path/to/the/trigger\" } . When an interval starts executing: . { \"Message\": \"IntervalAdded\", \"Path\": \"/path/to/the/interval\", \"Name\": \"machine_readable.name\", \"Label\": \"User-readable label\", \"Comment\": \"User-readable comment\", \"Speed\": 1.2345 } . When an interval has finished executing: . { \"Message\": \"IntervalRemoved\", \"Path\": \"/path/to/the/interval\" } . Heartbeat sent every few milliseconds: . { \"Intervals\": [ { \"Path\": \"/path/to/the/interval\", \"Progress\": 0.5, \"Speed\": 1., \"Gain\": 0.8 }, ... ] } . Client -&gt; score . Transport messages: . { \"Message\": \"Play\" } { \"Message\": \"Pause\" } { \"Message\": \"Stop\" } { \"Message\": \"Transport\", \"Milliseconds\": 40000 } . Console control: . See the Console API for the allowed operations. { \"Message\": \"Console\", \"Code\": \"someJSCodeToExecute()\" } . To trigger a trigger: . { \"Message\": \"Trigger\", \"Path\": \"/path/to/the/trigger\" } . To slow down or speed up an interval: . { \"Message\": \"IntervalSpeed\", \"Path\": \"/path/to/the/interval\", \"Speed\": 0.5 } . To change the gain of an interval: . { \"Message\": \"IntervalGain\", \"Path\": \"/path/to/the/interval\", \"Gain\": 0.5 } . To send a control message: . { \"Message\": \"Message\", \"Address\": \"device:/foo/bar@[color.rgb.r]\", \"Value\": { \"Float\": 1.23 } } . or, to showcase all possible types: . { \"Message\": \"Message\", \"Address\": \"device:/foo/bar\", \"Value\": { \"Tuple\": [ { \"Int\": 1 }, { \"Bool\": true }, { \"Char\": c }, { \"Vec2f\": [0.0, 1.1] }, { \"Vec3f\": [0.0, 1.1, 1.2] }, { \"Vec4f\": [0.0, 1.1, 1.3, 1.4] }, { \"Float\": 1.23 }, { \"String\": \"foo\" }, { \"Impulse\": null }, ] } } . To enable / disable listening . Listening to an address means that when an address’s value changes, the new value is forwarded to the remote client. { \"Message\": \"EnableListening\", \"Address\": \"device:/foo/bar\" } . and . { \"Message\": \"DisableListening\", \"Address\": \"device:/foo/bar\" } . Control surface . See Control surface. ",
    "url": "https://ossia.io/score-docs/in-depth/remote.html#websocket-api-description",
    "relUrl": "/in-depth/remote.html#websocket-api-description"
  },"384": {
    "doc": "Saving & recalling devices' state",
    "title": "Saving and recailling your device’s state",
    "content": "ossia score provides a number of tools to author precise control of the various devices involved in your project. Here we will focus on two basic elements: . | saving some devices’ state (aka making snapshots) to be recalled during the execution of your scenario | writing automations for some parameters | . These illustrate a small part of the possibilities detailed later in the manual, but should get you started with score basic workflow. ",
    "url": "https://ossia.io/score-docs/quick-start/saving-and-recalling-devices-state.html#saving-and-recailling-your-devices-state",
    "relUrl": "/quick-start/saving-and-recalling-devices-state.html#saving-and-recailling-your-devices-state"
  },"385": {
    "doc": "Saving & recalling devices' state",
    "title": "Storing your current device state",
    "content": "Saving your device current state on the timeline is as easy as dragging parameters you want to save from the Device explorer to where you will want them to be recalled in the timeline. You can store at one place all parameters of a device or only part of, as well as parameters from different devices. Note that when selecting a node in the namespace, all parameters below get selected. You may also select a single or many parameters using standard key combinations: . | Shift+click: Select all parameters between clicked parameter and previously selected one | Ctrl+click(Win / Linux) or⌘+click(Mac): Add selected parameter to the current selection | . In the illustration below, we will just select the gain parameters from our ossia compatible Max synth patch and store their current value at the 5th bar of our scenario. As you drop these gain parameters on the timeline, you can see a blue disc circled in white gets created. Clicking this state icon, you can see in the inspector panel both parameters and their value listed as a tree-like view. If you start playing your scenario using the play button from the transport (space key), this state will get recalled and sent to your device as the play-head cross its position on the timeline. Should you need this state to be recalled earlier or later, just stop execution of the scenario (using stop button from the transport bar or ↵ key), then select and drag it along the timeline. If your device does not echo back its parameters changes to score, you can still grab the parameters to store from the Device explorer and drop them on the Timeline. Then from the state inspector panel, type the desired value next to each parameter. You may as well type the desired values in the Device explorer first, then drag &amp; drop the parameters on the timeline. You may now make some changes to your device, then store this new state using the same drag &amp; drop workflow. Note that when storing our device’s second state in the timeline, score proposes to bind this snapshot to different elements in the timeline, as displayed with a dashed gray line. For now, we will just make sure this snapshot is bound to the first one we placed on the timeline. But be sure to check dedicated section in the manual to see the features score provides to help you structure elements in your scenario. You can now start sequencing your devices’ states in your scenario or read detailed information about managing states and automations. ",
    "url": "https://ossia.io/score-docs/quick-start/saving-and-recalling-devices-state.html#storing-your-current-device-state",
    "relUrl": "/quick-start/saving-and-recalling-devices-state.html#storing-your-current-device-state"
  },"386": {
    "doc": "Saving & recalling devices' state",
    "title": "Saving & recalling devices' state",
    "content": " ",
    "url": "https://ossia.io/score-docs/quick-start/saving-and-recalling-devices-state.html",
    "relUrl": "/quick-start/saving-and-recalling-devices-state.html"
  },"387": {
    "doc": "Scenario",
    "title": "Scenario",
    "content": "The main view in score. The Scenario process allows to put a score inside another score, and to nest at an arbitrarily depth: think of it as the traditional DAW groups, on steroids. Execution . | Putting stuff on the top start state for it to run with Reinitialize | Putting stuff on the top end state for it to run when stop is pressed. | . Keyboard shortcuts . | In a scenario with the navigation keys ( ↑, ↓, →, ←). | To the parent scenario with Ctrl+Alt+↑(Win / Linux) or⌘+Alt+↑(Mac). | Unroll all intervals’ racks in a scenario Ctrl+Alt+U(Win / Linux) or⌘+Alt+U(Mac) | Fold all intervals’ racks in a scenario Ctrl+Alt+F(Win / Linux) or⌘+Alt+F(Mac) | . Speed control . Speed sliders appear on intervals while playing. To reset it: Ctrl+Right Click(Win / Linux) or⌘+Right Click(Mac) . List of drag’n’drops possible . On intervals . | Drop from the device explorer to an interval: create an automatoin curve. | Drop from the library explorer to an interval: create a process. | Drop a media from the library or the system to an interval: create a process. | Drop from the object list into a slot or in the interval | . Moving processes around . | Drag the little ☰ icon somewhere else in the timeline. | In the same interval: reorders | In another interval: moves the process | In a blank space: creates a new interval from there and moves the process | . | . On processes . | Generally, dropping a media on a process changes the content of the process. | dropping a new sound file on a sound process | dropping a new address from the explorer on an automation | etc… | file bugs if you see a case not implemented ! | . | . On states . | Message list: add messages to the state | .cues files (created by dropping a state into the library) | .layer files | . From states . | It is possible to select messages in a state and drop them either in the scenario, or on another state | . ",
    "url": "https://ossia.io/score-docs/processes/scenario.html",
    "relUrl": "/processes/scenario.html"
  },"388": {
    "doc": "Scenario",
    "title": "Intervals",
    "content": "Execution controls: intervals can be started, stopped, and muted. Interpolate states . ",
    "url": "https://ossia.io/score-docs/processes/scenario.html#intervals",
    "relUrl": "/processes/scenario.html#intervals"
  },"389": {
    "doc": "Scenario",
    "title": "Graph links",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/scenario.html#graph-links",
    "relUrl": "/processes/scenario.html#graph-links"
  },"390": {
    "doc": "Scenario",
    "title": "Conditions",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/scenario.html#conditions",
    "relUrl": "/processes/scenario.html#conditions"
  },"391": {
    "doc": "Scenario",
    "title": "Keyboard shortcuts",
    "content": "Pressing suppr / backspace when a condition is selected removes it. ",
    "url": "https://ossia.io/score-docs/processes/scenario.html#keyboard-shortcuts-1",
    "relUrl": "/processes/scenario.html#keyboard-shortcuts-1"
  },"392": {
    "doc": "Scenario",
    "title": "Triggers",
    "content": ". | It is possible to choose the desired behaviour for off-time triggers : either triggering them stops and restarts the subgraph immediately, or it stops the subgraph and will only restart it after a new triggering. This choice is done in the trigger inspector. | . ",
    "url": "https://ossia.io/score-docs/processes/scenario.html#triggers",
    "relUrl": "/processes/scenario.html#triggers"
  },"393": {
    "doc": "Scenario",
    "title": "Keyboard shortcuts",
    "content": "Pressing suppr / backspace when a trigger is selected removes it. ",
    "url": "https://ossia.io/score-docs/processes/scenario.html#keyboard-shortcuts-2",
    "relUrl": "/processes/scenario.html#keyboard-shortcuts-2"
  },"394": {
    "doc": "Scenario",
    "title": "Sequences",
    "content": ". | Auto-sequence settings | . ",
    "url": "https://ossia.io/score-docs/processes/scenario.html#sequences",
    "relUrl": "/processes/scenario.html#sequences"
  },"395": {
    "doc": "Scripting API",
    "title": "Utility functions",
    "content": "// Reads the entire content of a file let data = Util.readFile(\"/path/to/file.txt\"); // Layouts a text so that it fits a rect of a given width by // adding line breaks. Naive algorithm. // Arguments are: // - text to lay out // - font to use // - font size // - maximum width in pixels let text = Util.layoutTextLines(\"some long text\", \"Monospace\", 24, 100); . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting-api.html#utility-functions",
    "relUrl": "/in-depth/scripting-api.html#utility-functions"
  },"396": {
    "doc": "Scripting API",
    "title": "Undo-redo and general helpers",
    "content": "// Find an object by name let obj = Score.find(\"Interval.foobar\"); // Get a reference to the object first selected in the score let obj = Score.selectedObject(); // Get a reference to all the objects currently selected in the score let objs = Score.selectedObjects(); // Get a reference to the current root document object let doc = Score.document(); // Undo-redo: Score.undo(); Score.redo(); // Undo-redo macros: // this is so that commands that do multiple // changes to the score, e.g. by adding multiple processes, // only show up as one single action in the undo-redo panel. // Every action that changes the score must be between these two calls. Score.startMacro(); Score.endMacro(); . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting-api.html#undo-redo-and-general-helpers",
    "relUrl": "/in-depth/scripting-api.html#undo-redo-and-general-helpers"
  },"397": {
    "doc": "Scripting API",
    "title": "UI",
    "content": "// This function allows to show a prompt to the user. // The object passed in argument allows to configure the UI to show. // They will be shown as a UI form. // The return value will be the list of values that the user has set on every widget if the prompt was accepted, and 'undefined' otherwise. const res = Score.prompt({ title: \"Input JSON\", widgets: [ { name:\"Name\", type: \"lineedit\", init: \"Hello\" }, { name:\"JSON\", type: \"textfield\" }, { name:\"Foo\", type: \"spinbox\", min: 0, max: 100, init: 10 }, { name:\"Bar\", type: \"slider\", min: 0.5, max: 10.2, init: 1.0 }, { name:\"Baz\", type: \"checkbox\", init: false } ] }); // Res could look like: // [\"text\", \"long text\", 30, 4.6, true] . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting-api.html#ui",
    "relUrl": "/in-depth/scripting-api.html#ui"
  },"398": {
    "doc": "Scripting API",
    "title": "Transport",
    "content": "// Plays the score Score.play(); // Plays a specific object let an_interval = Score.find(\"my_interval\"); Score.play(an_interval); // Stops playback Score.stop(); . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting-api.html#transport",
    "relUrl": "/in-depth/scripting-api.html#transport"
  },"399": {
    "doc": "Scripting API",
    "title": "Functions operating on devices",
    "content": "// Converts a device tree to JSON. // Useful for e.g. preset snapshotting, sending over the internet... let json = Score.deviceToJson(\"deviceName\"); // Create a WebSocket device from QML code. // See the QML code examples in the library. Score.createQMLWebSocketDevice(\"name\", \"QML Code\"); // Create a Serial device from QML code. // See the QML code examples in the library. Score.createQMLSerialDevice(\"name\", \"/dev/ttyUSB1\", \"QML Code\"); . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting-api.html#functions-operating-on-devices",
    "relUrl": "/in-depth/scripting-api.html#functions-operating-on-devices"
  },"400": {
    "doc": "Scripting API",
    "title": "Functions operating on the score",
    "content": "// Create a new process in an interval. // The process names are those in the library. // Third argument is reserved for future use. let new_process = Score.createProcess(an_interval, \"Automation (float)\", null); // Change the name of an object Score.setName(an_interval, \"Foo\"); // Create a new free-floating interval // Arguments: // - parent scenario // - At which time the interval is created (e.g. \"00:01:15.345\" for 1 minute 15 seconds 345 millis) // - How long it lasts (same format) // - Which vertical position (between [0;1] (top;bottom)) let new_itv = Score.createBox(scenar, \"00:00:10.000\", \"00:01:15.000\", 0.2); // Create a new interval after a state let new_itv = Score.createIntervalAfter(state, duration, y); // Get a port by name given a process let port = Score.port(my_lfo, \"Frequency\"); // Get an inlet / outlet by index given a process. // Here \"port1\" would be the \"Offset\" port of a LFO process let port1 = Score.inlet(my_lfo, 2); // Here \"port2\" would be the \"Outlet\" port of a LFO process let port2 = Score.outlet(my_lfo, 0); // Returns how many inlets / outlets there are in a given process let count = Score.inlets(my_lfo); let count = Score.outlets(my_lfo); // Set the address of a port Score.setAddress(port1, \"midi:/1/control/34\"); // Set the value of a port (only relevant for ports with UI controls) Score.setValue(port1, 0.34); Score.setValue(portA, \"foo\"); Score.setValue(portB, true); // etc... // Get the type of a port as a string. Float, Int, String, etc. let type = Score.valueType(port1); // Get the min/max range of a port if it has one let min = Score.min(port1); let max = Score.max(port1); // Get the list of values if the port is an enum / combo box / chooser ... let vals = Score.enumValues(port1); // Access the metadata object of an object. Allows to see the label, comments, etc let meta = Score.metadata(scenario); console.log(meta.name, meta.label, meta.comment) // Access the start / end elements of an interval let st = Score.startState(itv); let st = Score.endState(itv); let ev = Score.startEvent(itv); let ev = Score.endEvent(itv); let ts = Score.startSync(itv); let ts = Score.endSync(itv); // Remove an object from the score Score.remove(itv); // Create an automation on the given interval from an address Score.automate(itv, \"foo:/bar\"); // Create an automation on the given interval from a port object Score.automate(itv, port1); . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting-api.html#functions-operating-on-the-score",
    "relUrl": "/in-depth/scripting-api.html#functions-operating-on-the-score"
  },"401": {
    "doc": "Scripting API",
    "title": "Functions operating on curves",
    "content": "// Set a curve from a list of points: // [ [ x1, y1 ], [ x2, y2 ], ... ] let points = [ [0, 0.5], [0.2, 1.], [0.5, 0.9], [1.0, 0.0], ]; Score.setCurvePoints(an_automation_process, points); . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting-api.html#functions-operating-on-curves",
    "relUrl": "/in-depth/scripting-api.html#functions-operating-on-curves"
  },"402": {
    "doc": "Scripting API",
    "title": "Functions operating on step sequencer",
    "content": "// Sets the step on a Step Sequencer Score.setSteps(a_step_sequencer_process, [0.1, 0, 1., 0.4, 0.5]); . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting-api.html#functions-operating-on-step-sequencer",
    "relUrl": "/in-depth/scripting-api.html#functions-operating-on-step-sequencer"
  },"403": {
    "doc": "Scripting API",
    "title": "Scripting API",
    "content": " ",
    "url": "https://ossia.io/score-docs/in-depth/scripting-api.html",
    "relUrl": "/in-depth/scripting-api.html"
  },"404": {
    "doc": "Scripting",
    "title": "Scripting",
    "content": "The software can be scripted with Javascript (ES7). The available functions are defined by the following C++ class: EditJsContext. Click here for the complete reference. These functions will be available under the global Score object in the JS contexts. Additional utility functions are available under the Util object. let data = Util.readFile(\"/Users/me/foo.txt\"); . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting.html",
    "relUrl": "/in-depth/scripting.html"
  },"405": {
    "doc": "Scripting",
    "title": "Putting scripts in the User Library",
    "content": "Scripts ending in .js in the user library can be double-clicked: they will be run in the global application context. A script can introduce a function which can then be leveraged by the Javascript processes. ",
    "url": "https://ossia.io/score-docs/in-depth/scripting.html#putting-scripts-in-the-user-library",
    "relUrl": "/in-depth/scripting.html#putting-scripts-in-the-user-library"
  },"406": {
    "doc": "Scripting",
    "title": "Scripting in the console panel",
    "content": "The Console (shortcut: Ctrl+Shift+C(Win / Linux) or⌘+Shift+C(Mac)) allows to quickly test scripts in a REPL fashion. It is also useful as a simple calculator :-) . For instance, here is how a small console session may look: . // Gets the first selected object. &gt; var obj = Score.selectedObject(); // Print it to check what we got. &gt; obj; Scenario::IntervalModel(0x555556411330, \"Scenario::IntervalModel\") // Play it. &gt; Score.play(obj); . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting.html#scripting-in-the-console-panel",
    "relUrl": "/in-depth/scripting.html#scripting-in-the-console-panel"
  },"407": {
    "doc": "Scripting",
    "title": "Making scripts available as GUI actions",
    "content": "It is possible to put scripts in the “Scripts” menu at the top of the software. Scripts must be valid Javascript modules, and be present somewhere in the system library. Here is an example, which should go in for instance Documents/ossia/score/packages/user/my_scripts/Hello.mjs. It will add an “Example &gt; Hello” sub-menu in the “Scripts” menu. The script will also be triggable at any point with the Alt+A, Alt+H keyboard shortcut. A single script module can register multiple actions in one go. // This will be called whenever the action is triggered in the menu. function your_custom_function() { console.log(\"Triggered\"); } export function initialize() { // This will be called when the module is loaded on startup. console.log(\"Hello world !\") } // This is used to register actions in the Scripts menu in score export const actions = [ { name: \"Example/Hello\" , context: ActionContext.Menu , shortcut: \"Alt+A, Alt+H\" , action: your_custom_function } ] . A video example is available here ; here is an example of script that randomizes a process’s controls. ",
    "url": "https://ossia.io/score-docs/in-depth/scripting.html#making-scripts-available-as-gui-actions",
    "relUrl": "/in-depth/scripting.html#making-scripts-available-as-gui-actions"
  },"408": {
    "doc": "Scripting",
    "title": "Examples",
    "content": " ",
    "url": "https://ossia.io/score-docs/in-depth/scripting.html#examples",
    "relUrl": "/in-depth/scripting.html#examples"
  },"409": {
    "doc": "Scripting",
    "title": "Simple example",
    "content": "// Creates an OSC device named foo. Messages will be sent from score to 127.0.0.1:5678. // Score will listen to messages on port 1234. Score.createOSCDevice(\"foo\", \"127.0.0.1\", 5678, 1234); // Creates an OSC address on the device foo, named /bar/baz. It will receive color.rgba types. // All the usual ossia unit names are accessible, // as well as useful names such as the ones found in [addresses](addresses doc) Score.createAddress(\"foo:/bar/baz\", \"color.rgba\"); // Finds an object in the current score. // The name is the object name, put in the inspector var myObject = Score.find(\"the object name\"); // Creates an automation. The first argument must be a valid pointer to an interval // found by Score.find(...). Score.automate(myInterval, \"foo:/my/address\"); // Undo-redo Score.undo(); Score.redo(); // Transport Score.play(); Score.stop(); . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting.html#simple-example",
    "relUrl": "/in-depth/scripting.html#simple-example"
  },"410": {
    "doc": "Scripting",
    "title": "Advanced example 1",
    "content": "This example shows how to generate a sequence of randomized processes: automations, step sequencer, LFO which will control an address starting from a state. It declares a function that can then be called like this: . gengis_gen(\"my_state\", \"foo:/bar\") . // This function randomizes all the parameters of an LFO process // (or any process with inlets) function randomizeLFO(lfo) { // First count the number of inlets const N = Score.inlets(lfo); // For each inlet: for (let i = 0; i &lt; N; ++i) { // Get it const inl = Score.inlet(lfo, i); // Get what its type is (\"Float\", \"Int\", \"String\", etc) const val_type = Score.valueType(inl); if (val_type === \"Float\" || val_type === \"Int\") { // In that case check the range of the control const min = Score.min(inl); const max = Score.max(inl); // Generate a value in that range const val = min + Math.random() * (max - min); // Apply it to the control Score.setValue(inl, val); } else if (val_type === \"String\") { // If the input is a string it's likely an enumeration const values = Score.enumValues(inl); // [\"Sin\", \"Square\", ...] // Pick an enum value at random const val = Math.round(Math.random() * (N - 1)); const N = values.length; // Apply it Score.setValue(inl, values[val]); } } } // This function creates a random automation. // Automations are defined like this: // [ // [0, 0.2], // [0.5, 0.7], // [1., 0.4] // ] // will make a curve that starts at 0.2, goes up to 0.7 at the half of the curve, // and reaches 0.4 at the end. // The y values should be between 0 and 1, // the x values can go beyond 1 (to write past the default length of the automation). function randomizeAutomation(autom) { let arr = []; for (let i = 0; i &lt;= 10; i++) { let x = i / 10; let y = Math.random(); arr.push([x, y]); } Score.setCurvePoints(autom, arr); } // This function creates a random series of steps for the step sequencer. function randomizeStep(step) { let arr = []; for (let i = 0; i &lt;= 10; i++) { arr.push(Math.random()); } Score.setSteps(step, arr); } // Takes the name of a state and an address to set to each process's output. function gengis_gen(startState, address) { // Look for our state object. let ss = Score.find(startState); if (ss === null) { console.log(`${startState} not found`); return; } // We'll create 16 processes. const num = 16; const y = ss.heightPercentage; var cur_state = ss; // Start recording undo / redo commands. Score.startMacro(); for (let i = 0; i &lt; num; i++) { const seconds = Math.floor(Math.random() * 10); const duration = `00:00:0${seconds}`; // Create an interval after the state let new_itv = Score.createIntervalAfter(cur_state, duration, 0.1); // Create processes by name. var p; switch (Math.floor(Math.random() * 3) % 3) { case 0: { p = Score.createProcess(new_itv, \"LFO\", \"\"); randomizeLFO(p); break; } case 1: { p = Score.createProcess(new_itv, \"Automation (float)\", \"\"); randomizeAutomation(p); break; } case 2: { p = Score.createProcess(new_itv, \"Step sequencer\", \"\"); randomizeStep(p); break; } } if (p) { // Get the outlet of the process. let main_outlet = Score.outlet(p, 0); // Set its address. Score.setAddress(main_outlet, address); } // The next interval will start from the end state of the current interval. cur_state = Score.endState(new_itv); } // Apply the macro so that it can be un-done in one step. Score.endMacro(); } . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting.html#advanced-example-1",
    "relUrl": "/in-depth/scripting.html#advanced-example-1"
  },"411": {
    "doc": "Scripting",
    "title": "Advanced example 2",
    "content": "This example creates images process, plays them and remove them. The function bullet can be added to a Javascript process. For instance, this will create a Javascript process that makes an image sub-scenario be created randomly, every time it gets an input value: . import Score 1.0 Script { ValueInlet { id: in1 } tick: (token, state) =&gt; { if (typeof in1.value !== 'undefined') { Device.exec(\"bullet(Score.find('Scenario.1'))\") } } } . function bullet(scenario) { if(scenario === null) return; Score.startMacro(); // Create a new box const start_seconds = Math.floor(Math.random() * 10); const start_duration = `00:00:0${start_seconds}`; const len_seconds = Math.floor(1 + Math.random() * 2); const len_duration = `00:00:0${len_seconds}`; let itv = Score.createBox(scenario, start_duration, len_duration, Math.random() * 0.4 + 0.2); // Add an image process within { let img = Score.createProcess(itv, \"Images\", \"\"); // Set the bullet image let files = Score.port(img, \"Images\"); Score.setValue(files, [\"/home/jcelerier/genuary/bullet.png\"]); // Set the output address let outlet = Score.outlet(img, 0); Score.setAddress(outlet, \"window:/\"); // Set a random position let pos = Score.port(img, \"Position\"); Score.setValue(pos, [4*(Math.random()-0.5), 4*(Math.random()-0.5)]); // Set a random scale let scaleX = Score.port(img, \"Scale X\"); let scaleY = Score.port(img, \"Scale Y\"); let sc = 0.5 + Math.random() * 0.3; Score.setValue(scaleX, sc); Score.setValue(scaleY, sc); // Add an automation on the opacity { let opacity = Score.port(img, \"Opacity\"); let autom = Score.automate(itv, opacity); Score.setCurvePoints(autom, [ [0., 1.], [1., 0.] ]); } } // In the end state, add a small script, which will destroy that box { let end = Score.endState(itv); const script = `import Score 1.0 Script { start: () =&gt; Device.exec(\"Score.remove(Score.find('${Score.metadata(itv).name}'))\"); } ` Score.createProcess(end, \"Javascript\", script); } // Save as an undo-redo command Score.endMacro(); // Play it Score.play(itv); } . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting.html#advanced-example-2",
    "relUrl": "/in-depth/scripting.html#advanced-example-2"
  },"412": {
    "doc": "Serial device",
    "title": "Serial device",
    "content": ". This protocol allows to communicate through custom serial port protocols defined in QML. Multiple examples are available in the user library. ",
    "url": "https://ossia.io/score-docs/devices/serial-device.html",
    "relUrl": "/devices/serial-device.html"
  },"413": {
    "doc": "Serial device",
    "title": "QML API",
    "content": "Assuming a serial device which, whenever bytes are written to it, sends back a sensor reading with the following textual protocol: . 10\\r\\n12\\r\\n17\\r\\n5\\r\\n... To fetch the sensor value, a get message must be written by the computer to the serial port ; a complete communication session, in a serial console could for instance look like this: . get 10 get 12 get 17 . A basic QML script for processing that serial device and making the sensor value available to score under a /sensor address in the device explorer would look like this: . import Ossia 1.0 as Ossia Ossia.Serial { function onMessage(message) { return [ { address: \"/sensor\", value: parseInt(message) } ]; } function createTree() { return [ { name: \"request\", type: Ossia.Type.Pulse, access: Ossia.Access.Set, request: \"get\" }, { name: \"sensor\", type: Ossia.Type.Int, access: Ossia.Access.Get, min: 0, max: 255, bounding: Ossia.Bounding.Clip, repetition_filter: Ossia.Repetitions.Filtered } ]; } } . Here is the complete syntax available for reading messages: the most important thing to note is that: . | onMessage is to be used to process messages in text-based protocols. | onBinary is to be used to process messages in binary protocols. | onRead is to be used to process the raw byte stream. | property string delimiter: \"\\n\\n\" and property string framing: \"&lt;FRAMING&gt;\" can be used to configure the framing of messages. | . Supported framing protocols are: . | “none” | “slip” | “size” | “delimiter” (the default, set as “\\r\\n”) | . import Ossia 1.0 as Ossia Ossia.Serial { /// Message-based processing /// // Option A: this function is called whenever a \\r\\n-delineated message is read. // \"message\" will be a string, thus this function is what you need to use for text-based protocols. function onMessage(message) { // Will log in score's message window console.log(message); // Will set the value 123 to the address my_device:/sensor return [ { address: \"/sensor\", value: 123 } ]; } // Option B: this function is called whenever a message is read. // \"message\" will be an ArrayBuffer containing the raw bytes. function onBinary(message) { // Will log in score's message window console.log(message); // Will set the value 123 to the address my_device:/sensor return [ { address: \"/sensor\", value: 456 } ]; } // The delineation can be overriden with: property string delimiter: \"\\n\\n\" // It's possible to use other framing methods for message-based processing. // The following are supported: // SLIP encoding: property string framing: \"slip\" // Size-prefix encoding. // Each message starts with a big-endian int32 which is the size of the next message. property string framing: \"size\" // Delimiter (the default) property string framing: \"delimiter\" // No framing at all. It's up to the user to reconstitute messages, in the \"onRead\" method (see below). property string framing: \"none\" /// Raw processing /// // Option C: // If doing the following, the serial processing code will not attempt to frame // incoming and outgoing data as messages. The function is called with whatever bytes are available // and it is up to the user to reassemble them with the custom protocol being used. // \"bytes\" will be an ArrayBuffer containing the raw bytes. function onRead(bytes) { // Will set the value 123 to the address my_device:/sensor return [ { address: \"/sensor\", value: 789 } ]; } /// Creation of the tree /// // This function defines the shape of this device tree. // Note that it is static and defined at creation. function createTree() { return [ // This creates a node \"my_device:/request\" of type \"impulse\" { name: \"request\", type: Ossia.Type.Pulse, access: Ossia.Access.Set, /// request: can be used to customize the serial communication. // Option A: the string \"$val\" will be replaced textually by the value of the message sent by score request: \"message sent whenever a message is sent to this address in score\" // Option B: the given function will be called, which will return a string which behaves the same request: () =&gt; { return Math.random() + \" foo \" } // Option C: same thing with an argument: // it will be an object { value: /* current value */, type: /* type of the value */ } request: (val) =&gt; { return val.value + \" foo \" } }, // This creates a node \"my_device:/sensor\" of type \"int\" { name: \"sensor\", type: Ossia.Type.Int, access: Ossia.Access.Get, min: 0, max: 255, bounding: Ossia.Bounding.Clip, repetition_filter: Ossia.Repetitions.Filtered // Here without \"request:\" specified, the int value of the address will be textually written to the serial port } ]; } // These functions are called when score needs to actively listen on changes on some addresses function openListening(address) { } function closeListening(address) { } } . ",
    "url": "https://ossia.io/score-docs/devices/serial-device.html#qml-api",
    "relUrl": "/devices/serial-device.html#qml-api"
  },"414": {
    "doc": "Serial device",
    "title": "Writing binary data",
    "content": "By default, the values returned from request in the device tree are treated as strings and will be written to the serial port in textual, ASCII format. For instance, an “int” parameter with value 1234 will cause the actual integer to be written textually in the serial port: 123 as the bytes 0x31 0x32 0x33, and not the single-byte value for 123, 0x7B. If one wants actual binary data to be written, it is necessary to use a Javascript Typed Array, such as Uint8Array. Note that in this case the framing also must be handled manually, to enable for more control. Here is an example which will write a single byte delimited by \\r\\n. { name: \"request\", type: Ossia.Type.Int, access: Ossia.Access.Set, min: 0, max: 127, request: (val) =&gt; { let auint8 = new ArrayBuffer(3); let uint8 = new Uint8Array(auint8); uint8[0] = val.value; // An integer between 0 and 127 uint8[1] = '\\r'; uint8[2] = '\\n'; return auint8; } } . ",
    "url": "https://ossia.io/score-docs/devices/serial-device.html#writing-binary-data",
    "relUrl": "/devices/serial-device.html#writing-binary-data"
  },"415": {
    "doc": "Serial device",
    "title": "Coalescing messages",
    "content": "In case the serial port is too slow and overflows, one can add the property: . property real coalesce: 15 . to the Serial object, to coalesce messages every 15 milliseconds for instance. If a specific parameter must not be coalesced, but always sent, one can simply set critical: true on the node. One will generally want to use coalescing on parameters such as lights, drives, or anything that more-or-less maps to an electrical voltage, and not for parameters that would trigger the start of an action. ",
    "url": "https://ossia.io/score-docs/devices/serial-device.html#coalescing-messages",
    "relUrl": "/devices/serial-device.html#coalescing-messages"
  },"416": {
    "doc": "Serial device",
    "title": "Examples",
    "content": "Arduino’s built-in examples proposes two similar sketches for serial communication: SerialCallResponse and SerialCallResponseASCII. You can find their companion QML scripts in the user library, illustrating the use of the onRead and onMessage functions respectively. ",
    "url": "https://ossia.io/score-docs/devices/serial-device.html#examples",
    "relUrl": "/devices/serial-device.html#examples"
  },"417": {
    "doc": "ISF Shaders",
    "title": "ISF Shaders",
    "content": ". The shader process allow you to add and live-code your own shader to an image or video. A shader is a visual effect or generator program, which is processed with the graphics card for maximum performance. Shaders are written with the Interactive Shader Format (ISF), using GLSL. A lot of nice shaders are already provided as part of the user library, courtesy of Vidvox. They can be drag’n’dropped from the library, or from the explorer ; controls and inputs will be created automatically. ISF filters apply to the whole texture used as their input, which is then rendered to a texture used as output (or directly to the viewport). ",
    "url": "https://ossia.io/score-docs/processes/shaders.html",
    "relUrl": "/processes/shaders.html"
  },"418": {
    "doc": "ISF Shaders",
    "title": "Editing shaders",
    "content": "We recommend using the official ISF editor to edit shaders for production work ; but it is possible to edit the shader code live during execution of the score, by pressing Ctrl+Enter(Win / Linux) or⌘+Enter(Mac) when in the code editor ; the shader will be updated automatically. The shader editor allows to edit both the fragment and the vertex shader. ",
    "url": "https://ossia.io/score-docs/processes/shaders.html#editing-shaders",
    "relUrl": "/processes/shaders.html#editing-shaders"
  },"419": {
    "doc": "Shmdata devices",
    "title": "Shmdata",
    "content": "Shmdata, developed at the SAT Metalab, is a Unix-oriented protocol for sharing memory between applications easily. It is mainly used to share video frames. Thanks to it, score can easily send and receive video data from and to GStreamer for instance. ",
    "url": "https://ossia.io/score-docs/devices/shmdata-devices.html#shmdata",
    "relUrl": "/devices/shmdata-devices.html#shmdata"
  },"420": {
    "doc": "Shmdata devices",
    "title": "Compiling and installing shmdata",
    "content": "Refer to the latest instructions on the shmdata Readme. Score comes built-in with shmdata support on Linux and macOS (Windows does not support the necessary Unix primitives). Test that it works correctly with the gst-launch commands given in that Readme. ",
    "url": "https://ossia.io/score-docs/devices/shmdata-devices.html#compiling-and-installing-shmdata",
    "relUrl": "/devices/shmdata-devices.html#compiling-and-installing-shmdata"
  },"421": {
    "doc": "Shmdata devices",
    "title": "Using shmdata in score",
    "content": "Shmdata can currently be used as a video input and output device. Simply create the devices you need, and set your video input / output to the shmdata device’s name. These examples assume that the shmdata GStreamer plug-in is installed in /opt/shmdata: . Sending data from GStreamer to score: . $ gst-launch-1.0 --gst-plugin-path=/opt/shmdata videotestsrc pattern=snow ! queue ! videoconvert ! shmdatasink socket-path=/tmp/score_shmdata_input . Sending data from score to GStreamer: . $ gst-launch-1.0 --gst-plugin-path=/opt/shmdata shmdatasrc socket-path=/tmp/score_shmdata_output ! videoconvert ! xvimagesink . Here is a score that would process the input and write it to the output. | Input device (receives the GStreamer feed): . | Output device (sends the feed to GStreamer): . | The score and the GStreamer output which shows the processing done by score: . | . ",
    "url": "https://ossia.io/score-docs/devices/shmdata-devices.html#using-shmdata-in-score",
    "relUrl": "/devices/shmdata-devices.html#using-shmdata-in-score"
  },"422": {
    "doc": "Shmdata devices",
    "title": "Recording score’s video output",
    "content": "Here is a GStreamer command-line which will encode the shmdata output as .mkv with relatively low quality: . $ gst-launch-1.0 -e \\ shmdatasrc socket-path=/tmp/score_shm_video \\ ! queue \\ ! videoconvert \\ ! videorate \\ ! video/x-raw,framerate=60/1 \\ ! x264enc \\ ! matroskamux \\ ! filesink location=foo.mkv . Or as .mov encoded in Apple ProRes (warning: very, very CPU hungry): . $ gst-launch-1.0 -e \\ shmdatasrc socket-path=/tmp/score_shm_video \\ ! queue \\ ! videoconvert \\ ! videorate \\ ! video/x-raw,framerate=60/1 \\ ! avenc_prores_ks \\ ! qtmux \\ ! filesink location=foo.mov . ",
    "url": "https://ossia.io/score-docs/devices/shmdata-devices.html#recording-scores-video-output",
    "relUrl": "/devices/shmdata-devices.html#recording-scores-video-output"
  },"423": {
    "doc": "Shmdata devices",
    "title": "Shmdata devices",
    "content": " ",
    "url": "https://ossia.io/score-docs/devices/shmdata-devices.html",
    "relUrl": "/devices/shmdata-devices.html"
  },"424": {
    "doc": "Shortcuts",
    "title": "General",
    "content": ". | Ctrl+Shift+D(Win / Linux) or⌘+Shift+D(Mac): Show Device explorer panel | Ctrl+Shift+P(Win / Linux) or⌘+Shift+P(Mac): Show Processes library panel | Ctrl+Shift+B(Win / Linux) or⌘+Shift+B(Mac): Show System library panel | Ctrl+Shift+L(Win / Linux) or⌘+Shift+L(Mac): Show Project library panel | Ctrl+Shift+C(Win / Linux) or⌘+Shift+C(Mac): Show Console panel | Ctrl+Shift+G(Win / Linux) or⌘+Shift+G(Mac): Show Messages log panel | . ",
    "url": "https://ossia.io/score-docs/reference/shortcuts.html#general",
    "relUrl": "/reference/shortcuts.html#general"
  },"425": {
    "doc": "Shortcuts",
    "title": "Conditions",
    "content": ". | Suppr/Backspace: Delete selected condition | . ",
    "url": "https://ossia.io/score-docs/reference/shortcuts.html#conditions",
    "relUrl": "/reference/shortcuts.html#conditions"
  },"426": {
    "doc": "Shortcuts",
    "title": "Device explorer",
    "content": ". | Esc: De-select node | . ",
    "url": "https://ossia.io/score-docs/reference/shortcuts.html#device-explorer",
    "relUrl": "/reference/shortcuts.html#device-explorer"
  },"427": {
    "doc": "Shortcuts",
    "title": "Timeline",
    "content": ". | ↑, ↓, →, ←: Navigate through the various linked elements on the Timeline | Ctrl+Alt+↑(Win / Linux) or⌘+Alt+↑(Mac): Go back to parent scenario | Ctrl+Alt+U(Win / Linux) or⌘+Alt+U(Mac): Unroll all processes attached to an interval | Ctrl+Alt+F(Win / Linux) or⌘+Alt+F(Mac): Fold all processes attached to an interval | . ",
    "url": "https://ossia.io/score-docs/reference/shortcuts.html#timeline",
    "relUrl": "/reference/shortcuts.html#timeline"
  },"428": {
    "doc": "Shortcuts",
    "title": "Trigger",
    "content": ". | Suppr/Backspace: Delete selected trigger | . ",
    "url": "https://ossia.io/score-docs/reference/shortcuts.html#trigger",
    "relUrl": "/reference/shortcuts.html#trigger"
  },"429": {
    "doc": "Shortcuts",
    "title": "Shortcuts",
    "content": "Below is a list of shortcuts available in score listed by scope of usage. ",
    "url": "https://ossia.io/score-docs/reference/shortcuts.html",
    "relUrl": "/reference/shortcuts.html"
  },"430": {
    "doc": "Signal display",
    "title": "Signal display",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/signal-display.html",
    "relUrl": "/processes/signal-display.html"
  },"431": {
    "doc": "Soundfiles",
    "title": "Sound file process",
    "content": "To add a sound file, the easiest way is to drag’n’drop it either from the operating system, or from the library. ",
    "url": "https://ossia.io/score-docs/processes/soundfile.html#sound-file-process",
    "relUrl": "/processes/soundfile.html#sound-file-process"
  },"432": {
    "doc": "Soundfiles",
    "title": "Timestretching",
    "content": "ossia score supports 4 modes of playback: . | No stretching at all (Raw). | Re-pitching through resampling thanks to the libsamplerate library. | Time-stretching (pitch does not change) thanks to the Rubberband library, in a mode optimized for drums and another for tonal instruments. | . If a file has any tempo information (either through ACID tags or a BPM present in the filename), it is automatically assumed to be a loop and put in loop mode with the timestretch enabled. The tempo of the soundfile can be adjusted through the inspector ; the ratio between its tempo and the current playback tempo will be used to timestretch / repitch accordingly. ",
    "url": "https://ossia.io/score-docs/processes/soundfile.html#timestretching",
    "relUrl": "/processes/soundfile.html#timestretching"
  },"433": {
    "doc": "Soundfiles",
    "title": "RAM / disk playback",
    "content": "score will stream .wav / .aiff files at the same samplerate than the project from disk directly. All the other files will be decoded first and read from RAM. | Until a choice is implemented, we recommend users who have large .wav files and slow hard drives to set-up a RAMDisk manually. | . ",
    "url": "https://ossia.io/score-docs/processes/soundfile.html#ram--disk-playback",
    "relUrl": "/processes/soundfile.html#ram--disk-playback"
  },"434": {
    "doc": "Soundfiles",
    "title": "Supported formats",
    "content": "score should be able to read any file supported by FFMPEG. Current releases are built with FFMPEG 4.4. The list of supported audio format is available here. ",
    "url": "https://ossia.io/score-docs/processes/soundfile.html#supported-formats",
    "relUrl": "/processes/soundfile.html#supported-formats"
  },"435": {
    "doc": "Soundfiles",
    "title": "Soundfiles",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/soundfile.html",
    "relUrl": "/processes/soundfile.html"
  },"436": {
    "doc": "Spout devices",
    "title": "Spout",
    "content": "Spout is a Windows-only protocol and library for sharing video textures across applications. ",
    "url": "https://ossia.io/score-docs/devices/spout-devices.html#spout",
    "relUrl": "/devices/spout-devices.html#spout"
  },"437": {
    "doc": "Spout devices",
    "title": "Spout input device",
    "content": "This device allows receiving a video stream directly from a Spout-compatible input. Simply choose the wanted input in the list, and put the output at the end of the video chain. ",
    "url": "https://ossia.io/score-docs/devices/spout-devices.html#spout-input-device",
    "relUrl": "/devices/spout-devices.html#spout-input-device"
  },"438": {
    "doc": "Spout devices",
    "title": "Spout output device",
    "content": "This device allows to create a Spout stream that other sPout-compatible software will be able to display or modify. Simply choose the viewport options, a rendering rate, and a name for the output. You can then use the device as input to video filters. ",
    "url": "https://ossia.io/score-docs/devices/spout-devices.html#spout-output-device",
    "relUrl": "/devices/spout-devices.html#spout-output-device"
  },"439": {
    "doc": "Spout devices",
    "title": "Spout devices",
    "content": " ",
    "url": "https://ossia.io/score-docs/devices/spout-devices.html",
    "relUrl": "/devices/spout-devices.html"
  },"440": {
    "doc": "States & automations in practice",
    "title": "States &amp; automations in practice",
    "content": "In previous sections of this quick start guide, we saw two elementary methods to write scenarios for your project: saving &amp; recalling some device’s state as well as writing simple automations for its parameters. While elementary, these two very features still offer a lot of flexibility to author advanced scenarios for your creations project. This is made even more flexible given a handful of score’s practice-based workflow features. Rather than separating cue-like execution of messages toward your devices and time evolving processes such as automations, score offer a number of ways to easily mix two approaches in a unified workflow. ",
    "url": "https://ossia.io/score-docs/quick-start/states-and-automations-in-practice.html#states--automations-in-practice",
    "relUrl": "/quick-start/states-and-automations-in-practice.html#states--automations-in-practice"
  },"441": {
    "doc": "States & automations in practice",
    "title": "Sequence mode",
    "content": "Setting up auto-sequence mode . A workflow you might find useful is the auto-sequence mode. As of score 3, auto-sequence is an option that needs to be activated from the software Score preferences. To do so, bring up the Settings window. In the Settings window, select the User interface tab then make sure the auto-sequence option is toggled. Using auto-sequence . In previous sections, we saw how to drag parameters from the Device explorer to easily store your device’s state on the timeline as well as drag some processes (in this case automation). Auto-sequence kind of allows to do both in one go. In the example below, we will start by storing an initial state for our device. Then after making some changes to our device, rather than dropping again the parameters from the Device explorer to the timeline, we will use the blue + icon next to the state icon and drag the link to a later point in the timeline. What happens here is twofold: . | storing a new state using that blue + button will store the device’s state using the namespace selection defined in the previous stored state | using the auto-sequence option, score will automatically create some automations for the parameter that changed between initial state and newly created state | . You may also store a new state by dragging from the blue + icon without auto-sequence mode activated. In that case, score will still use previous namespace selection to store parameters values but no automation will get created for changed parameters. Of course, once these automations get auto-magically created, you can still edit their behavior over time and do whatever pleasing changes to their curve. You may also remove an automation, should you want not to include a parameter continuous change. Note on multiple automations editing . In the example above, you can see multiple automation slots actually got superposed. You can bring to front any of the automations in background to edit it. To do so, click on the address bar at the top of the slot to open up the list of superposed parameters ‘automation. Select in the contextual menu the one to edit. Once to front (displayed in red), it can be edited. When multiple automations are stacked, frontmost one is drawn with a red line, while the ones behind are drawn with a greyed out line . You can also remove an automation from the stack by clicking on a slot background. Bring the contextual menu using right-click and select remove. ",
    "url": "https://ossia.io/score-docs/quick-start/states-and-automations-in-practice.html#sequence-mode",
    "relUrl": "/quick-start/states-and-automations-in-practice.html#sequence-mode"
  },"442": {
    "doc": "States & automations in practice",
    "title": "States & automations in practice",
    "content": " ",
    "url": "https://ossia.io/score-docs/quick-start/states-and-automations-in-practice.html",
    "relUrl": "/quick-start/states-and-automations-in-practice.html"
  },"443": {
    "doc": "Step sequencer",
    "title": "Step Sequencer",
    "content": ". Score has a separate step sequencer where you can edit the number of rows and the duration of each step. If the window is stretched beyond the last row, the sequencer will be automatically repeated. ",
    "url": "https://ossia.io/score-docs/processes/step.html#step-sequencer",
    "relUrl": "/processes/step.html#step-sequencer"
  },"444": {
    "doc": "Step sequencer",
    "title": "Step sequencer",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/step.html",
    "relUrl": "/processes/step.html"
  },"445": {
    "doc": "Syphon devices",
    "title": "Syphon",
    "content": "Syphon is a macOS-only protocol and library for sharing video textures across applications. ",
    "url": "https://ossia.io/score-docs/devices/syphon-devices.html#syphon",
    "relUrl": "/devices/syphon-devices.html#syphon"
  },"446": {
    "doc": "Syphon devices",
    "title": "Syphon input device",
    "content": "This device allows receiving a video stream directly from a Syphon-compatible input. Simply choose the wanted input in the list, and put the output at the end of the video chain. ",
    "url": "https://ossia.io/score-docs/devices/syphon-devices.html#syphon-input-device",
    "relUrl": "/devices/syphon-devices.html#syphon-input-device"
  },"447": {
    "doc": "Syphon devices",
    "title": "Syphon output device",
    "content": "This device allows to create a Syphon stream that other Syphon-compatible software will be able to display or modify. Simply choose the viewport options, a rendering rate, and a name for the output. You can then use the device as input to video filters. ",
    "url": "https://ossia.io/score-docs/devices/syphon-devices.html#syphon-output-device",
    "relUrl": "/devices/syphon-devices.html#syphon-output-device"
  },"448": {
    "doc": "Syphon devices",
    "title": "Syphon devices",
    "content": " ",
    "url": "https://ossia.io/score-docs/devices/syphon-devices.html",
    "relUrl": "/devices/syphon-devices.html"
  },"449": {
    "doc": "Tempo",
    "title": "Tempo",
    "content": "This process allows to add a tempo curve to an interval, and to control its speed programmatically through the dataflow system. When a tempo process is assigned to an interval, its speed behaviour is taken out of the parent hierarchy: the tempo is absolute and not impacted by the parent hierarchy’s speed: a tempo of 120 will always mean 120 in relation to the human referential. All the child intervals of this interval will however use this interval’s tempo, unless them theyselve get a tempo curve. This allows to write poly-tempo scores. If values are sent to the tempo process’s input port, then the curve is not used and the port instead is used as source for the parent interval’s tempo. ",
    "url": "https://ossia.io/score-docs/processes/tempo.html",
    "relUrl": "/processes/tempo.html"
  },"450": {
    "doc": "Tempo",
    "title": "Example",
    "content": ". ",
    "url": "https://ossia.io/score-docs/processes/tempo.html#example",
    "relUrl": "/processes/tempo.html#example"
  },"451": {
    "doc": "Texture generator",
    "title": "Texture generator",
    "content": "This process allows to live-code a texture generator for live visuals. The code is written in C++ (20). The function score_rgba will be called at every frame with the pixels of the texture to write into. The texture’s data is retained across frames. Be careful and save often: invalid memory accesses will make score crash ! . ",
    "url": "https://ossia.io/score-docs/processes/texgen.html",
    "relUrl": "/processes/texgen.html"
  },"452": {
    "doc": "Texture generator",
    "title": "Example",
    "content": "extern \"C\" void score_rgba(unsigned char* rgba, int width, int height, int t) { int k = 0; for(int j = 0; j &lt; height; j++) { for(int i = 0; i &lt; width; i++) { rgba[k++] = 255 * t * k / (width * height); rgba[k++] = 255 * t * k / (width * height); rgba[k++] = 255 * t * k / (width * height); rgba[k++] = 255 * t * k / (width * height); } } } . ",
    "url": "https://ossia.io/score-docs/processes/texgen.html#example",
    "relUrl": "/processes/texgen.html#example"
  },"453": {
    "doc": "Troubleshooting",
    "title": "Troubleshooting score issues",
    "content": " ",
    "url": "https://ossia.io/score-docs/troubleshooting.html#troubleshooting-score-issues",
    "relUrl": "/troubleshooting.html#troubleshooting-score-issues"
  },"454": {
    "doc": "Troubleshooting",
    "title": "score just crashed",
    "content": "Please send us a detailed bug report of what you were doing at the moment of the crash, along with any crashlog, in either the forum, the chat or the Github issues (preferably). Thanks ! . ",
    "url": "https://ossia.io/score-docs/troubleshooting.html#score-just-crashed",
    "relUrl": "/troubleshooting.html#score-just-crashed"
  },"455": {
    "doc": "Troubleshooting",
    "title": "score crashes immediately on first start-up on Windows",
    "content": "Check that you do not have the JACK2 ASIO driver installed. It is known to cause crashes on startup on Windows for many software. You can check the following registry key in the Windows registry editor: HKEY_LOCAL_MACHINE\\SOFTWARE\\ASIO. ",
    "url": "https://ossia.io/score-docs/troubleshooting.html#score-crashes-immediately-on-first-start-up-on-windows",
    "relUrl": "/troubleshooting.html#score-crashes-immediately-on-first-start-up-on-windows"
  },"456": {
    "doc": "Troubleshooting",
    "title": "score crashes immediately on first start-up on Linux",
    "content": "If you get an error from the terminal which looks like: . The program 'ossia-score' received an X Window System error. This probably reflects a bug in the program. The error was 'BadMatch (invalid parameter attributes)'. (Details: serial 363 error_code 8 request_code 154 minor_code 34) (Note to programmers: normally, X errors are reported asynchronously; that is, you will receive the error a while after causing it. To debug your program, run it with the --sync command line option to change this behavior. You can then get a meaningful backtrace from your debugger if you break on the gdk_x_error() function.) . Then this is likely an OpenGL driver issue. Try running score with the --no-opengl command-line flag. ",
    "url": "https://ossia.io/score-docs/troubleshooting.html#score-crashes-immediately-on-first-start-up-on-linux",
    "relUrl": "/troubleshooting.html#score-crashes-immediately-on-first-start-up-on-linux"
  },"457": {
    "doc": "Troubleshooting",
    "title": "The playback does not start",
    "content": "Most of the time, this is due to incorrect sound settings. Go to the settings and check that you have a valid sound card set. ",
    "url": "https://ossia.io/score-docs/troubleshooting.html#the-playback-does-not-start",
    "relUrl": "/troubleshooting.html#the-playback-does-not-start"
  },"458": {
    "doc": "Troubleshooting",
    "title": "The score runs but there is no sound",
    "content": "Most of the time, this is due to incorrect sound settings. Check that you are not using the Dummy driver which does not uses the soundcard. Go to the settings and check that the correct sound-card is selected for audio output (for instance, it happens that the sound card chosen is the HDMI output of the computer monitor, which may not have loudspeakers). ",
    "url": "https://ossia.io/score-docs/troubleshooting.html#the-score-runs-but-there-is-no-sound",
    "relUrl": "/troubleshooting.html#the-score-runs-but-there-is-no-sound"
  },"459": {
    "doc": "Troubleshooting",
    "title": "Playback seems to hang at random times on Linux",
    "content": "This is due to a PortAudio bug. Use the JACK backend instead. ",
    "url": "https://ossia.io/score-docs/troubleshooting.html#playback-seems-to-hang-at-random-times-on-linux",
    "relUrl": "/troubleshooting.html#playback-seems-to-hang-at-random-times-on-linux"
  },"460": {
    "doc": "Troubleshooting",
    "title": "Some VST plug-ins and virtual cameras do not work on Mac",
    "content": "You are likely encountering security-related macOS issues. As a workaround, you can follow the steps given in the above link to remove the code signing of the score binary, which will in turn make macOS allow score to open virtual webcams and any audio plug-ins. ",
    "url": "https://ossia.io/score-docs/troubleshooting.html#some-vst-plug-ins-and-virtual-cameras-do-not-work-on-mac",
    "relUrl": "/troubleshooting.html#some-vst-plug-ins-and-virtual-cameras-do-not-work-on-mac"
  },"461": {
    "doc": "Troubleshooting",
    "title": "The minimap is hard to use on Mac",
    "content": "You are likely encountering this macOS issue. As a workaround, you can try to open score by right-clicking on Score.app, selection “Open contents”, navigating to “Score.app/Contents/MacOS” and running the “score” binary from there. ",
    "url": "https://ossia.io/score-docs/troubleshooting.html#the-minimap-is-hard-to-use-on-mac",
    "relUrl": "/troubleshooting.html#the-minimap-is-hard-to-use-on-mac"
  },"462": {
    "doc": "Troubleshooting",
    "title": "Troubleshooting",
    "content": " ",
    "url": "https://ossia.io/score-docs/troubleshooting.html",
    "relUrl": "/troubleshooting.html"
  },"463": {
    "doc": "Address system",
    "title": "Unit system",
    "content": "score provides various features to ease the management of parameters. These are specially useful when writing complex processes (e.g automations). ",
    "url": "https://ossia.io/score-docs/in-depth/unit-system.html#unit-system",
    "relUrl": "/in-depth/unit-system.html#unit-system"
  },"464": {
    "doc": "Address system",
    "title": "Addressing items in arrays",
    "content": "When a parameter of a declared device defines a set of values (e.g parameters defining an XYZ position or an RGB color), items in this array can accessed independently using a special syntax: a parameter address may be followed by an integer (starting from zero) in brackets, which will select a given member. For example, using aDevice:/anAddress@[1] as a destination address of an automation will send the automation value to the second element in the array. If the array contains sub-arrays (for instance for a matrix), it is possible to address sub-elements like this: . aDevice:/anAddress@[1][0] . For instance, given . aDevice:/anAddress == [ [a, b], [c, d] ] . the above address will change the value of c. Note that without specifying an index, messages and automations sent to array parameters (i.e. vec2f, vec3f, list) will affect all items in the array. ",
    "url": "https://ossia.io/score-docs/in-depth/unit-system.html#addressing-items-in-arrays",
    "relUrl": "/in-depth/unit-system.html#addressing-items-in-arrays"
  },"465": {
    "doc": "Address system",
    "title": "Using unit conversion",
    "content": "Parameters of a device may be declared with a specific unit (for instance, parameters defining a position in space or a color). score embeds an automatic unit conversion mechanism for advanced automations. When using these parameters in ports of processes, it is also possible to set an unit set on them, with the same syntax than for array indexing: using aDevice:/anAddress@[angle.radian] as a destination address of an automation will send the value in this unit (ie. radian). The value will be converted back to the address’s original unit when sent over the network protocol, which may be for instance degrees. The complete list of supported units is available in the libossia documentation. In the case of multi-dimensional quantities (for instance, colors, 3D positions), it is also possible to select a single component: . aDevice:/anAddress[color.rgb.r] . as the output of an automation will only update the red component. This also works with different units: for instance, if the device has a parameter declared with the color.rgb unit, it is possible to control its hue with parameter@[color.hsv.h]. ",
    "url": "https://ossia.io/score-docs/in-depth/unit-system.html#using-unit-conversion",
    "relUrl": "/in-depth/unit-system.html#using-unit-conversion"
  },"466": {
    "doc": "Address system",
    "title": "Pattern matching",
    "content": "It is possible to control a set of addresses with pattern matching. For instance, given the following OSC device: . It is possible to send an automation to . OSCdevice:/sub/*/level . to control all the levels with a single curve. The complete reference of the supported pattern matching syntax is available here. ",
    "url": "https://ossia.io/score-docs/in-depth/unit-system.html#pattern-matching",
    "relUrl": "/in-depth/unit-system.html#pattern-matching"
  },"467": {
    "doc": "Address system",
    "title": "Address system",
    "content": " ",
    "url": "https://ossia.io/score-docs/in-depth/unit-system.html",
    "relUrl": "/in-depth/unit-system.html"
  },"468": {
    "doc": "Smooth",
    "title": "Smooth",
    "content": ". The Smooth process can be used to tame a noisy input stream, coming from a very sensitive sensor for example. The output of this process may be more usable than the raw stream to control other parameters. ",
    "url": "https://ossia.io/score-docs/processes/smooth.html",
    "relUrl": "/processes/smooth.html"
  },"469": {
    "doc": "Smooth",
    "title": "Amount",
    "content": "0 applies the least amount of filtering, 1 the most. ",
    "url": "https://ossia.io/score-docs/processes/smooth.html#amount",
    "relUrl": "/processes/smooth.html#amount"
  },"470": {
    "doc": "Smooth",
    "title": "Type",
    "content": "There are 4 different filters available: . | OneEuro for the 1€ filter. | LowPass that only uses the low pass implementation from the one euro filter. | Average for a floating average. | Median for a floating median. | . ",
    "url": "https://ossia.io/score-docs/processes/smooth.html#type",
    "relUrl": "/processes/smooth.html#type"
  },"471": {
    "doc": "Smooth",
    "title": "Freq (1e/LP)",
    "content": "Minimum cutoff frequency for OneEuro and LowPass, between 0 and 300. ",
    "url": "https://ossia.io/score-docs/processes/smooth.html#freq-1elp",
    "relUrl": "/processes/smooth.html#freq-1elp"
  },"472": {
    "doc": "Smooth",
    "title": "Cutoff (1e/LP)",
    "content": "Cutoff frequency of the derivative for OneEuro and LowPass, between 0 and 10. ",
    "url": "https://ossia.io/score-docs/processes/smooth.html#cutoff-1elp",
    "relUrl": "/processes/smooth.html#cutoff-1elp"
  },"473": {
    "doc": "Smooth",
    "title": "Beta (1e only)",
    "content": "Cutoff slope for OneEuro, between 0 and 10. ",
    "url": "https://ossia.io/score-docs/processes/smooth.html#beta-1e-only",
    "relUrl": "/processes/smooth.html#beta-1e-only"
  },"474": {
    "doc": "Video",
    "title": "Video",
    "content": "The video process allows to play a video. Video decoding is done with the help of the GPU as far as possible, e.g. for YUV420P or HAP data. Most common codecs and pixel formats are supported ; we use FFMPEG for decoding plus the HAP library by Vidvox for HAP videos. ",
    "url": "https://ossia.io/score-docs/processes/video.html",
    "relUrl": "/processes/video.html"
  },"475": {
    "doc": "Video",
    "title": "Usage",
    "content": "To add a video to a score, the simplest is to drag’n’drop it from the user library to the score. Videos loop by default to facilitate VJ use-cases. Otherwise a black screen would be shown when reaching the end. Do not forget to set a trigger at the end, though ! . The simplest way to play a video is as follows: . | Add a Window device device | Drop the video | Select the output port of the video process and assign it to the Window device device. | . See the example: . Note that for now the sound tracks contained in video files are not handled; this will be done in a later version. As a workaround, audio content can be extracted from the video and dropped on the same interval to preserve synchronization. The following ffmpeg command can be used to extract audio track from a given input file : . $ ffmpeg -i &lt;input_file&gt; extracted_audio.wav . ",
    "url": "https://ossia.io/score-docs/processes/video.html#usage",
    "relUrl": "/processes/video.html#usage"
  },"476": {
    "doc": "Video",
    "title": "Inspector controls",
    "content": "The video inspector allows to set a stretch mode and the timing behaviour: . | Stretch modes can be the usual stretch / fill / keep original. | Tempo is used to map the video to the score tempo, and to enable time-stretching with the Tempo process. If Use tempo is not set, then the video will play at its internal rate. Otherwise, it will assume that the video is at the given tempo, and play it faster / slower depending on the difference between that tempo and the score’s actual playback speed: a video set at 120 will play twice as slow if the score tempo is at 60. | . ",
    "url": "https://ossia.io/score-docs/processes/video.html#inspector-controls",
    "relUrl": "/processes/video.html#inspector-controls"
  },"477": {
    "doc": "Video",
    "title": "Limitations",
    "content": "While for simple playback any video format should work, we recommend using a seek-optimized format such as HAP or MJPEG when working on a score. This is because usual video formats for playback, such as H.264 or HEVC (H.265) make tradeoffs for better compression that make seeking much more complicated: in the theoretical worst case, the decoder needs to decode the entire video from the beginning when seeking which of course takes too long. To reencode a video into HAP, you can use ffmpeg from the command-line (or the Handbrake GUI). $ ffmpeg -i source.mov -c:v hap &lt;OPTIONS&gt; output.mov $ ffmpeg -i source.mov -c:v hap -format hap_alpha outputName.mov $ ffmpeg -i source.mov -c:v hap -format hap_q outputName.mov $ ffmpeg -i source.mov -c:v hap -compressor none outputName.mov $ ffmpeg -i source.mov -c:v hap -format hap_q -chunks 4 outputName.mov . The (optional) HAP-related options can be: . | -format hap_alpha for alpha-channel support | -format hap_q for HAP Q codec support | -compressor none slightly reduces playback CPU usage at the cost of larger file sizes. | -chunks &lt;N&gt; with N a number between 1 and 64: optimizes the file for a specific multi-core decoding configuration. | . ",
    "url": "https://ossia.io/score-docs/processes/video.html#limitations",
    "relUrl": "/processes/video.html#limitations"
  },"478": {
    "doc": "What is score ?",
    "title": "What is score ?",
    "content": "ossia score offers advanced tools to ease the authoring of time exigent projects involving medias: flexible score for a live performance, interactive scenario for an intermedia installation, game-like state machine scenarios, etc. It thus provides a unified place to write automations for the parameters of the devices involved in the project, provides means to author efficient mappings from device A to device B or to modulate some devices parameters using generative processes and so on. ",
    "url": "https://ossia.io/score-docs/quick-start/what-is-score.html",
    "relUrl": "/quick-start/what-is-score.html"
  },"479": {
    "doc": "What is score ?",
    "title": "Advanced time sequencing environment",
    "content": "When having to author scenarios for interactive art, music and sound performances, one often has to rely on two approaches: . | DAW / timeline-based software offering tools for fine time editing and parameters automation | cue-based software offering great flexibility in live situation | . While both approaches have numerous advantages, they also draw some limits in some advanced media-based productions: First type hardly offers (if any) flexibility in live situation regarding how events actually evolve in time. Second type makes it hard if possible at all to control precisely processes evolving over time. score thus aims at bridging the gap between these two models in a unified environment. By combining a flexible timeline with a patch-like authoring process, it allows to write precisely timed processes such as automations or more fancy parameters control and modulation while still maintaining some variations as the scenario is executed. But it also allows authoring open and non-linear scenarios yet still including some time-dependent processes. ",
    "url": "https://ossia.io/score-docs/quick-start/what-is-score.html#advanced-time-sequencing-environment",
    "relUrl": "/quick-start/what-is-score.html#advanced-time-sequencing-environment"
  },"480": {
    "doc": "What is score ?",
    "title": "Interoperability-based",
    "content": "ossia score aims to fully integrate with the favorite tools of artists and musicians involved in advanced media authoring. It allows to remotely control various commercial or custom software and hardware as well as to work with audio or video medias right from the app. While score itself offers some audio and video features, it does not aim at being an “All in one” super software (hence forcing intermedia authors to give up their personal toolset expertise). On the contrary, score was built from the ground up to be as interoperable as possible. Users remain thus free to use their tools of choice, be it their favorite VJing software, custom audio synthesis app or any specialized toolset. score 3.0.0 supports a number of protocols such as MIDI, Open Sound Control, OSCQuery or serial port making it easy to use score as the central hub of a project and thus author fine relationships between medias. ",
    "url": "https://ossia.io/score-docs/quick-start/what-is-score.html#interoperability-based",
    "relUrl": "/quick-start/what-is-score.html#interoperability-based"
  },"481": {
    "doc": "Wiimote device",
    "title": "Wiimote device",
    "content": ". Reference is not yet available. Feel more than welcome to ask for help on the ossia.io forum or send a message on ossia score Gitter channel where you will most likely find a handful of score users and developers. ",
    "url": "https://ossia.io/score-docs/devices/wiimote-device.html",
    "relUrl": "/devices/wiimote-device.html"
  },"482": {
    "doc": "Window device",
    "title": "Window properties",
    "content": ". | /screen: on which screen the window must be shown. | /position: absolute position of the window on the user’s viewport. | /size: window size in pixels. | /rendersize: the resolution at which rendering is done. If it is [0, 0] then the renderer is rescaled to follow the window resolution. | /fullscreen: show as fullscreen. Double-clicking on the window will also trigger this. | . ",
    "url": "https://ossia.io/score-docs/devices/window-device.html#window-properties",
    "relUrl": "/devices/window-device.html#window-properties"
  },"483": {
    "doc": "Window device",
    "title": "Mouse input",
    "content": ". | /cursor/scaled: mouse cursor position in the window scaled to [0;1] bounds. | /cursor/absolute: mouse cursor position in the window in pixels. | . ",
    "url": "https://ossia.io/score-docs/devices/window-device.html#mouse-input",
    "relUrl": "/devices/window-device.html#mouse-input"
  },"484": {
    "doc": "Window device",
    "title": "Tablet input",
    "content": ". | /tablet/scaled: tablet pen position in the window scaled to [0;1] bounds. | /tablet/absolute: tablet pen position in the window in pixels. | /tablet/z: tablet pen height. | /tablet/pressure: tablet pen pressure. | /tablet/rotation: tablet pen rotation. | /tablet/tangential: tablet pen tangential pressure. | /tablet/tilt_x and /tablet/tilt_y: tablet pen tilt. | . The values are extracted directly from Qt’s QTabletEvent. ",
    "url": "https://ossia.io/score-docs/devices/window-device.html#tablet-input",
    "relUrl": "/devices/window-device.html#tablet-input"
  },"485": {
    "doc": "Window device",
    "title": "Keyboard input",
    "content": ". | /key/code: low-level key code corresponding to the current user input. One per keystroke. | /key/text: high-level combined result of the user’s keystrokes. For instance, a user pressing “Shift + G” will yield a capital “G” text here. | . ",
    "url": "https://ossia.io/score-docs/devices/window-device.html#keyboard-input",
    "relUrl": "/devices/window-device.html#keyboard-input"
  },"486": {
    "doc": "Window device",
    "title": "Window device",
    "content": ". The Window device allows to show a window in which visuals will be rendered. Its device tree contains the following parameters: . ",
    "url": "https://ossia.io/score-docs/devices/window-device.html",
    "relUrl": "/devices/window-device.html"
  },"487": {
    "doc": "Working with audio",
    "title": "Working with audio in score",
    "content": " ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-audio.html#working-with-audio-in-score",
    "relUrl": "/quick-start/working-with-audio.html#working-with-audio-in-score"
  },"488": {
    "doc": "Working with audio",
    "title": "Audio setup",
    "content": "Before playing with audio sound files or synthesis in score you may want to ensure audio settings are properly set up. To do so, open the Preferences window from the score menu and select the “Audio” tab on the left side of the Preferences window. Then select the Driver you want to use as well as the desired audio interface and related options (Buffer size and sample rate). Make sure the audio switch is properly lit on. When done, you are ready to go ! . ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-audio.html#audio-setup",
    "relUrl": "/quick-start/working-with-audio.html#audio-setup"
  },"489": {
    "doc": "Working with audio",
    "title": "Playing audio file",
    "content": "Audio files can easily be integrated to your scenario. Just grab your file on your disk and drop it at the desired place on the timeline. Click the play button (or use spacebar shortcut) and that’s it. By default, score will use the main stereo output of your audio interface. Be sure to read the audio routing section for more information. ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-audio.html#playing-audio-file",
    "relUrl": "/quick-start/working-with-audio.html#playing-audio-file"
  },"490": {
    "doc": "Working with audio",
    "title": "Combining audio medias and devices control",
    "content": "Audio files (and more generally medias) can be fully combined with device’s automations or other processes in the scenario. Thus you can write medias playing and distant devices remote control at a single place. In the example below, we just want to play one audio file synchronously with some automations already in place. Rather than dropping our audio file on the timeline and align things by hand, we can just drop it on the automation’s slot top bar so it sticks to it. In this particular case, you may notice though that the dropped sound file is shorter than the full length of the automation. Just bring the audio file inspector and toggle the loop mode. Now when playing the scenario, the audio file will loop as long as the automation is playing. ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-audio.html#combining-audio-medias-and-devices-control",
    "relUrl": "/quick-start/working-with-audio.html#combining-audio-medias-and-devices-control"
  },"491": {
    "doc": "Working with audio",
    "title": "Adding audio effects",
    "content": "Contrary to some other software, score does not rely so much on the studio recording metaphor involving the usual mixing desk, per track FX, fixed busses and so on. Rather, it relies much more on a time-based modular approach. Without going too much into details of score engine for now, let’s just say that it offers to have a unique sound chain (audio source, FX or modulators) for each block of the scenario involving audio. As illustrated below, you can easily add some FX, either from the built-in library or some VST effects installed on your computer to some audio file in your scenario. When dropped, a patch-like workspace is created. For demonstration purpose here, we will just add a simple gain controller. Below the sound file waveform, you can note a red dot. This actually is the audio output. We can just drag a cable from this red dot down to the red circle (its input) at the left of the gain FX. When playing the scenario, audio file will now play through this simple FX and go out to the main output. Again, when the play-head gets beyond the automation’s slot, audio will get fully bypassed (hence preventing from any CPU drain). Feel free to get familiar with this patch workspace using other audio FX or VST of your own collection. You may also note some yellow circle and frames. These are respectively control input and output of some processes parameter. Should you feel adventurous, have fun checking the Control folder in the Process library to add modulation to your FX’s parameters. ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-audio.html#adding-audio-effects",
    "relUrl": "/quick-start/working-with-audio.html#adding-audio-effects"
  },"492": {
    "doc": "Working with audio",
    "title": "Working with audio",
    "content": " ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-audio.html",
    "relUrl": "/quick-start/working-with-audio.html"
  },"493": {
    "doc": "Working with devices",
    "title": "Working with your devices",
    "content": "score is built from the ground up to be as interoperable as possible with other devices involved in a creative project, whether they are software or hardware. When starting a project in score you will most likely want to start by setting up the devices score will be used with. ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-devices.html#working-with-your-devices",
    "relUrl": "/quick-start/working-with-devices.html#working-with-your-devices"
  },"494": {
    "doc": "Working with devices",
    "title": "Setting up your devices network",
    "content": "These devices can be freely added to your current score project from the Device explorer panel. Bring up the Device explorer panel using Ctrl+Shift+D(Win / Linux) or⌘+Shift+D(Mac) shortcut or click on the bottom left icon. Right click on the Device explorer panel and setup the desired communication protocol between score and your device. Remember you can at any time edit the settings of your device using right-click, then select Edit from the contextual menu . Score currently support the following devices types: . | OSC | Utilities | Hardware | Web | Lights | Audio | Video | . | OSCQuery | Mapper | Midi in | HTTP | Artnet | Audio | Window | . | OSC | Local | Midi out | WS |   |   | Camera | . | Minuit |   | Serial |   |   |   | Spout | . |   |   | Joystick |   |   |   | Syphon | . |   |   | Wiimote |   |   |   | Shmdata | . Detailed explanations on these various device types and corresponding setup options can be found in the Reference pages. ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-devices.html#setting-up-your-devices-network",
    "relUrl": "/quick-start/working-with-devices.html#setting-up-your-devices-network"
  },"495": {
    "doc": "Working with devices",
    "title": "Devices’ namespace browsing",
    "content": "The Device explorer provides a unified view of your devices parameters as a tree-like structure. Devices are exposed as a number of nodes (some key parts of your device) and their related parameters. From there you can freely browse your distant devices for monitoring or more importantly to select the parameters you want to control from score, as detailed in the next topic of this Quick start. ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-devices.html#devices-namespace-browsing",
    "relUrl": "/quick-start/working-with-devices.html#devices-namespace-browsing"
  },"496": {
    "doc": "Working with devices",
    "title": "Monitor &amp; remote control of parameters",
    "content": "The Device explorer also provides detailed information about your device parameters. Clicking a parameter from the namespace brings a dedicated inspector at the bottom, displaying it s various attributes, such as its current value (assuming your device echoes back its parameters value to score). You may also use this inspector to remotely change the value of a parameter (e.g. for testing purpose). ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-devices.html#monitor--remote-control-of-parameters",
    "relUrl": "/quick-start/working-with-devices.html#monitor--remote-control-of-parameters"
  },"497": {
    "doc": "Working with devices",
    "title": "Working with devices",
    "content": " ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-devices.html",
    "relUrl": "/quick-start/working-with-devices.html"
  },"498": {
    "doc": "Working with video",
    "title": "Working with video in score",
    "content": "score embeds a number of video related features: media playing and processing, GPU-based processing or synthesis. Just like with audio files, video files can be thus fully integrated to your scenario along with other processes and distant devices controls. ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-video.html#working-with-video-in-score",
    "relUrl": "/quick-start/working-with-video.html#working-with-video-in-score"
  },"499": {
    "doc": "Working with video",
    "title": "Supported formats",
    "content": "Score supports all video files formats supported by the FFMPEG library. More info on supported files can be found on the FFMPEG website. ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-video.html#supported-formats",
    "relUrl": "/quick-start/working-with-video.html#supported-formats"
  },"500": {
    "doc": "Working with video",
    "title": "Video setup",
    "content": "First, we need to setup our video output. To do so, we need to add a video window device to our project by right-clicking in the Device explorer pane and choose Add device from the contextual menu. In the device setup window, mouse over to the video category and choose the Window device. You may define a name for the video window or use the default name and click Add. When done, score creates a black video window. You can see in the Device explorer a device with the defined name. You will note that contrary to other devices used so far, this one has no parameters under its root node. This device basically only creates a video output window and rendering context. If the window is closed, it’s possible to open it again with a right-click on the device’s name and then click on show . ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-video.html#video-setup",
    "relUrl": "/quick-start/working-with-video.html#video-setup"
  },"501": {
    "doc": "Working with video",
    "title": "Playing a video file",
    "content": "To add a video file to the timeline, just grab your file on disk or in the project library and drop it where you want on the timeline. As seen in the previous section, you may as well drop it on top of some already existing automation’s slot so your video file is aligned. When done, a slot containing the video file gets created on the timeline. This creates a Video process. You can adjust the length of the slot to fit the part of the video file to play following the different key frames of the video. We now need to route our video file to our video window so it gets displayed when execution the scenario. Just as with other processes used so far (automation as well as audio), the video slot has an output port at the bottom: the white filled circle. Click on the output port to bring its inspector. From there, select your window video device in the dedicated menu. Now when executing your scenario, video file will get properly displayed in window. ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-video.html#playing-a-video-file",
    "relUrl": "/quick-start/working-with-video.html#playing-a-video-file"
  },"502": {
    "doc": "Working with video",
    "title": "Adding video effects",
    "content": "Again, similarly to audio files, you can easily drag some effects. From the Processes Library pane or from the User library pane, select one of the processes in the GFX category. In the example below, we will use the Shader filter provided in score default library. We now need to route our video file to the video effect rather than from the window. To do so, drag a cable from the video file output port (the white filled circle) to the effect input port (the white framed circle) as shown below. Then from the shader output port inspector, choose GFX as output. You may now play with the shader parameters using its UI as the scenario is executed or write some automations. ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-video.html#adding-video-effects",
    "relUrl": "/quick-start/working-with-video.html#adding-video-effects"
  },"503": {
    "doc": "Working with video",
    "title": "Working with video",
    "content": " ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-video.html",
    "relUrl": "/quick-start/working-with-video.html"
  },"504": {
    "doc": "Writing automations",
    "title": "Writing continuous parameter control",
    "content": "Score provides numerous features to control continuously your devices’ parameters over time. These are provided through the Process library available by clicking on the icon at the bottom left of score window (or using Ctrl+Shift+P(Win / Linux) or⌘+Shift+P(Mac) shortcut). In the example below, we will just create a basic breakpoint function-based automation for one of our device’s parameter, by selecting the automation (float) in the Process library, then drag &amp; drop it where we want it on the timeline. When done, you will see on the timeline a simple 1 segment linear default automation. Let’s now assign our device parameter as a destination for this simple automation process. Click on the automation’s slot top bar to bring its inspector. Now from the Device explorer drag the desired parameter on the address field. The automation is now assigned to our parameter. When playing the scenario, our device’s parameter will get driven by an ascending ramp as the playhead goes across the automation slot. Of course, you may refine your automation function by double-clicking in the automation slot to add more points or select a segment and use Shift+Drag to add curvature to the segment as well as using other advanced features as detailed in the Automation reference page. You can extend your automation slot by dragging along the timeline its top right corner (the blue dot). By default, slot will get extended will preserving the automation length so you can further write your automation. You may also drag it using Cmd+Drag to scale the automation as the slot gets extended along the timeline . Full size edit . When further precision is required to edit your automation, you can double-click the name above the automation slot (here “automation (float)” to zoom in the slot and edit the automation in full size. When done editing, you can go back to your scenario full view using Cmd+↑ or clicking on your scenario name beneath the time ruler. ",
    "url": "https://ossia.io/score-docs/quick-start/writing-automations.html#writing-continuous-parameter-control",
    "relUrl": "/quick-start/writing-automations.html#writing-continuous-parameter-control"
  },"505": {
    "doc": "Writing automations",
    "title": "Writing automations",
    "content": " ",
    "url": "https://ossia.io/score-docs/quick-start/writing-automations.html",
    "relUrl": "/quick-start/writing-automations.html"
  },"506": {
    "doc": "WebSocket device",
    "title": "WebSocket device",
    "content": ". This device allows to connect to an existing WebSocket server, and exchange messages bidirectionally. Since such servers can have arbitrarily complex APIs, we have to map these APIs to score’s tree-based parameter model. This is done with a QML script, just like for the Serial device and HTTP device devices. ",
    "url": "https://ossia.io/score-docs/devices/ws-device.html",
    "relUrl": "/devices/ws-device.html"
  },"507": {
    "doc": "WebSocket device",
    "title": "Sample code",
    "content": "Consider a WebSockets server which notifies about road traffic (available in the user library): . /** * To try: * - Install node.js * - npm install ws * - node RoadTrafficServer.js * * This server has the following API: * - It will regularly send the message to its clients: * { * sensorValue: { * name: \"Some place\", * value: 123 // the sensor reading, some dummy number which increments * } * } * * - It reacts to the following message: * { sensor: X } // X can be between 0 and 3 * * and will change the sensor being updated appropriately. * */ const ws = require(\"ws\"); const wss = new ws.WebSocketServer({ port: 8080 }); const clamp = (num, min, max) =&gt; Math.min(Math.max(num, min), max); let sensors = [ { name: \"Hôtel de ville\", value: 0 }, { name: \"St. Catherine\", value: 140 }, { name: \"Place de la Bourse\", value: 7 }, { name: \"Cours de la Libération\", value: 15 }, ]; let currentSensor = { sensorValue: sensors[0] }; let index = 0; wss.on('connection', function connection(ws) { ws.on('message', function message(data) { console.log('received: %s', data); const rq = JSON.parse(data); const idx = parseInt(rq.sensor); console.log(rq, clamp(idx, 0, 3)); currentSensor = { sensorValue: sensors[clamp(idx, 0, 3)] }; ws.send(JSON.stringify(currentSensor)); }); setInterval(() =&gt; { currentSensor.sensorValue.value ++; ws.send(JSON.stringify(currentSensor)); }, 100); }); . The following QML code is able to interact with it: . import Ossia 1.0 as Ossia // Note: to run this example you need to run the RoadTrafficServer.js // available in the library Ossia.WebSockets { property string host: \"ws://127.0.0.1:8080\" // Called whenever the Websocket gets connected function onConnected() { console.log(\"Connected !\") return [ ]; // Return type: see onMessage } // Called whenever the Websocket gets disconnected function onDisonnected() { console.log(\"Connected !\") return [ ]; // Return type: see onMessage } // Called whenever the Websocket server sends us a message function onMessage(message) { // The message has the format: // { // sensorValue: { // name: \"Some place\", // value: 123 // the sensor reading, some dummy number which increments // } // } // // We want to convert it into the following ossia address space // and apply a simple mapping: // // /traffic/name: \"Some place\" // /traffic/value: 1.23 // 1. Parse the json var res = JSON.parse(message); // 2. For each address to update in the tree, return a message: // { address: \"/foo/bar\", value: ... } return [ { address: \"/traffic/sensor\", value: res[\"sensorValue\"][\"value\"] / 100. }, { address: \"/traffic/name\", value: res[\"sensorValue\"][\"name\"] } ]; } // This is used to set-up the device tree with the relevant functions function createTree() { return [ { name: \"traffic\", children: [ // These two will just display the value from onMessage { name: \"sensor\", type: Ossia.Type.Float }, { name: \"name\", type: Ossia.Type.String }, // This one is a request to be made to the server { name: \"change_sensor\", type: Ossia.Type.Int, // For the three following functions, // the return value is sent to the WS server if not undefined: // 1. When a message is sent from score request: function (value) { // value is: // { // type: \"some_type\" // value: ... the actual value ... // } // e.g. { type: Ossia.Type.Int, value: 123 } // in order to differentiate between ints, floats, etc return JSON.stringify({ sensor: value.value }); }, // 2. When score listens on a node openListening: function () { console.log(\"open listening\"); }, // 3. When score stops listening on a node closeListening: function () { console.log(\"open listening\"); } } ] } ]; } } . ",
    "url": "https://ossia.io/score-docs/devices/ws-device.html#sample-code",
    "relUrl": "/devices/ws-device.html#sample-code"
  },"508": {
    "doc": "WebSocket device",
    "title": "Creating a device from existing JSON",
    "content": "Consider an API which regularly updates its clients with the following JSON: . { \"widget\": { \"debug\": \"on\", \"window\": { \"title\": \"Sample Konfabulator Widget\", \"name\": \"main_window\", \"width\": 500, \"height\": 500 }, \"image\": { \"src\": \"Images/Sun.png\", \"name\": \"sun1\", \"hOffset\": 250, \"vOffset\": 250, \"alignment\": \"center\" }, \"text\": { \"data\": \"Click Here\", \"size\": 36, \"style\": \"bold\", \"name\": \"text1\", \"hOffset\": 250, \"vOffset\": 100, \"alignment\": \"center\", \"onMouseUp\": \"sun1.opacity = (sun1.opacity / 100) * 90;\" } } } . This is a tree structure that maps very cleanly to score’s model. To facilitate this simple case, an user script is provided as part of the user library: it will take a sample JSON and create the relevant QML code. It is accessible in the Scripts/Protocols/Websockets/Device from JSON menu option. The processFromJson property on the root Ossia.WebSocket will enable automatic processing of incoming JSON: it will as far as possible be matched to the structure of the tree in order to update the parameters. Note that this is much more efficient than doing it manually through onMessage as this is implemented directly in C++. ",
    "url": "https://ossia.io/score-docs/devices/ws-device.html#creating-a-device-from-existing-json",
    "relUrl": "/devices/ws-device.html#creating-a-device-from-existing-json"
  }
}
